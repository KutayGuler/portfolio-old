var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_fs, import_node_path, import_node_worker_threads, import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    init_shims();
    import_node_fs = __toModule(require("node:fs"));
    import_node_path = __toModule(require("node:path"));
    import_node_worker_threads = __toModule(require("node:worker_threads"));
    init_install_fetch();
    import_node_http = __toModule(require("node:http"));
    import_node_https = __toModule(require("node:https"));
    import_node_zlib = __toModule(require("node:zlib"));
    import_node_stream = __toModule(require("node:stream"));
    import_node_util = __toModule(require("node:util"));
    import_node_url = __toModule(require("node:url"));
    import_net = __toModule(require("net"));
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream2.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net2.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options: options2 } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https2.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib2.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib2.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflate(), reject) : (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_node_http2, import_node_https2, import_node_zlib2, import_node_stream2, import_node_util2, import_node_url2, import_net2, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob3, Blob$1, _File, File, t, i, h, r, m, f2, e, x, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_node_http2 = __toModule(require("node:http"));
    import_node_https2 = __toModule(require("node:https"));
    import_node_zlib2 = __toModule(require("node:zlib"));
    import_node_stream2 = __toModule(require("node:stream"));
    import_node_util2 = __toModule(require("node:util"));
    import_node_url2 = __toModule(require("node:url"));
    import_net2 = __toModule(require("net"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    Blob$1 = Blob3;
    _File = class File2 extends Blob$1 {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options2 = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options2);
        if (options2 === null)
          options2 = {};
        const lastModified = options2.lastModified === void 0 ? Date.now() : Number(options2.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    };
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util2.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream2.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream2.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream2.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream2.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util2.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream2.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream2.PassThrough({ highWaterMark });
        p2 = new import_node_stream2.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util2.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util2.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream2.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http2.default.validateHeaderName === "function" ? import_node_http2.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http2.default.validateHeaderValue === "function" ? import_node_http2.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_node_util2.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url2.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options2 = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options: options2
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/@sveltejs/kit/dist/chunks/url.js
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
var absolute, scheme;
var init_url = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/url.js"() {
    init_shims();
    absolute = /^([a-z]+:)?\/?\//;
    scheme = /^[a-z]+:/;
  }
});

// node_modules/@sveltejs/kit/dist/chunks/error.js
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var init_error = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/error.js"() {
    init_shims();
  }
});

// node_modules/@sveltejs/kit/dist/ssr.js
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s3) {
  return typeof s3 === "string" || s3 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i2) {
    names.set(entry[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop2() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function writable(value, start = noop2) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function escape_json_string_in_html(str) {
  return escape2(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
function escape_html_attr(str) {
  return '"' + escape2(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape2(str, dict, unicode_encoder) {
  let result = "";
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    const char = str.charAt(i2);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i2];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page
}) {
  const css6 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css6.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css6).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
    init2 += options2.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${page && page.path ? try_serialize(page.path, (error3) => {
      throw new Error(`Failed to serialize page.path: ${error3.message}`);
    }) : null},
						query: new URLSearchParams(${page && page.query ? s$1(page.query.toString()) : ""}),
						params: ${page && page.params ? try_serialize(page.params, (error3) => {
      throw new Error(`Failed to serialize page.params: ${error3.message}`);
    }) : null}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += options2.amp ? `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>` : `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (is_root_relative(resolved)) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, _receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s2(response2.statusText)},"headers":${s2(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {}
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i2 === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e2 = coalesce_to_error(err);
            options2.handle_error(e2, request);
            status = 500;
            error2 = e2;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options2.load_component(route.b[i2]);
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e2 = coalesce_to_error(err);
                  options2.handle_error(e2, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                let if_none_match_value = request2.headers["if-none-match"];
                if (if_none_match_value?.startsWith('W/"')) {
                  if_none_match_value = if_none_match_value.substring(2);
                }
                const etag = `"${hash(response.body || "")}"`;
                if (if_none_match_value === etag) {
                  return {
                    status: 304,
                    headers: {}
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e2 = coalesce_to_error(err);
    options2.handle_error(e2, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e2.stack : e2.message
    };
  }
}
var chars, unsafeChars, reserved, escaped, objectProtoOwnPropertyNames, subscriber_queue, escape_json_string_in_html_dict, escape_html_attr_dict, s$1, s2, ReadOnlyFormData;
var init_ssr = __esm({
  "node_modules/@sveltejs/kit/dist/ssr.js"() {
    init_shims();
    init_url();
    init_error();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    escaped = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    Promise.resolve();
    subscriber_queue = [];
    escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    s$1 = JSON.stringify;
    s2 = JSON.stringify;
    ReadOnlyFormData = class {
      #map;
      constructor(map) {
        this.#map = map;
      }
      get(key) {
        const value = this.#map.get(key);
        return value && value[0];
      }
      getAll(key) {
        return this.#map.get(key);
      }
      has(key) {
        return this.#map.has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *entries() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *keys() {
        for (const [key] of this.#map)
          yield key;
      }
      *values() {
        for (const [, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield value[i2];
          }
        }
      }
    };
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    init_shims();
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i2 = 0; i2 < pairs.length; i2++) {
        var pair = pairs[i2];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] == '"') {
          val = val.slice(1, -1);
        }
        if (obj[key] == void 0) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e2) {
        return str;
      }
    }
  }
});

// node_modules/@lukeed/uuid/dist/index.mjs
function v4() {
  var i2 = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i2 = 256);
    while (i2--)
      BUFFER[i2] = 256 * Math.random() | 0;
    i2 = IDX = 0;
  }
  for (; i2 < 16; i2++) {
    num = BUFFER[IDX + i2];
    if (i2 == 6)
      out += HEX[num & 15 | 64];
    else if (i2 == 8)
      out += HEX[num & 63 | 128];
    else
      out += HEX[num];
    if (i2 & 1 && i2 > 1 && i2 < 11)
      out += "-";
  }
  IDX++;
  return out;
}
var IDX, HEX, BUFFER;
var init_dist = __esm({
  "node_modules/@lukeed/uuid/dist/index.mjs"() {
    init_shims();
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// .svelte-kit/output/server/chunks/__layout-a44d6e83.js
var layout_a44d6e83_exports = {};
__export(layout_a44d6e83_exports, {
  default: () => _layout
});
var import_cookie, _layout;
var init_layout_a44d6e83 = __esm({
  ".svelte-kit/output/server/chunks/__layout-a44d6e83.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie = __toModule(require_cookie());
    init_dist();
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${slots.default ? slots.default({}) : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/error-c7aa771f.js
var error_c7aa771f_exports = {};
__export(error_c7aa771f_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var import_cookie2, Error2;
var init_error_c7aa771f = __esm({
  ".svelte-kit/output/server/chunks/error-c7aa771f.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie2 = __toModule(require_cookie());
    init_dist();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape3(status)}</h1>

<pre>${escape3(error2.message)}</pre>



${error2.frame ? `<pre>${escape3(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape3(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-9b58d7d6.js
var index_9b58d7d6_exports = {};
__export(index_9b58d7d6_exports, {
  default: () => Routes
});
var import_cookie3, css, Routes;
var init_index_9b58d7d6 = __esm({
  ".svelte-kit/output/server/chunks/index-9b58d7d6.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie3 = __toModule(require_cookie());
    init_dist();
    css = {
      code: "section.svelte-qcwhck{font-family:'Roboto Mono', monospace;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh}h1.svelte-qcwhck{font-size:2rem;width:50%;padding:0;margin:0}h4.svelte-qcwhck{text-align:center;width:50%}button.svelte-qcwhck{margin-top:5%}@media screen and (max-width: 800px){h1.svelte-qcwhck{font-size:1rem;width:60%}}",
      map: null
    };
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      console.info = () => {
      };
      let originals = [
        "hello, i'm kutay, a computer science student living in wroclaw.",
        "check out my",
        "essays",
        "and",
        "library",
        "while you are here or click the button below."
      ];
      let [intro, check, essays, and, library, outro] = originals;
      let monologue = "";
      $$result.css.add(css);
      return `${$$result.head += `${$$result.title = `<title>Home</title>`, ""}`, ""}

<section class="${"svelte-qcwhck"}"><h1 class="${"svelte-qcwhck"}">${escape3(intro)}<br><br>${escape3(check)}
		<a href="${"/essays"}">${escape3(essays)}</a>
		${escape3(and)}
		<a href="${"/library"}">${escape3(library)}</a>
		${escape3(outro)}</h1>
	<button class="${"svelte-qcwhck"}">${escape3("gibberify")}</button>
	<h4 class="${"svelte-qcwhck"}">${escape3(monologue)}</h4>
</section>`;
    });
  }
});

// .svelte-kit/output/server/chunks/library-98fcbcbb.js
var library_98fcbcbb_exports = {};
__export(library_98fcbcbb_exports, {
  default: () => Library
});
function backInOut(t2) {
  const s3 = 1.70158 * 1.525;
  if ((t2 *= 2) < 1)
    return 0.5 * (t2 * t2 * ((s3 + 1) * t2 - s3));
  return 0.5 * ((t2 -= 2) * t2 * ((s3 + 1) * t2 + s3) + 2);
}
function backIn(t2) {
  const s3 = 1.70158;
  return t2 * t2 * ((s3 + 1) * t2 - s3);
}
function backOut(t2) {
  const s3 = 1.70158;
  return --t2 * t2 * ((s3 + 1) * t2 + s3) + 1;
}
function bounceOut(t2) {
  const a = 4 / 11;
  const b = 8 / 11;
  const c = 9 / 10;
  const ca = 4356 / 361;
  const cb = 35442 / 1805;
  const cc = 16061 / 1805;
  const t22 = t2 * t2;
  return t2 < a ? 7.5625 * t22 : t2 < b ? 9.075 * t22 - 9.9 * t2 + 3.4 : t2 < c ? ca * t22 - cb * t2 + cc : 10.8 * t2 * t2 - 20.52 * t2 + 10.72;
}
function bounceInOut(t2) {
  return t2 < 0.5 ? 0.5 * (1 - bounceOut(1 - t2 * 2)) : 0.5 * bounceOut(t2 * 2 - 1) + 0.5;
}
function bounceIn(t2) {
  return 1 - bounceOut(1 - t2);
}
function circInOut(t2) {
  if ((t2 *= 2) < 1)
    return -0.5 * (Math.sqrt(1 - t2 * t2) - 1);
  return 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
}
function circIn(t2) {
  return 1 - Math.sqrt(1 - t2 * t2);
}
function circOut(t2) {
  return Math.sqrt(1 - --t2 * t2);
}
function cubicInOut(t2) {
  return t2 < 0.5 ? 4 * t2 * t2 * t2 : 0.5 * Math.pow(2 * t2 - 2, 3) + 1;
}
function cubicIn(t2) {
  return t2 * t2 * t2;
}
function cubicOut(t2) {
  const f3 = t2 - 1;
  return f3 * f3 * f3 + 1;
}
function elasticInOut(t2) {
  return t2 < 0.5 ? 0.5 * Math.sin(13 * Math.PI / 2 * 2 * t2) * Math.pow(2, 10 * (2 * t2 - 1)) : 0.5 * Math.sin(-13 * Math.PI / 2 * (2 * t2 - 1 + 1)) * Math.pow(2, -10 * (2 * t2 - 1)) + 1;
}
function elasticIn(t2) {
  return Math.sin(13 * t2 * Math.PI / 2) * Math.pow(2, 10 * (t2 - 1));
}
function elasticOut(t2) {
  return Math.sin(-13 * (t2 + 1) * Math.PI / 2) * Math.pow(2, -10 * t2) + 1;
}
function expoInOut(t2) {
  return t2 === 0 || t2 === 1 ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 20 * t2 - 10) : -0.5 * Math.pow(2, 10 - t2 * 20) + 1;
}
function expoIn(t2) {
  return t2 === 0 ? t2 : Math.pow(2, 10 * (t2 - 1));
}
function expoOut(t2) {
  return t2 === 1 ? t2 : 1 - Math.pow(2, -10 * t2);
}
function quadInOut(t2) {
  t2 /= 0.5;
  if (t2 < 1)
    return 0.5 * t2 * t2;
  t2--;
  return -0.5 * (t2 * (t2 - 2) - 1);
}
function quadIn(t2) {
  return t2 * t2;
}
function quadOut(t2) {
  return -t2 * (t2 - 2);
}
function quartInOut(t2) {
  return t2 < 0.5 ? 8 * Math.pow(t2, 4) : -8 * Math.pow(t2 - 1, 4) + 1;
}
function quartIn(t2) {
  return Math.pow(t2, 4);
}
function quartOut(t2) {
  return Math.pow(t2 - 1, 3) * (1 - t2) + 1;
}
function quintInOut(t2) {
  if ((t2 *= 2) < 1)
    return 0.5 * t2 * t2 * t2 * t2 * t2;
  return 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
}
function quintIn(t2) {
  return t2 * t2 * t2 * t2 * t2;
}
function quintOut(t2) {
  return --t2 * t2 * t2 * t2 * t2 + 1;
}
function sineInOut(t2) {
  return -0.5 * (Math.cos(Math.PI * t2) - 1);
}
function sineIn(t2) {
  const v = Math.cos(t2 * Math.PI * 0.5);
  if (Math.abs(v) < 1e-14)
    return 1;
  else
    return 1 - v;
}
function sineOut(t2) {
  return Math.sin(t2 * Math.PI / 2);
}
function EventDispatcher() {
}
function Vector2(x2 = 0, y = 0) {
  this.x = x2;
  this.y = y;
}
function Matrix3() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
}
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
  Object.defineProperty(this, "id", { value: textureId++ });
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearMipmapLinearFilter;
  this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
  this.format = format2 !== void 0 ? format2 : RGBAFormat;
  this.internalFormat = null;
  this.type = type !== void 0 ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}
function Vector4(x2 = 0, y = 0, z = 0, w = 1) {
  this.x = x2;
  this.y = y;
  this.z = z;
  this.w = w;
}
function WebGLRenderTarget(width, height, options2) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options2 = options2 || {};
  this.texture = new Texture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
  this.texture.image = {};
  this.texture.image.width = width;
  this.texture.image.height = height;
  this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
  this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
  this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
  this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : true;
  this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
}
function WebGLMultisampleRenderTarget(width, height, options2) {
  WebGLRenderTarget.call(this, width, height, options2);
  this.samples = 4;
}
function Quaternion(x2 = 0, y = 0, z = 0, w = 1) {
  this._x = x2;
  this._y = y;
  this._z = z;
  this._w = w;
}
function Vector3(x2 = 0, y = 0, z = 0) {
  this.x = x2;
  this.y = y;
  this.z = z;
}
function Matrix4() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
}
function Euler(x2 = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
  this._x = x2;
  this._y = y;
  this._z = z;
  this._order = order;
}
function Layers() {
  this.mask = 1 | 0;
}
function Object3D() {
  Object.defineProperty(this, "id", { value: _object3DId++ });
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}
function Scene() {
  Object3D.call(this);
  this.type = "Scene";
  this.background = null;
  this.environment = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
function Box3(min, max) {
  this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
  this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
function Sphere(center, radius) {
  this.center = center !== void 0 ? center : new Vector3();
  this.radius = radius !== void 0 ? radius : -1;
}
function Ray(origin, direction) {
  this.origin = origin !== void 0 ? origin : new Vector3();
  this.direction = direction !== void 0 ? direction : new Vector3(0, 0, -1);
}
function Plane(normal, constant) {
  this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== void 0 ? constant : 0;
}
function Triangle(a, b, c) {
  this.a = a !== void 0 ? a : new Vector3();
  this.b = b !== void 0 ? b : new Vector3();
  this.c = c !== void 0 ? c : new Vector3();
}
function Color(r2, g, b) {
  if (g === void 0 && b === void 0) {
    return this.set(r2);
  }
  return this.setRGB(r2, g, b);
}
function hue2rgb(p, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t2);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
function Face3(a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
}
function Material() {
  Object.defineProperty(this, "id", { value: materialId++ });
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = "MeshBasicMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
}
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
}
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i2 = 1, l = array.length; i2 < l; ++i2) {
    if (array[i2] > max)
      max = array[i2];
  }
  return max;
}
function BufferGeometry() {
  Object.defineProperty(this, "id", { value: _bufferGeometryId += 2 });
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = { start: 0, count: Infinity };
  this.userData = {};
}
function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new MeshBasicMaterial();
  this.updateMorphTargets();
}
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);
  _vB$1.fromBufferAttribute(position, b);
  _vC$1.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = new Face3(a, b, c);
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
function Geometry() {
  Object.defineProperty(this, "id", { value: _geometryId += 2 });
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Geometry";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    "color": [1, 1, 1],
    "uv": [0, 0],
    "uv2": [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
function Camera$1() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
function PerspectiveCamera(fov2, aspect2, near, far) {
  Camera$1.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2 !== void 0 ? fov2 : 50;
  this.zoom = 1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.focus = 10;
  this.aspect = aspect2 !== void 0 ? aspect2 : 1;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
function CubeCamera(near, far, renderTarget) {
  Object3D.call(this);
  this.type = "CubeCamera";
  if (renderTarget.isWebGLCubeRenderTarget !== true) {
    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    return;
  }
  this.renderTarget = renderTarget;
  const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.layers = this.layers;
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.layers = this.layers;
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.layers = this.layers;
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.layers = this.layers;
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.layers = this.layers;
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.layers = this.layers;
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  this.update = function(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  };
  this.clear = function(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(renderTarget, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  };
}
function WebGLCubeRenderTarget(size, options2, dummy) {
  if (Number.isInteger(options2)) {
    console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
    options2 = dummy;
  }
  WebGLRenderTarget.call(this, size, size, options2);
}
function DataTexture(data, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
  this.image = { data: data || null, width: width || 1, height: height || 1 };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
  this.needsUpdate = true;
}
function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== void 0 ? p0 : new Plane(),
    p1 !== void 0 ? p1 : new Plane(),
    p2 !== void 0 ? p2 : new Plane(),
    p3 !== void 0 ? p3 : new Plane(),
    p4 !== void 0 ? p4 : new Plane(),
    p5 !== void 0 ? p5 : new Plane()
  ];
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = gl.FLOAT;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      type = gl.UNSIGNED_SHORT;
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = "PlaneGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = "PlaneBufferGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  width = width || 1;
  height = height || 1;
  const width_half = width / 2;
  const height_half = height / 2;
  const gridX = Math.floor(widthSegments) || 1;
  const gridY = Math.floor(heightSegments) || 1;
  const gridX1 = gridX + 1;
  const gridY1 = gridY + 1;
  const segment_width = width / gridX;
  const segment_height = height / gridY;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  for (let iy = 0; iy < gridY1; iy++) {
    const y = iy * segment_height - height_half;
    for (let ix = 0; ix < gridX1; ix++) {
      const x2 = ix * segment_width - width_half;
      vertices.push(x2, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  }
  for (let iy = 0; iy < gridY; iy++) {
    for (let ix = 0; ix < gridX; ix++) {
      const a = ix + gridX1 * iy;
      const b = ix + gridX1 * (iy + 1);
      const c = ix + 1 + gridX1 * (iy + 1);
      const d = ix + 1 + gridX1 * iy;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      const texture = background.isWebGLCubeRenderTarget ? background.texture : background;
      boxMesh.material.uniforms.envMap.value = texture;
      boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== void 0 ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry);
      if (updateBuffers)
        saveCache(geometry);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {}
    };
  }
  function needsUpdate(geometry) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length)
      return true;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
    }
    return false;
  }
  function saveCache(geometry) {
    const cache = {};
    const attributes2 = geometry.attributes;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
    }
    currentState.attributes = cache;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render2(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    const extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping() {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = cache.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    let nPlanes = planes !== null ? planes.length : 0, dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLExtensions(gl) {
  const extensions = {};
  return {
    has: function(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return !!extension;
    },
    get: function(name) {
      if (!this.has(name)) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extensions[name];
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = new WeakMap();
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    const buffergeometry = geometries.get(geometry);
    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }
    for (const name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    geometries.delete(geometry);
    const attribute = wireframeAttributes.get(buffergeometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(buffergeometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    let buffergeometry = geometries.get(geometry);
    if (buffergeometry)
      return buffergeometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === void 0) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }
      buffergeometry = geometry._bufferGeometry;
    }
    geometries.set(geometry, buffergeometry);
    info.memory.geometries++;
    return buffergeometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l = array.length; i2 < l; i2++) {
        attributes.update(array[i2], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
        const a = array[i2 + 0];
        const b = array[i2 + 1];
        const c = array[i2 + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
        const a = i2 + 0;
        const b = i2 + 1;
        const c = i2 + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render2.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render2.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render2.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render2.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render2.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render2.frame++;
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i2 = 0; i2 < length; i2++) {
        influences[i2] = [i2, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i2 = 0; i2 < length; i2++) {
      const influence = influences[i2];
      influence[0] = i2;
      influence[1] = objectInfluences[i2];
    }
    influences.sort(absNumericalSort);
    for (let i2 = 0; i2 < 8; i2++) {
      if (i2 < length && influences[i2][1]) {
        workInfluences[i2][0] = influences[i2][0];
        workInfluences[i2][1] = influences[i2][1];
      } else {
        workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i2][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      const influence = workInfluences[i2];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
        }
        morphInfluences[i2] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== void 0) {
          geometry.deleteAttribute("morphTarget" + i2);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== void 0) {
          geometry.deleteAttribute("morphNormal" + i2);
        }
        morphInfluences[i2] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  return {
    update,
    dispose
  };
}
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
  images = images !== void 0 ? images : [];
  mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
  format2 = format2 !== void 0 ? format2 : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
  this.flipY = false;
}
function DataTexture2DArray(data, width, height, depth) {
  Texture.call(this, null);
  this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}
function DataTexture3D(data, width, height, depth) {
  Texture.call(this, null);
  this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  let n = nBlocks * blockSize, r2 = arrayCacheF32[n];
  if (r2 === void 0) {
    r2 = new Float32Array(n);
    arrayCacheF32[n] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i2 = 0, l = a.length; i2 < l; i2++) {
    if (a[i2] !== b[i2])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i2 = 0, l = b.length; i2 < l; i2++) {
    a[i2] = b[i2];
  }
}
function allocTexUnits(textures, n) {
  let r2 = arrayCacheI32[n];
  if (r2 === void 0) {
    r2 = new Int32Array(n);
    arrayCacheI32[n] = r2;
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.safeSetTexture2D(v[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.safeSetTextureCube(v[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < n; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < n; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[ i \]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      " attribute mat4 instanceMatrix;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#version 300 es\n",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#version 300 es\n",
      "#define varying in",
      "out highp vec4 pc_fragColor;",
      "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = prefixVertex + vertexShader;
  const fragmentGlsl = prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, extensions, capabilities, bindingStates) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function allocateBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = material.envMap || environment;
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial,
      isShaderMaterial: material.isShaderMaterial,
      precision,
      instancing: object.isInstancedMesh === true,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.get("EXT_frag_depth") !== null,
      rendererExtensionDrawBuffers: isWebGL2 || extensions.get("WEBGL_draw_buffers") !== null,
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.get("EXT_shader_texture_lod") !== null,
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === void 0) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array.push(parameters[parameterNames[i2]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function onSceneDispose(event) {
    const scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    lists.delete(scene);
  }
  function get(scene, camera) {
    const cameras = lists.get(scene);
    let list;
    if (cameras === void 0) {
      list = new WebGLRenderList(properties);
      lists.set(scene, new WeakMap());
      lists.get(scene).set(camera, list);
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      list = cameras.get(camera);
      if (list === void 0) {
        list = new WebGLRenderList(properties);
        cameras.set(camera, list);
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights() {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, shadows, camera) {
    let r2 = 0, g = 0, b = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    const viewMatrix = camera.matrixWorldInverse;
    lights.sort(shadowCastingLightsFirst);
    for (let i2 = 0, l = lights.length; i2 < l; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  return {
    setup,
    state
  };
}
function WebGLRenderState() {
  const lights = new WebGLLights();
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates() {
  let renderStates = new WeakMap();
  function onSceneDispose(event) {
    const scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    renderStates.delete(scene);
  }
  function get(scene, camera) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState();
      renderStates.set(scene, new WeakMap());
      renderStates.get(scene).set(camera, renderState);
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      if (renderStates.get(scene).has(camera) === false) {
        renderState = new WebGLRenderState();
        renderStates.get(scene).set(camera, renderState);
      } else {
        renderState = renderStates.get(scene).get(camera);
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDepthMaterial";
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.setValues(parameters);
}
function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDistanceMaterial";
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1e3;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.setValues(parameters);
}
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizonal = shadowMaterialVertical.clone();
  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, stencilBuffer: false };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat, stencilBuffer: false };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a;
          g *= a;
          b *= a;
        }
        color.set(r2, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = null;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (!currentBlendingEnabled) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RGB32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RGB16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.RGB8;
    }
    if (glFormat === _gl.RGBA) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.RGBA8;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f3) {
    if (f3 === NearestFilter || f3 === NearestMipmapNearestFilter || f3 === NearestMipmapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    if (texture.image.length !== 6)
      return;
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      initTexture(textureProperties, texture);
      state.activeTexture(_gl.TEXTURE0 + slot);
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i2].image;
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length;
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    } else {
      state.activeTexture(_gl.TEXTURE0 + slot);
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
    }
  }
  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    const extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension) {
      if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
        return;
      if (texture.type === HalfFloatType && (isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null)
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataTexture2DArray)
      textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isDataTexture3D)
      textureType = _gl.TEXTURE_3D;
    initTexture(textureProperties, texture);
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = _gl.DEPTH_COMPONENT;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = _gl.DEPTH_COMPONENT32F;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = _gl.DEPTH_COMPONENT24;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
        } else {
          glInternalFormat = _gl.DEPTH_COMPONENT16;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
        glInternalFormat = _gl.DEPTH_STENCIL;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const glFormat = utils.convert(renderTarget.texture.format);
    const glType = utils.convert(renderTarget.texture.type);
    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = _gl.DEPTH_COMPONENT16;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const glFormat = utils.convert(renderTarget.texture.format);
      const glType = utils.convert(renderTarget.texture.type);
      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
      renderTarget.texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(renderTarget.texture.format);
          const glType = utils.convert(renderTarget.texture.type);
          const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2);
      }
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(_gl.TEXTURE_2D, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        if (renderTarget.depthBuffer)
          mask |= _gl.DEPTH_BUFFER_BIT;
        if (renderTarget.stencilBuffer)
          mask |= _gl.STENCIL_BUFFER_BIT;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
      setTextureCube(texture, slot);
    } else {
      setTextureCubeDynamic(texture, slot);
    }
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType)
      return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type)
      return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type)
      return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedShort565Type)
      return gl.UNSIGNED_SHORT_5_6_5;
    if (p === ByteType)
      return gl.BYTE;
    if (p === ShortType)
      return gl.SHORT;
    if (p === UnsignedShortType)
      return gl.UNSIGNED_SHORT;
    if (p === IntType)
      return gl.INT;
    if (p === UnsignedIntType)
      return gl.UNSIGNED_INT;
    if (p === FloatType)
      return gl.FLOAT;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return gl.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return gl.ALPHA;
    if (p === RGBFormat)
      return gl.RGB;
    if (p === RGBAFormat)
      return gl.RGBA;
    if (p === LuminanceFormat)
      return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat)
      return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat)
      return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat)
      return gl.DEPTH_STENCIL;
    if (p === RedFormat)
      return gl.RED;
    if (p === RedIntegerFormat)
      return gl.RED_INTEGER;
    if (p === RGFormat)
      return gl.RG;
    if (p === RGIntegerFormat)
      return gl.RG_INTEGER;
    if (p === RGBIntegerFormat)
      return gl.RGB_INTEGER;
    if (p === RGBAIntegerFormat)
      return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return gl.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}
function Group() {
  Object3D.call(this);
  this.type = "Group";
}
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({ type: event.type });
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({ type: "sessionend" });
  }
  function onRequestReferenceSpace(value) {
    referenceSpace = value;
    animation.setContext(session);
    animation.start();
    scope.isPresenting = true;
    scope.dispatchEvent({ type: "sessionstart" });
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({ baseLayer });
      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
      session.addEventListener("inputsourceschange", updateInputSources);
    }
  };
  function updateInputSources(event) {
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      inputSourcesMap.set(inputSources[i2], controllers[i2]);
    }
    for (let i2 = 0; i2 < event.removed.length; i2++) {
      const inputSource = event.removed[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({ type: "disconnected", data: inputSource });
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i2 = 0; i2 < event.added.length; i2++) {
      const inputSource = event.added[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({ type: "connected", data: inputSource });
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i2 = 0; i2 < cameras2.length; i2++) {
      updateCamera(cameras2[i2], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    const children = camera.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      children[i2].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i2 = 0; i2 < views.length; i2++) {
        const view = views[i2];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i2];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i2 === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      const controller = controllers[i2];
      const inputSource = inputSources[i2];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, environment, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material, environment);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, environment);
      } else {
        refreshUniformsStandard(uniforms, material, environment);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material, environment) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = material.envMap || environment;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      var maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material, environment) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap || environment) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, environment) {
    refreshUniformsStandard(uniforms, material, environment);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  const _this = this;
  let _isContextLost = false;
  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  let _currentArrayCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  const _clipping = new WebGLClipping();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error2) {
    console.error("THREE.WebGLRenderer: " + error2.message);
    throw error2;
  }
  let extensions, capabilities, state, info;
  let properties, textures, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    if (capabilities.isWebGL2 === false) {
      extensions.get("WEBGL_depth_texture");
      extensions.get("OES_texture_float");
      extensions.get("OES_texture_half_float");
      extensions.get("OES_texture_half_float_linear");
      extensions.get("OES_standard_derivatives");
      extensions.get("OES_element_index_uint");
      extensions.get("OES_vertex_array_object");
      extensions.get("ANGLE_instanced_arrays");
    }
    extensions.get("OES_texture_float_linear");
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities, bindingStates);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function() {
    return background.getClearColor();
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === void 0 || depth)
      bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === void 0 || stencil)
      bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(_gl.LINES);
      } else {
        renderer.setMode(_gl.TRIANGLES);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(_gl.LINES);
      } else if (object.isLineLoop) {
        renderer.setMode(_gl.LINE_LOOP);
      } else {
        renderer.setMode(_gl.LINE_STRIP);
      }
    } else if (object.isPoints) {
      renderer.setMode(_gl.POINTS);
    } else if (object.isSprite) {
      renderer.setMode(_gl.TRIANGLES);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function(object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    const compiled = new WeakMap();
    scene.traverse(function(object) {
      let material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            let material2 = material[i2];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (xr.isPresenting)
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      _clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled === true)
      _clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    currentRenderList = null;
    currentRenderState = null;
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l = groups.length; i2 < l; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }
  function initMaterial(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let program = materialProperties.program;
    let programChange = true;
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      materialProperties.lightsStateVersion = lightsStateVersion;
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      parameters2.uniforms = programCache.getUniforms(material, parameters2);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters2.uniforms;
      materialProperties.outputEncoding = parameters2.outputEncoding;
    }
    const programAttributes = program.getAttributes();
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      for (let i2 = 0; i2 < _this.maxMorphTargets; i2++) {
        if (programAttributes["morphTarget" + i2] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      for (let i2 = 0; i2 < _this.maxMorphNormals; i2++) {
        if (programAttributes["morphNormal" + i2] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (materialProperties.program === void 0) {
        initMaterial(material, scene, object);
      } else if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === void 0) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, environment, _pixelRatio, _height);
      if (m_uniforms.ltc_1 !== void 0)
        m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== void 0)
        m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value && _currentRenderTarget === null)
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    if (renderTarget) {
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace || 0];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x2, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level) {
    if (level === void 0)
      level = 0;
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
    if (level === void 0)
      level = 0;
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(_gl.TEXTURE_2D);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
function WebGL1Renderer(parameters) {
  WebGLRenderer.call(this, parameters);
}
function FogExp2(color, density) {
  this.name = "";
  this.color = new Color(color);
  this.density = density !== void 0 ? density : 25e-5;
}
function Fog(color, near, far) {
  this.name = "";
  this.color = new Color(color);
  this.near = near !== void 0 ? near : 1;
  this.far = far !== void 0 ? far : 1e3;
}
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = "SpriteMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.alphaMap = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.transparent = true;
  this.setValues(parameters);
}
function Sprite(material) {
  Object3D.call(this);
  this.type = "Sprite";
  if (_geometry === void 0) {
    _geometry = new BufferGeometry();
    const float32Array = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]);
    const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
    _geometry.setIndex([0, 1, 2, 0, 2, 3]);
    _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
    _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }
  this.geometry = _geometry;
  this.material = material !== void 0 ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
function LOD() {
  Object3D.call(this);
  this._currentLevel = 0;
  this.type = "LOD";
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
  this.autoUpdate = true;
}
function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
function Skeleton(bones, boneInverses) {
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  this.frame = -1;
  if (boneInverses === void 0) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn("THREE.Skeleton boneInverses is the wrong length.");
      this.boneInverses = [];
      for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.count = count;
  this.frustumCulled = false;
}
function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = "LineBasicMaterial";
  this.color = new Color(16777215);
  this.linewidth = 1;
  this.linecap = "round";
  this.linejoin = "round";
  this.morphTargets = false;
  this.setValues(parameters);
}
function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
  }
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new LineBasicMaterial();
  this.updateMorphTargets();
}
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineLoop";
}
function PointsMaterial(parameters) {
  Material.call(this);
  this.type = "PointsMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.alphaMap = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.setValues(parameters);
}
function Points(geometry, material) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new PointsMaterial();
  this.updateMorphTargets();
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
  this.format = format2 !== void 0 ? format2 : RGBFormat;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.generateMipmaps = false;
  const scope = this;
  function updateVideo() {
    scope.needsUpdate = true;
    video.requestVideoFrameCallback(updateVideo);
  }
  if ("requestVideoFrameCallback" in video) {
    video.requestVideoFrameCallback(updateVideo);
  }
}
function CompressedTexture(mipmaps, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
  this.image = { width, height };
  this.mipmaps = mipmaps;
  this.flipY = false;
  this.generateMipmaps = false;
}
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
  this.needsUpdate = true;
}
function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
  format2 = format2 !== void 0 ? format2 : DepthFormat;
  if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  }
  if (type === void 0 && format2 === DepthFormat)
    type = UnsignedShortType;
  if (type === void 0 && format2 === DepthStencilFormat)
    type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
  this.image = { width, height };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}
function WireframeGeometry(geometry) {
  BufferGeometry.call(this);
  this.type = "WireframeGeometry";
  const vertices = [];
  const edge = [0, 0], edges = {};
  const keys = ["a", "b", "c"];
  if (geometry && geometry.isGeometry) {
    const faces = geometry.faces;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      for (let j = 0; j < 3; j++) {
        const edge1 = face[keys[j]];
        const edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        const key = edge[0] + "," + edge[1];
        if (edges[key] === void 0) {
          edges[key] = { index1: edge[0], index2: edge[1] };
        }
      }
    }
    for (const key in edges) {
      const e2 = edges[key];
      let vertex = geometry.vertices[e2.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry.vertices[e2.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry && geometry.isBufferGeometry) {
    let vertex = new Vector3();
    if (geometry.index !== null) {
      const position = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;
      if (groups.length === 0) {
        groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
      }
      for (let o = 0, ol = groups.length; o < ol; ++o) {
        const group = groups[o];
        const start = group.start;
        const count = group.count;
        for (let i2 = start, l = start + count; i2 < l; i2 += 3) {
          for (let j = 0; j < 3; j++) {
            const edge1 = indices.getX(i2 + j);
            const edge2 = indices.getX(i2 + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = { index1: edge[0], index2: edge[1] };
            }
          }
        }
      }
      for (const key in edges) {
        const e2 = edges[key];
        vertex.fromBufferAttribute(position, e2.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e2.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      const position = geometry.attributes.position;
      for (let i2 = 0, l = position.count / 3; i2 < l; i2++) {
        for (let j = 0; j < 3; j++) {
          const index1 = 3 * i2 + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index2 = 3 * i2 + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  }
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
}
function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}
function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricBufferGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i2 = 0; i2 <= stacks; i2++) {
    const v = i2 / stacks;
    for (let j = 0; j <= slices; j++) {
      const u = j / slices;
      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, v);
    }
  }
  for (let i2 = 0; i2 < stacks; i2++) {
    for (let j = 0; j < slices; j++) {
      const a = i2 * sliceCount + j;
      const b = i2 * sliceCount + j + 1;
      const c = (i2 + 1) * sliceCount + j + 1;
      const d = (i2 + 1) * sliceCount + j;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = "PolyhedronGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}
function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = "PolyhedronBufferGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  radius = radius || 1;
  detail = detail || 0;
  const vertexBuffer = [];
  const uvBuffer = [];
  subdivide(detail);
  applyRadius(radius);
  generateUVs();
  this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
  this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
  if (detail === 0) {
    this.computeVertexNormals();
  } else {
    this.normalizeNormals();
  }
  function subdivide(detail2) {
    const a = new Vector3();
    const b = new Vector3();
    const c = new Vector3();
    for (let i2 = 0; i2 < indices.length; i2 += 3) {
      getVertexByIndex(indices[i2 + 0], a);
      getVertexByIndex(indices[i2 + 1], b);
      getVertexByIndex(indices[i2 + 2], c);
      subdivideFace(a, b, c, detail2);
    }
  }
  function subdivideFace(a, b, c, detail2) {
    const cols = Math.pow(2, detail2);
    const v = [];
    for (let i2 = 0; i2 <= cols; i2++) {
      v[i2] = [];
      const aj = a.clone().lerp(c, i2 / cols);
      const bj = b.clone().lerp(c, i2 / cols);
      const rows = cols - i2;
      for (let j = 0; j <= rows; j++) {
        if (j === 0 && i2 === cols) {
          v[i2][j] = aj;
        } else {
          v[i2][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    }
    for (let i2 = 0; i2 < cols; i2++) {
      for (let j = 0; j < 2 * (cols - i2) - 1; j++) {
        const k = Math.floor(j / 2);
        if (j % 2 === 0) {
          pushVertex(v[i2][k + 1]);
          pushVertex(v[i2 + 1][k]);
          pushVertex(v[i2][k]);
        } else {
          pushVertex(v[i2][k + 1]);
          pushVertex(v[i2 + 1][k + 1]);
          pushVertex(v[i2 + 1][k]);
        }
      }
    }
  }
  function applyRadius(radius2) {
    const vertex = new Vector3();
    for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
      vertex.x = vertexBuffer[i2 + 0];
      vertex.y = vertexBuffer[i2 + 1];
      vertex.z = vertexBuffer[i2 + 2];
      vertex.normalize().multiplyScalar(radius2);
      vertexBuffer[i2 + 0] = vertex.x;
      vertexBuffer[i2 + 1] = vertex.y;
      vertexBuffer[i2 + 2] = vertex.z;
    }
  }
  function generateUVs() {
    const vertex = new Vector3();
    for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
      vertex.x = vertexBuffer[i2 + 0];
      vertex.y = vertexBuffer[i2 + 1];
      vertex.z = vertexBuffer[i2 + 2];
      const u = azimuth(vertex) / 2 / Math.PI + 0.5;
      const v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }
    correctUVs();
    correctSeam();
  }
  function correctSeam() {
    for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
      const x0 = uvBuffer[i2 + 0];
      const x1 = uvBuffer[i2 + 2];
      const x2 = uvBuffer[i2 + 4];
      const max = Math.max(x0, x1, x2);
      const min = Math.min(x0, x1, x2);
      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2)
          uvBuffer[i2 + 0] += 1;
        if (x1 < 0.2)
          uvBuffer[i2 + 2] += 1;
        if (x2 < 0.2)
          uvBuffer[i2 + 4] += 1;
      }
    }
  }
  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }
  function getVertexByIndex(index, vertex) {
    const stride = index * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }
  function correctUVs() {
    const a = new Vector3();
    const b = new Vector3();
    const c = new Vector3();
    const centroid = new Vector3();
    const uvA = new Vector2();
    const uvB = new Vector2();
    const uvC = new Vector2();
    for (let i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
      a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
      b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
      c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      const azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }
  function correctUV(uv, stride, vector, azimuth2) {
    if (azimuth2 < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }
    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}
function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "TetrahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
function TetrahedronBufferGeometry(radius, detail) {
  const vertices = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ];
  const indices = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "TetrahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "OctahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
function OctahedronBufferGeometry(radius, detail) {
  const vertices = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ];
  const indices = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "OctahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "IcosahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
function IcosahedronBufferGeometry(radius, detail) {
  const t2 = (1 + Math.sqrt(5)) / 2;
  const vertices = [
    -1,
    t2,
    0,
    1,
    t2,
    0,
    -1,
    -t2,
    0,
    1,
    -t2,
    0,
    0,
    -1,
    t2,
    0,
    1,
    t2,
    0,
    -1,
    -t2,
    0,
    1,
    -t2,
    t2,
    0,
    -1,
    t2,
    0,
    1,
    -t2,
    0,
    -1,
    -t2,
    0,
    1
  ];
  const indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "IcosahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "DodecahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
function DodecahedronBufferGeometry(radius, detail) {
  const t2 = (1 + Math.sqrt(5)) / 2;
  const r2 = 1 / t2;
  const vertices = [
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    0,
    -r2,
    -t2,
    0,
    -r2,
    t2,
    0,
    r2,
    -t2,
    0,
    r2,
    t2,
    -r2,
    -t2,
    0,
    -r2,
    t2,
    0,
    r2,
    -t2,
    0,
    r2,
    t2,
    0,
    -t2,
    0,
    -r2,
    t2,
    0,
    -r2,
    -t2,
    0,
    r2,
    t2,
    0,
    r2
  ];
  const indices = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "DodecahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = "TubeGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  if (taper !== void 0)
    console.warn("THREE.TubeGeometry: taper has been removed.");
  const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals;
  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = "TubeBufferGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  const frames = path.computeFrenetFrames(tubularSegments, closed);
  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals;
  const vertex = new Vector3();
  const normal = new Vector3();
  const uv = new Vector2();
  let P = new Vector3();
  const vertices = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  generateBufferData();
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateBufferData() {
    for (let i2 = 0; i2 < tubularSegments; i2++) {
      generateSegment(i2);
    }
    generateSegment(closed === false ? tubularSegments : 0);
    generateUVs();
    generateIndices();
  }
  function generateSegment(i2) {
    P = path.getPointAt(i2 / tubularSegments, P);
    const N = frames.normals[i2];
    const B = frames.binormals[i2];
    for (let j = 0; j <= radialSegments; j++) {
      const v = j / radialSegments * Math.PI * 2;
      const sin = Math.sin(v);
      const cos = -Math.cos(v);
      normal.x = cos * N.x + sin * B.x;
      normal.y = cos * N.y + sin * B.y;
      normal.z = cos * N.z + sin * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z);
      vertex.x = P.x + radius * normal.x;
      vertex.y = P.y + radius * normal.y;
      vertex.z = P.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  function generateIndices() {
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
        const b = (radialSegments + 1) * j + (i2 - 1);
        const c = (radialSegments + 1) * j + i2;
        const d = (radialSegments + 1) * (j - 1) + i2;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }
  function generateUVs() {
    for (let i2 = 0; i2 <= tubularSegments; i2++) {
      for (let j = 0; j <= radialSegments; j++) {
        uv.x = i2 / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = "TorusKnotGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  if (heightScale !== void 0)
    console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}
function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = "TorusKnotBufferGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const vertex = new Vector3();
  const normal = new Vector3();
  const P1 = new Vector3();
  const P2 = new Vector3();
  const B = new Vector3();
  const T = new Vector3();
  const N = new Vector3();
  for (let i2 = 0; i2 <= tubularSegments; ++i2) {
    const u = i2 / tubularSegments * p * Math.PI * 2;
    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T);
    B.normalize();
    N.normalize();
    for (let j = 0; j <= radialSegments; ++j) {
      const v = j / radialSegments * Math.PI * 2;
      const cx = -tube * Math.cos(v);
      const cy = tube * Math.sin(v);
      vertex.x = P1.x + (cx * N.x + cy * B.x);
      vertex.y = P1.y + (cx * N.y + cy * B.y);
      vertex.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i2 / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (let j = 1; j <= tubularSegments; j++) {
    for (let i2 = 1; i2 <= radialSegments; i2++) {
      const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
      const b = (radialSegments + 1) * j + (i2 - 1);
      const c = (radialSegments + 1) * j + i2;
      const d = (radialSegments + 1) * (j - 1) + i2;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function calculatePositionOnCurve(u, p2, q2, radius2, position) {
    const cu = Math.cos(u);
    const su = Math.sin(u);
    const quOverP = q2 / p2 * u;
    const cs = Math.cos(quOverP);
    position.x = radius2 * (2 + cs) * 0.5 * cu;
    position.y = radius2 * (2 + cs) * su * 0.5;
    position.z = radius2 * Math.sin(quOverP) * 0.5;
  }
}
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = "TorusGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = "TorusBufferGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const center = new Vector3();
  const vertex = new Vector3();
  const normal = new Vector3();
  for (let j = 0; j <= radialSegments; j++) {
    for (let i2 = 0; i2 <= tubularSegments; i2++) {
      const u = i2 / tubularSegments * arc;
      const v = j / radialSegments * Math.PI * 2;
      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex.z = tube * Math.sin(v);
      vertices.push(vertex.x, vertex.y, vertex.z);
      center.x = radius * Math.cos(u);
      center.y = radius * Math.sin(u);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i2 / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (let j = 1; j <= radialSegments; j++) {
    for (let i2 = 1; i2 <= tubularSegments; i2++) {
      const a = (tubularSegments + 1) * j + i2 - 1;
      const b = (tubularSegments + 1) * (j - 1) + i2 - 1;
      const c = (tubularSegments + 1) * (j - 1) + i2;
      const d = (tubularSegments + 1) * j + i2;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  let a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  let a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  let minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  let minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    let a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  let queue = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      let x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m2 = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  let stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p = m2;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
        m2 = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m2;
}
function sectorContainsSector(m2, p) {
  return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i2, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x2 | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r2) {
  return (q.y - p.y) * (r2.x - q.x) - (q.x - p.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r2) {
  return q.x <= Math.max(p.x, r2.x) && q.x >= Math.min(p.x, r2.x) && q.y <= Math.max(p.y, r2.y) && q.y >= Math.min(p.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  let a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i2, x2, y, last) {
  const p = new Node(i2, x2, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i2, x2, y) {
  this.i = i2;
  this.x = x2;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
    sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
    j = i2;
  }
  return sum;
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
function ExtrudeGeometry(shapes, options2) {
  Geometry.call(this);
  this.type = "ExtrudeGeometry";
  this.parameters = {
    shapes,
    options: options2
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options2));
  this.mergeVertices();
}
function ExtrudeBufferGeometry(shapes, options2) {
  BufferGeometry.call(this);
  this.type = "ExtrudeBufferGeometry";
  this.parameters = {
    shapes,
    options: options2
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  const scope = this;
  const verticesArray = [];
  const uvArray = [];
  for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
    const shape = shapes[i2];
    addShape(shape);
  }
  this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals();
  function addShape(shape) {
    const placeholder = [];
    const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
    const steps = options2.steps !== void 0 ? options2.steps : 1;
    let depth = options2.depth !== void 0 ? options2.depth : 100;
    let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
    let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 6;
    let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 2;
    let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
    let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
    const extrudePath = options2.extrudePath;
    const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
    if (options2.amount !== void 0) {
      console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
      depth = options2.amount;
    }
    let extrudePts, extrudeByPath = false;
    let splineTube, binormal, normal, position2;
    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false;
      splineTube = extrudePath.computeFrenetFrames(steps, false);
      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    }
    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
      bevelOffset = 0;
    }
    const shapePoints = shape.extractPoints(curveSegments);
    let vertices = shapePoints.shape;
    const holes = shapePoints.holes;
    const reverse = !ShapeUtils.isClockWise(vertices);
    if (reverse) {
      vertices = vertices.reverse();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        if (ShapeUtils.isClockWise(ahole)) {
          holes[h2] = ahole.reverse();
        }
      }
    }
    const faces = ShapeUtils.triangulateShape(vertices, holes);
    const contour = vertices;
    for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
      const ahole = holes[h2];
      vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
      if (!vec)
        console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }
    const vlen = vertices.length, flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
      let v_trans_x, v_trans_y, shrink_by;
      const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
      const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
      const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
      const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
      if (Math.abs(collinear0) > Number.EPSILON) {
        const v_prev_len = Math.sqrt(v_prev_lensq);
        const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
        const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        const ptNextShift_x = inNext.x - v_next_y / v_next_len;
        const ptNextShift_y = inNext.y + v_next_x / v_next_len;
        const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
        const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        let direction_eq = false;
        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }
        if (direction_eq) {
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }
      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    const contourMovements = [];
    for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
      if (j === il)
        j = 0;
      if (k === il)
        k = 0;
      contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
    }
    const holesMovements = [];
    let oneHoleMovements, verticesMovements = contourMovements.concat();
    for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
      const ahole = holes[h2];
      oneHoleMovements = [];
      for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
      }
      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (let b = 0; b < bevelSegments; b++) {
      const t2 = b / bevelSegments;
      const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
      const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
      for (let i2 = 0, il = contour.length; i2 < il; i2++) {
        const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
        v(vert.x, vert.y, -z);
      }
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = holesMovements[h2];
        for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
          const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
          v(vert.x, vert.y, -z);
        }
      }
    }
    const bs = bevelSize + bevelOffset;
    for (let i2 = 0; i2 < vlen; i2++) {
      const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
    for (let s3 = 1; s3 <= steps; s3++) {
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v(vert.x, vert.y, depth / steps * s3);
        } else {
          normal.copy(splineTube.normals[s3]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s3]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s3]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    }
    for (let b = bevelSegments - 1; b >= 0; b--) {
      const t2 = b / bevelSegments;
      const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
      const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
      for (let i2 = 0, il = contour.length; i2 < il; i2++) {
        const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
        v(vert.x, vert.y, depth + z);
      }
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = holesMovements[h2];
        for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
          const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
          }
        }
      }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
      const start = verticesArray.length / 3;
      if (bevelEnabled) {
        let layer = 0;
        let offset = vlen * layer;
        for (let i2 = 0; i2 < flen; i2++) {
          const face = faces[i2];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }
        layer = steps + bevelSegments * 2;
        offset = vlen * layer;
        for (let i2 = 0; i2 < flen; i2++) {
          const face = faces[i2];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        for (let i2 = 0; i2 < flen; i2++) {
          const face = faces[i2];
          f3(face[2], face[1], face[0]);
        }
        for (let i2 = 0; i2 < flen; i2++) {
          const face = faces[i2];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }
      scope.addGroup(start, verticesArray.length / 3 - start, 0);
    }
    function buildSideFaces() {
      const start = verticesArray.length / 3;
      let layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        sidewalls(ahole, layeroffset);
        layeroffset += ahole.length;
      }
      scope.addGroup(start, verticesArray.length / 3 - start, 1);
    }
    function sidewalls(contour2, layeroffset) {
      let i2 = contour2.length;
      while (--i2 >= 0) {
        const j = i2;
        let k = i2 - 1;
        if (k < 0)
          k = contour2.length - 1;
        for (let s3 = 0, sl = steps + bevelSegments * 2; s3 < sl; s3++) {
          const slen1 = vlen * s3;
          const slen2 = vlen * (s3 + 1);
          const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
          f4(a, b, c, d);
        }
      }
    }
    function v(x2, y, z) {
      placeholder.push(x2);
      placeholder.push(y);
      placeholder.push(z);
    }
    function f3(a, b, c) {
      addVertex(a);
      addVertex(b);
      addVertex(c);
      const nextIndex = verticesArray.length / 3;
      const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }
    function f4(a, b, c, d) {
      addVertex(a);
      addVertex(b);
      addVertex(d);
      addVertex(b);
      addVertex(c);
      addVertex(d);
      const nextIndex = verticesArray.length / 3;
      const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }
    function addVertex(index) {
      verticesArray.push(placeholder[index * 3 + 0]);
      verticesArray.push(placeholder[index * 3 + 1]);
      verticesArray.push(placeholder[index * 3 + 2]);
    }
    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}
function toJSON$1(shapes, options2, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options2.extrudePath !== void 0)
    data.options.extrudePath = options2.extrudePath.toJSON();
  return data;
}
function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = "TextGeometry";
  this.parameters = {
    text,
    parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}
function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  const font = parameters.font;
  if (!(font && font.isFont)) {
    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
    return new Geometry();
  }
  const shapes = font.generateShapes(text, parameters.size);
  parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
  if (parameters.bevelThickness === void 0)
    parameters.bevelThickness = 10;
  if (parameters.bevelSize === void 0)
    parameters.bevelSize = 8;
  if (parameters.bevelEnabled === void 0)
    parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = "TextBufferGeometry";
}
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "SphereGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "SphereBufferGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== void 0 ? phiStart : 0;
  phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
  const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
  let index = 0;
  const grid = [];
  const vertex = new Vector3();
  const normal = new Vector3();
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  for (let iy = 0; iy <= heightSegments; iy++) {
    const verticesRow = [];
    const v = iy / heightSegments;
    let uOffset = 0;
    if (iy == 0 && thetaStart == 0) {
      uOffset = 0.5 / widthSegments;
    } else if (iy == heightSegments && thetaEnd == Math.PI) {
      uOffset = -0.5 / widthSegments;
    }
    for (let ix = 0; ix <= widthSegments; ix++) {
      const u = ix / widthSegments;
      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.copy(vertex).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u + uOffset, 1 - v);
      verticesRow.push(index++);
    }
    grid.push(verticesRow);
  }
  for (let iy = 0; iy < heightSegments; iy++) {
    for (let ix = 0; ix < widthSegments; ix++) {
      const a = grid[iy][ix + 1];
      const b = grid[iy][ix];
      const c = grid[iy + 1][ix];
      const d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0)
        indices.push(a, b, d);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
        indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "RingGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "RingBufferGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let radius = innerRadius;
  const radiusStep = (outerRadius - innerRadius) / phiSegments;
  const vertex = new Vector3();
  const uv = new Vector2();
  for (let j = 0; j <= phiSegments; j++) {
    for (let i2 = 0; i2 <= thetaSegments; i2++) {
      const segment = thetaStart + i2 / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    radius += radiusStep;
  }
  for (let j = 0; j < phiSegments; j++) {
    const thetaSegmentLevel = j * (thetaSegments + 1);
    for (let i2 = 0; i2 < thetaSegments; i2++) {
      const segment = i2 + thetaSegmentLevel;
      const a = segment;
      const b = segment + thetaSegments + 1;
      const c = segment + thetaSegments + 2;
      const d = segment + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = "LatheGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = "LatheBufferGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2;
  phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
  const indices = [];
  const vertices = [];
  const uvs = [];
  const inverseSegments = 1 / segments;
  const vertex = new Vector3();
  const uv = new Vector2();
  for (let i2 = 0; i2 <= segments; i2++) {
    const phi = phiStart + i2 * inverseSegments * phiLength;
    const sin = Math.sin(phi);
    const cos = Math.cos(phi);
    for (let j = 0; j <= points.length - 1; j++) {
      vertex.x = points[j].x * sin;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos;
      vertices.push(vertex.x, vertex.y, vertex.z);
      uv.x = i2 / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  }
  for (let i2 = 0; i2 < segments; i2++) {
    for (let j = 0; j < points.length - 1; j++) {
      const base2 = j + i2 * points.length;
      const a = base2;
      const b = base2 + points.length;
      const c = base2 + points.length + 1;
      const d = base2 + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  this.computeVertexNormals();
  if (phiLength === Math.PI * 2) {
    const normals = this.attributes.normal.array;
    const n1 = new Vector3();
    const n2 = new Vector3();
    const n = new Vector3();
    const base2 = segments * points.length * 3;
    for (let i2 = 0, j = 0; i2 < points.length; i2++, j += 3) {
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2];
      n2.x = normals[base2 + j + 0];
      n2.y = normals[base2 + j + 1];
      n2.z = normals[base2 + j + 2];
      n.addVectors(n1, n2).normalize();
      normals[j + 0] = normals[base2 + j + 0] = n.x;
      normals[j + 1] = normals[base2 + j + 1] = n.y;
      normals[j + 2] = normals[base2 + j + 2] = n.z;
    }
  }
}
function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = "ShapeGeometry";
  if (typeof curveSegments === "object") {
    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
    curveSegments = curveSegments.curveSegments;
  }
  this.parameters = {
    shapes,
    curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}
function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = "ShapeBufferGeometry";
  this.parameters = {
    shapes,
    curveSegments
  };
  curveSegments = curveSegments || 12;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let groupStart = 0;
  let groupCount = 0;
  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (let i2 = 0; i2 < shapes.length; i2++) {
      addShape(shapes[i2]);
      this.addGroup(groupStart, groupCount, i2);
      groupStart += groupCount;
      groupCount = 0;
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function addShape(shape) {
    const indexOffset = vertices.length / 3;
    const points = shape.extractPoints(curveSegments);
    let shapeVertices = points.shape;
    const shapeHoles = points.holes;
    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }
    for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
      const shapeHole = shapeHoles[i2];
      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i2] = shapeHole.reverse();
      }
    }
    const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
    for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
      const shapeHole = shapeHoles[i2];
      shapeVertices = shapeVertices.concat(shapeHole);
    }
    for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
      const vertex = shapeVertices[i2];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y);
    }
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      const a = face[0] + indexOffset;
      const b = face[1] + indexOffset;
      const c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
function EdgesGeometry(geometry, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = "EdgesGeometry";
  this.parameters = {
    thresholdAngle
  };
  thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
  const vertices = [];
  const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
  const edge = [0, 0], edges = {};
  let edge1, edge2, key;
  const keys = ["a", "b", "c"];
  let geometry2;
  if (geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
  } else {
    geometry2 = geometry.clone();
  }
  geometry2.mergeVertices();
  geometry2.computeFaceNormals();
  const sourceVertices = geometry2.vertices;
  const faces = geometry2.faces;
  for (let i2 = 0, l = faces.length; i2 < l; i2++) {
    const face = faces[i2];
    for (let j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + "," + edge[1];
      if (edges[key] === void 0) {
        edges[key] = { index1: edge[0], index2: edge[1], face1: i2, face2: void 0 };
      } else {
        edges[key].face2 = i2;
      }
    }
  }
  for (key in edges) {
    const e2 = edges[key];
    if (e2.face2 === void 0 || faces[e2.face1].normal.dot(faces[e2.face2].normal) <= thresholdDot) {
      let vertex = sourceVertices[e2.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e2.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
}
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CylinderBufferGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  const scope = this;
  radiusTop = radiusTop !== void 0 ? radiusTop : 1;
  radiusBottom = radiusBottom !== void 0 ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== void 0 ? openEnded : false;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let index = 0;
  const indexArray = [];
  const halfHeight = height / 2;
  let groupStart = 0;
  generateTorso();
  if (openEnded === false) {
    if (radiusTop > 0)
      generateCap(true);
    if (radiusBottom > 0)
      generateCap(false);
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateTorso() {
    const normal = new Vector3();
    const vertex = new Vector3();
    let groupCount = 0;
    const slope = (radiusBottom - radiusTop) / height;
    for (let y = 0; y <= heightSegments; y++) {
      const indexRow = [];
      const v = y / heightSegments;
      const radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (let x2 = 0; x2 <= radialSegments; x2++) {
        const u = x2 / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, 1 - v);
        indexRow.push(index++);
      }
      indexArray.push(indexRow);
    }
    for (let x2 = 0; x2 < radialSegments; x2++) {
      for (let y = 0; y < heightSegments; y++) {
        const a = indexArray[y][x2];
        const b = indexArray[y + 1][x2];
        const c = indexArray[y + 1][x2 + 1];
        const d = indexArray[y][x2 + 1];
        indices.push(a, b, d);
        indices.push(b, c, d);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, 0);
    groupStart += groupCount;
  }
  function generateCap(top) {
    let centerIndexStart, centerIndexEnd;
    const uv = new Vector2();
    const vertex = new Vector3();
    let groupCount = 0;
    const radius = top === true ? radiusTop : radiusBottom;
    const sign2 = top === true ? 1 : -1;
    centerIndexStart = index;
    for (let x2 = 1; x2 <= radialSegments; x2++) {
      vertices.push(0, halfHeight * sign2, 0);
      normals.push(0, sign2, 0);
      uvs.push(0.5, 0.5);
      index++;
    }
    centerIndexEnd = index;
    for (let x2 = 0; x2 <= radialSegments; x2++) {
      const u = x2 / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign2;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, sign2, 0);
      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign2 + 0.5;
      uvs.push(uv.x, uv.y);
      index++;
    }
    for (let x2 = 0; x2 < radialSegments; x2++) {
      const c = centerIndexStart + x2;
      const i2 = centerIndexEnd + x2;
      if (top === true) {
        indices.push(i2, i2 + 1, c);
      } else {
        indices.push(i2 + 1, i2, c);
      }
      groupCount += 3;
    }
    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
    groupStart += groupCount;
  }
}
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeBufferGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CircleGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CircleBufferGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  segments = segments !== void 0 ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const vertex = new Vector3();
  const uv = new Vector2();
  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);
  for (let s3 = 0, i2 = 3; s3 <= segments; s3++, i2 += 3) {
    const segment = thetaStart + s3 / segments * thetaLength;
    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z);
    normals.push(0, 0, 1);
    uv.x = (vertices[i2] / radius + 1) / 2;
    uv.y = (vertices[i2 + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  }
  for (let i2 = 1; i2 <= segments; i2++) {
    indices.push(i2, i2 + 1, 0);
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = "ShadowMaterial";
  this.color = new Color(0);
  this.transparent = true;
  this.setValues(parameters);
}
function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = "RawShaderMaterial";
}
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = { "STANDARD": "" };
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    "STANDARD": "",
    "PHYSICAL": ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = "MeshPhongMaterial";
  this.color = new Color(16777215);
  this.specular = new Color(1118481);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
function MeshToonMaterial(parameters) {
  Material.call(this);
  this.defines = { "TOON": "" };
  this.type = "MeshToonMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.gradientMap = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = "MeshNormalMaterial";
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = "MeshLambertMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = { "MATCAP": "" };
  this.type = "MeshMatcapMaterial";
  this.color = new Color(16777215);
  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = "LineDashedMaterial";
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
function KeyframeTrack(name, times, values, interpolation) {
  if (name === void 0)
    throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (times === void 0 || times.length === 0)
    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
}
function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}
function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
function AnimationClip(name, duration, tracks, blendMode) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== void 0 ? duration : -1;
  this.blendMode = blendMode !== void 0 ? blendMode : NormalAnimationBlendMode;
  this.uuid = MathUtils.generateUUID();
  if (this.duration < 0) {
    this.resetDuration();
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
      const regex = handlers[i2];
      const loader = handlers[i2 + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
function FileLoader(manager) {
  Loader.call(this, manager);
}
function AnimationLoader(manager) {
  Loader.call(this, manager);
}
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
function ImageLoader(manager) {
  Loader.call(this, manager);
}
function CubeTextureLoader(manager) {
  Loader.call(this, manager);
}
function TextureLoader(manager) {
  Loader.call(this, manager);
}
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = "EllipseCurve";
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = "ArcCurve";
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init2(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init2(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = "CatmullRomCurve3";
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || "centripetal";
  this.tension = tension !== void 0 ? tension : 0.5;
}
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p) {
  const k = 1 - t2;
  return k * k * p;
}
function QuadraticBezierP1(t2, p) {
  return 2 * (1 - t2) * t2 * p;
}
function QuadraticBezierP2(t2, p) {
  return t2 * t2 * p;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p) {
  const k = 1 - t2;
  return k * k * k * p;
}
function CubicBezierP1(t2, p) {
  const k = 1 - t2;
  return 3 * k * k * t2 * p;
}
function CubicBezierP2(t2, p) {
  return 3 * (1 - t2) * t2 * t2 * p;
}
function CubicBezierP3(t2, p) {
  return t2 * t2 * t2 * p;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}
function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}
function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve";
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve3";
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
function SplineCurve(points) {
  Curve.call(this);
  this.type = "SplineCurve";
  this.points = points || [];
}
function CurvePath() {
  Curve.call(this);
  this.type = "CurvePath";
  this.curves = [];
  this.autoClose = false;
}
function Path(points) {
  CurvePath.call(this);
  this.type = "Path";
  this.currentPoint = new Vector2();
  if (points) {
    this.setFromPoints(points);
  }
}
function Shape(points) {
  Path.call(this, points);
  this.uuid = MathUtils.generateUUID();
  this.type = "Shape";
  this.holes = [];
}
function Light$1(color, intensity) {
  Object3D.call(this);
  this.type = "Light";
  this.color = new Color(color);
  this.intensity = intensity !== void 0 ? intensity : 1;
  this.receiveShadow = void 0;
}
function HemisphereLight(skyColor, groundColor, intensity) {
  Light$1.call(this, skyColor, intensity);
  this.type = "HemisphereLight";
  this.castShadow = void 0;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}
function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.normalBias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.mapPass = null;
  this.matrix = new Matrix4();
  this.autoUpdate = true;
  this.needsUpdate = false;
  this._frustum = new Frustum();
  this._frameExtents = new Vector2(1, 1);
  this._viewportCount = 1;
  this._viewports = [
    new Vector4(0, 0, 1, 1)
  ];
}
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light$1.call(this, color, intensity);
  this.type = "SpotLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(power) {
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== void 0 ? distance : 0;
  this.angle = angle !== void 0 ? angle : Math.PI / 3;
  this.penumbra = penumbra !== void 0 ? penumbra : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new SpotLightShadow();
}
function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
  this._frameExtents = new Vector2(4, 2);
  this._viewportCount = 6;
  this._viewports = [
    new Vector4(2, 1, 1, 1),
    new Vector4(0, 1, 1, 1),
    new Vector4(3, 1, 1, 1),
    new Vector4(1, 1, 1, 1),
    new Vector4(3, 0, 1, 1),
    new Vector4(1, 0, 1, 1)
  ];
  this._cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
  ];
  this._cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
}
function PointLight(color, intensity, distance, decay) {
  Light$1.call(this, color, intensity);
  this.type = "PointLight";
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(power) {
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== void 0 ? distance : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new PointLightShadow();
}
function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera$1.call(this);
  this.type = "OrthographicCamera";
  this.zoom = 1;
  this.view = null;
  this.left = left !== void 0 ? left : -1;
  this.right = right !== void 0 ? right : 1;
  this.top = top !== void 0 ? top : 1;
  this.bottom = bottom !== void 0 ? bottom : -1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.updateProjectionMatrix();
}
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
function DirectionalLight(color, intensity) {
  Light$1.call(this, color, intensity);
  this.type = "DirectionalLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}
function AmbientLight(color, intensity) {
  Light$1.call(this, color, intensity);
  this.type = "AmbientLight";
  this.castShadow = void 0;
}
function RectAreaLight(color, intensity, width, height) {
  Light$1.call(this, color, intensity);
  this.type = "RectAreaLight";
  this.width = width !== void 0 ? width : 10;
  this.height = height !== void 0 ? height : 10;
}
function SphericalHarmonics3() {
  this.coefficients = [];
  for (let i2 = 0; i2 < 9; i2++) {
    this.coefficients.push(new Vector3());
  }
}
function LightProbe(sh, intensity) {
  Light$1.call(this, void 0, intensity);
  this.type = "LightProbe";
  this.sh = sh !== void 0 ? sh : new SphericalHarmonics3();
}
function MaterialLoader(manager) {
  Loader.call(this, manager);
  this.textures = {};
}
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
function BufferGeometryLoader(manager) {
  Loader.call(this, manager);
}
function ObjectLoader(manager) {
  Loader.call(this, manager);
}
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = { premultiplyAlpha: "none" };
}
function ShapePath() {
  this.type = "ShapePath";
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}
function Font(data) {
  this.type = "Font";
  this.data = data;
}
function createPaths(text, size, data) {
  const chars2 = Array.from ? Array.from(text) : String(text).split("");
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars2.length; i2++) {
    const char = chars2[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x2, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l = outline.length; i2 < l; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x2 = outline[i2++] * scale + offsetX;
          y = outline[i2++] * scale + offsetY;
          path.moveTo(x2, y);
          break;
        case "l":
          x2 = outline[i2++] * scale + offsetX;
          y = outline[i2++] * scale + offsetY;
          path.lineTo(x2, y);
          break;
        case "q":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          cpx2 = outline[i2++] * scale + offsetX;
          cpy2 = outline[i2++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}
function FontLoader(manager) {
  Loader.call(this, manager);
}
function AudioLoader(manager) {
  Loader.call(this, manager);
}
function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, void 0, intensity);
  const color1 = new Color().set(skyColor);
  const color2 = new Color().set(groundColor);
  const sky = new Vector3(color1.r, color1.g, color1.b);
  const ground = new Vector3(color2.r, color2.g, color2.b);
  const c0 = Math.sqrt(Math.PI);
  const c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}
function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, void 0, intensity);
  const color1 = new Color().set(color);
  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
function StereoCamera() {
  this.type = "StereoCamera";
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
  this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
function Clock(autoStart) {
  this.autoStart = autoStart !== void 0 ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}
function AudioListener() {
  Object3D.call(this);
  this.type = "AudioListener";
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0;
  this._clock = new Clock();
}
function Audio(listener) {
  Object3D.call(this);
  this.type = "Audio";
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.loopStart = 0;
  this.loopEnd = 0;
  this.offset = 0;
  this.duration = void 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = "empty";
  this._startedAt = 0;
  this._progress = 0;
  this.filters = [];
}
function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.panningModel = "HRTF";
  this.panner.connect(this.gain);
}
function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}
function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  let mixFunction, mixFunctionAdditive, setIdentity;
  switch (typeName) {
    case "quaternion":
      mixFunction = this._slerp;
      mixFunctionAdditive = this._slerpAdditive;
      setIdentity = this._setAdditiveIdentityQuaternion;
      this.buffer = new Float64Array(valueSize * 6);
      this._workIndex = 5;
      break;
    case "string":
    case "bool":
      mixFunction = this._select;
      mixFunctionAdditive = this._select;
      setIdentity = this._setAdditiveIdentityOther;
      this.buffer = new Array(valueSize * 5);
      break;
    default:
      mixFunction = this._lerp;
      mixFunctionAdditive = this._lerpAdditive;
      setIdentity = this._setAdditiveIdentityNumeric;
      this.buffer = new Float64Array(valueSize * 5);
  }
  this._mixBufferRegion = mixFunction;
  this._mixBufferRegionAdditive = mixFunctionAdditive;
  this._setIdentity = setIdentity;
  this._origIndex = 3;
  this._addIndex = 4;
  this.cumulativeWeight = 0;
  this.cumulativeWeightAdditive = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
function AnimationObjectGroup() {
  this.uuid = MathUtils.generateUUID();
  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0;
  const indices = {};
  this._indicesByUUID = indices;
  for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
    indices[arguments[i2].uuid] = i2;
  }
  this._paths = [];
  this._parsedPaths = [];
  this._bindings = [];
  this._bindingsIndicesByPath = {};
  const scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },
      get inUse() {
        return this.total - scope.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return scope._bindings.length;
    }
  };
}
function AnimationAction(mixer, clip, localRoot, blendMode) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  this.blendMode = blendMode || clip.blendMode;
  const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
  const interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };
  for (let i2 = 0; i2 !== nTracks; ++i2) {
    const interpolant = tracks[i2].createInterpolant(null);
    interpolants[i2] = interpolant;
    interpolant.settings = interpolantSettings;
  }
  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants;
  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null;
  this._byClipCacheIndex = null;
  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1;
  this._startTime = null;
  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity;
  this.paused = false;
  this.enabled = true;
  this.clampWhenFinished = false;
  this.zeroSlopeAtStart = true;
  this.zeroSlopeAtEnd = true;
}
function AnimationMixer(root) {
  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1;
}
function Uniform(value) {
  if (typeof value === "string") {
    console.warn("THREE.Uniform: Type parameter is no longer needed.");
    value = arguments[1];
  }
  this.value = value;
}
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction);
  this.near = near || 0;
  this.far = far || Infinity;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: { threshold: 1 },
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      intersectObject(children[i2], raycaster, intersects2, true);
    }
  }
}
function Cylindrical(radius, theta, y) {
  this.radius = radius !== void 0 ? radius : 1;
  this.theta = theta !== void 0 ? theta : 0;
  this.y = y !== void 0 ? y : 0;
  return this;
}
function Box2(min, max) {
  this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
  this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
}
function Line3(start, end) {
  this.start = start !== void 0 ? start : new Vector3();
  this.end = end !== void 0 ? end : new Vector3();
}
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
function SpotLightHelper(light, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  const geometry = new BufferGeometry();
  const positions = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ];
  for (let i2 = 0, j = 1, l = 32; i2 < l; i2++, j++) {
    const p1 = i2 / l * Math.PI * 2;
    const p2 = j / l * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
  }
  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
  const material = new LineBasicMaterial({ fog: false, toneMapped: false });
  this.cone = new LineSegments(geometry, material);
  this.add(this.cone);
  this.update();
}
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
function SkeletonHelper(object) {
  const bones = getBoneList(object);
  const geometry = new BufferGeometry();
  const vertices = [];
  const colors = [];
  const color1 = new Color(0, 0, 1);
  const color2 = new Color(0, 1, 0);
  for (let i2 = 0; i2 < bones.length; i2++) {
    const bone = bones[i2];
    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
  LineSegments.call(this, geometry, material);
  this.type = "SkeletonHelper";
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}
function PointLightHelper(light, sphereSize, color) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color;
  const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
  const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
  Mesh.call(this, geometry, material);
  this.type = "PointLightHelper";
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
}
function HemisphereLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  const geometry = new OctahedronBufferGeometry(size);
  geometry.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
  if (this.color === void 0)
    this.material.vertexColors = true;
  const position = geometry.getAttribute("position");
  const colors = new Float32Array(position.count * 3);
  geometry.setAttribute("color", new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry, this.material));
  this.update();
}
function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  const center = divisions / 2;
  const step = size / divisions;
  const halfSize = size / 2;
  const vertices = [], colors = [];
  for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
    vertices.push(-halfSize, 0, k, halfSize, 0, k);
    vertices.push(k, 0, -halfSize, k, 0, halfSize);
    const color = i2 === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
  }
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
  LineSegments.call(this, geometry, material);
  this.type = "GridHelper";
}
function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  const vertices = [];
  const colors = [];
  for (let i2 = 0; i2 <= radials; i2++) {
    const v = i2 / radials * (Math.PI * 2);
    const x2 = Math.sin(v) * radius;
    const z = Math.cos(v) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x2, 0, z);
    const color = i2 & 1 ? color1 : color2;
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
  }
  for (let i2 = 0; i2 <= circles; i2++) {
    const color = i2 & 1 ? color1 : color2;
    const r2 = radius - radius / circles * i2;
    for (let j = 0; j < divisions; j++) {
      let v = j / divisions * (Math.PI * 2);
      let x2 = Math.sin(v) * r2;
      let z = Math.cos(v) * r2;
      vertices.push(x2, 0, z);
      colors.push(color.r, color.g, color.b);
      v = (j + 1) / divisions * (Math.PI * 2);
      x2 = Math.sin(v) * r2;
      z = Math.cos(v) * r2;
      vertices.push(x2, 0, z);
      colors.push(color.r, color.g, color.b);
    }
  }
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
  LineSegments.call(this, geometry, material);
  this.type = "PolarGridHelper";
}
function DirectionalLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  if (size === void 0)
    size = 1;
  let geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute([
    -size,
    size,
    0,
    size,
    size,
    0,
    size,
    -size,
    0,
    -size,
    -size,
    0,
    -size,
    size,
    0
  ], 3));
  const material = new LineBasicMaterial({ fog: false, toneMapped: false });
  this.lightPlane = new Line(geometry, material);
  this.add(this.lightPlane);
  geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry, material);
  this.add(this.targetLine);
  this.update();
}
function CameraHelper(camera) {
  const geometry = new BufferGeometry();
  const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
  const vertices = [];
  const colors = [];
  const pointMap = {};
  const colorFrustum = new Color(16755200);
  const colorCone = new Color(16711680);
  const colorUp = new Color(43775);
  const colorTarget = new Color(16777215);
  const colorCross = new Color(3355443);
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }
  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);
    if (pointMap[id] === void 0) {
      pointMap[id] = [];
    }
    pointMap[id].push(vertices.length / 3 - 1);
  }
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry, material);
  this.type = "CameraHelper";
  this.camera = camera;
  if (this.camera.updateProjectionMatrix)
    this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}
function setPoint(point, pointMap, geometry, camera, x2, y, z) {
  _vector.set(x2, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
    }
  }
}
function BoxHelper(object, color) {
  this.object = object;
  if (color === void 0)
    color = 16776960;
  const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  const positions = new Float32Array(8 * 3);
  const geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.setAttribute("position", new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({ color, toneMapped: false }));
  this.type = "BoxHelper";
  this.matrixAutoUpdate = false;
  this.update();
}
function Box3Helper(box, color) {
  this.type = "Box3Helper";
  this.box = box;
  if (color === void 0)
    color = 16776960;
  const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  const geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({ color, toneMapped: false }));
  this.type = "Box3Helper";
  this.geometry.computeBoundingSphere();
}
function PlaneHelper(plane, size, hex) {
  this.plane = plane;
  this.size = size === void 0 ? 1 : size;
  const color = hex !== void 0 ? hex : 16776960;
  const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  Line.call(this, geometry, new LineBasicMaterial({ color, toneMapped: false }));
  this.type = "PlaneHelper";
  const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  const geometry2 = new BufferGeometry();
  geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
}
function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
  Object3D.call(this);
  this.type = "ArrowHelper";
  if (dir === void 0)
    dir = new Vector3(0, 0, 1);
  if (origin === void 0)
    origin = new Vector3(0, 0, 0);
  if (length === void 0)
    length = 1;
  if (color === void 0)
    color = 16776960;
  if (headLength === void 0)
    headLength = 0.2 * length;
  if (headWidth === void 0)
    headWidth = 0.2 * headLength;
  if (_lineGeometry === void 0) {
    _lineGeometry = new BufferGeometry();
    _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
    _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
    _coneGeometry.translate(0, -0.5, 0);
  }
  this.position.copy(origin);
  this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}
function AxesHelper(size) {
  size = size || 1;
  const vertices = [
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size
  ];
  const colors = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ];
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
  LineSegments.call(this, geometry, material);
  this.type = "AxesHelper";
}
function _createPlanes() {
  const _lodPlanes = [];
  const _sizeLods = [];
  const _sigmas = [];
  let lod = LOD_MAX;
  for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
    } else if (i2 == 0) {
      sigma = 0;
    }
    _sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y,
        0,
        x2 + 2 / 3,
        y,
        0,
        x2 + 2 / 3,
        y + 1,
        0,
        x2,
        y,
        0,
        x2 + 2 / 3,
        y + 1,
        0,
        x2,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes, _sizeLods, _sigmas };
}
function Spline(points) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
  CatmullRomCurve3.call(this, points);
  this.type = "catmullrom";
}
function isValidArray3Prop(p) {
  let isValid = false;
  p && p.constructor === Array && p.length === 3 ? isValid = true : null;
  return isValid;
}
function isArray(p) {
  return p && p.constructor === Array;
}
function isValidMatrix4(p) {
  p ? console.error("SVELTHREE > passing a Matrix4 as prop is not implemented yet!") : null;
  return false;
}
function writable2(value, start = noop3) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
            subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function tryMatrixUpdate$1() {
  console.error("SVELTHREE > Camera : updating Matrix is not yet implemented!");
}
function getPointerData(e2) {
  let pointerData = {
    pointerId: 1976 + e2["pointerId"],
    width: e2["width"],
    height: e2["height"],
    pressure: e2["pressure"],
    tangentialPressure: e2["tangentialPressure"],
    tiltX: e2["tangentialPressure"],
    tiltY: e2["tiltY"],
    twist: e2["twist"],
    pointerType: e2["pointerType"],
    isPrimary: e2["isPrimary"],
    altKey: e2.altKey,
    button: e2.button,
    buttons: e2.buttons,
    clientX: e2.clientX,
    clientY: e2.clientY,
    ctrlKey: e2.ctrlKey,
    metaKey: e2.metaKey,
    movementX: e2.movementX,
    movementY: e2.movementY,
    offsetX: e2.offsetX,
    offsetY: e2.offsetY,
    pageX: e2.pageX,
    pageY: e2.pageY,
    relatedTarget: e2.relatedTarget,
    screenX: e2.screenX,
    screenY: e2.screenY,
    shiftKey: e2.shiftKey,
    x: e2.x,
    y: e2.y
  };
  return pointerData;
}
function tryMatrixUpdate() {
  console.error("SVELTHREE > Mesh : updating Matrix is not yet implemented!");
}
async function tween(obj, attrName, vals, duration, easing = "linear", repeatObj = {
  count: 0,
  alternate: true
}) {
  await new Promise((resolve2) => {
    let rAF = 0;
    let f3 = 0;
    let total = FPS * duration;
    if (attrName == "rotation") {
      vals = vals.map((val) => Math.PI * (val / 180));
    }
    let init2 = {
      x: obj[attrName].x,
      y: obj[attrName].y,
      z: obj[attrName].z
    };
    let delta = {
      x: Math.abs(init2.x - vals[0]),
      y: Math.abs(init2.y - vals[1]),
      z: Math.abs(init2.z - vals[2])
    };
    let multiplier = {
      x: init2.x < vals[0] ? 1 : -1,
      y: init2.y < vals[1] ? 1 : -1,
      z: init2.z < vals[2] ? 1 : -1
    };
    function animate() {
      if (f3 == total + 1) {
        cancelAnimationFrame(rAF);
        repeatObj.count -= 1;
        if (!repeatObj.alternate && repeatObj.count > 0) {
          Object.defineProperty(obj, attrName, {
            writable: true,
            value: {
              x: init2.x,
              y: init2.y,
              z: init2.z
            }
          });
        }
        resolve2([obj, attrName, vals, duration, easing, repeatObj]);
        return;
      }
      let xyz = repeatObj.alternate ? {
        x: init2.x + delta.x * easings[easing](f3 / total) * multiplier.x,
        y: init2.y + delta.y * easings[easing](f3 / total) * multiplier.y,
        z: init2.z + delta.z * easings[easing](f3 / total) * multiplier.z
      } : {
        x: delta.x * easings[easing](f3 / total) * multiplier.x,
        y: delta.y * easings[easing](f3 / total) * multiplier.y,
        z: delta.z * easings[easing](f3 / total) * multiplier.z
      };
      Object.assign(obj[attrName], xyz);
      f3++;
      rAF = requestAnimationFrame(animate);
    }
    rAF = requestAnimationFrame(animate);
  }).then((args) => {
    if (args[5].count <= 0) {
      return true;
    } else {
      return tween(...args);
    }
  });
}
var import_cookie4, easings, REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, KeepStencilOp, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, _lut, _seed, MathUtils, _canvas, ImageUtils, textureId, _vector$b, _quaternion$4, _v1$5, _m1$3, _zero, _one, _x, _y, _z, _matrix, _quaternion$3, _object3DId, _v1$4, _q1, _m1$2, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, _points, _vector$a, _box$3, _v0$1, _v1$3, _v2$3, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _vector$9, _segCenter, _segDir, _diff, _edge1, _edge2, _normal, _vector1, _vector2$1, _normalMatrix, _v0, _v1$2, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, _colorKeywords, _hslA, _hslB, materialId, _vector$8, _vector2, _bufferGeometryId, _m1$1, _obj$1, _offset$1, _box$1, _boxMorphTargets, _vector$7, _inverseMatrix$2, _ray$2, _sphere$3, _vA$1, _vB$1, _vC$1, _tempA, _tempB, _tempC, _morphA, _morphB, _morphC, _uvA$1, _uvB$1, _uvC$1, _intersectionPoint, _intersectionPointWorld, _geometryId, _m1, _obj, _offset, BoxGeometry, BoxBufferGeometry, UniformsUtils, default_vertex, default_fragment, fov, aspect, _sphere$2, _vector$6, UniformsLib, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmissionmap_fragment, transmissionmap_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, background_frag, background_vert, cube_frag, cube_vert, depth_frag, depth_vert, distanceRGBA_frag, distanceRGBA_vert, equirect_frag, equirect_vert, linedashed_frag, linedashed_vert, meshbasic_frag, meshbasic_vert, meshlambert_frag, meshlambert_vert, meshmatcap_frag, meshmatcap_vert, meshtoon_frag, meshtoon_vert, meshphong_frag, meshphong_vert, meshphysical_frag, meshphysical_vert, normal_frag, normal_vert, points_frag, points_vert, shadow_frag, shadow_vert, sprite_frag, sprite_vert, ShaderChunk, ShaderLib, emptyTexture, emptyTexture2dArray, emptyTexture3d, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, RePathPart, programIdCount, includePattern, deprecatedUnrollLoopPattern, unrollLoopPattern, nextVersion, vsm_frag, vsm_vert, _vector$5, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA, _vB, _vC, _uvA, _uvB, _uvC, _v1$1, _v2$1, _offsetMatrix, _identityMatrix, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _mesh, _start$1, _end$1, _inverseMatrix$1, _ray$1, _sphere$1, _start, _end, _inverseMatrix, _ray, _sphere, _position$2, Earcut, ShapeUtils, WorldUVGenerator, Geometries, Materials, AnimationUtils, Cache, DefaultLoadingManager, loading, tmp, px, py, pz, Curves, LoaderUtils, TYPED_ARRAYS, TEXTURE_MAPPING, TEXTURE_WRAPPING, TEXTURE_FILTER, _context, AudioContext, _eyeRight, _eyeLeft, _position$1, _quaternion$1, _scale$1, _orientation$1, _position, _quaternion, _scale, _orientation, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Spherical, _vector$4, _startP, _startEnd, _vector$3, _vector$2, _boneMatrix, _matrixWorldInv, _vector$1, _color1, _color2, _v1, _v2, _v3, _vector, _camera, _box, _axis, _lineGeometry, _coneGeometry, LOD_MIN, LOD_MAX, EXTRA_LOD_SIGMA, TOTAL_LODS, PHI, INV_PHI, DRACOLoader, OrbitControls, MapControls, UniversalPropIterator, Object3DUtils, subscriber_queue2, svelthreeStores, AnimationProp, SvelthreeAnimationManager, SvelthreeAnimation, Camera, PerspectiveCamera_1, SvelthreeInteraction, Mesh_1, Canvas, LightUtils, Light, AmbientLight_1, PointLight_1, Scene_1, WebGLRenderer_1, FPS, Book, books, css2, Library;
var init_library_98fcbcbb = __esm({
  ".svelte-kit/output/server/chunks/library-98fcbcbb.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie4 = __toModule(require_cookie());
    init_dist();
    easings = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      backIn,
      backInOut,
      backOut,
      bounceIn,
      bounceInOut,
      bounceOut,
      circIn,
      circInOut,
      circOut,
      cubicIn,
      cubicInOut,
      cubicOut,
      elasticIn,
      elasticInOut,
      elasticOut,
      expoIn,
      expoInOut,
      expoOut,
      quadIn,
      quadInOut,
      quadOut,
      quartIn,
      quartInOut,
      quartOut,
      quintIn,
      quintInOut,
      quintOut,
      sineIn,
      sineInOut,
      sineOut,
      linear: identity
    });
    if (Number.EPSILON === void 0) {
      Number.EPSILON = Math.pow(2, -52);
    }
    if (Number.isInteger === void 0) {
      Number.isInteger = function(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
    }
    if (Math.sign === void 0) {
      Math.sign = function(x2) {
        return x2 < 0 ? -1 : x2 > 0 ? 1 : +x2;
      };
    }
    if ("name" in Function.prototype === false) {
      Object.defineProperty(Function.prototype, "name", {
        get: function() {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
      });
    }
    if (Object.assign === void 0) {
      Object.assign = function(target) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        const output = Object(target);
        for (let index = 1; index < arguments.length; index++) {
          const source = arguments[index];
          if (source !== void 0 && source !== null) {
            for (const nextKey in source) {
              if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    }
    REVISION = "119";
    MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    CullFaceNone = 0;
    CullFaceBack = 1;
    CullFaceFront = 2;
    PCFShadowMap = 1;
    PCFSoftShadowMap = 2;
    VSMShadowMap = 3;
    FrontSide = 0;
    BackSide = 1;
    DoubleSide = 2;
    FlatShading = 1;
    NoBlending = 0;
    NormalBlending = 1;
    AdditiveBlending = 2;
    SubtractiveBlending = 3;
    MultiplyBlending = 4;
    CustomBlending = 5;
    AddEquation = 100;
    SubtractEquation = 101;
    ReverseSubtractEquation = 102;
    MinEquation = 103;
    MaxEquation = 104;
    ZeroFactor = 200;
    OneFactor = 201;
    SrcColorFactor = 202;
    OneMinusSrcColorFactor = 203;
    SrcAlphaFactor = 204;
    OneMinusSrcAlphaFactor = 205;
    DstAlphaFactor = 206;
    OneMinusDstAlphaFactor = 207;
    DstColorFactor = 208;
    OneMinusDstColorFactor = 209;
    SrcAlphaSaturateFactor = 210;
    NeverDepth = 0;
    AlwaysDepth = 1;
    LessDepth = 2;
    LessEqualDepth = 3;
    EqualDepth = 4;
    GreaterEqualDepth = 5;
    GreaterDepth = 6;
    NotEqualDepth = 7;
    MultiplyOperation = 0;
    MixOperation = 1;
    AddOperation = 2;
    NoToneMapping = 0;
    LinearToneMapping = 1;
    ReinhardToneMapping = 2;
    CineonToneMapping = 3;
    ACESFilmicToneMapping = 4;
    CustomToneMapping = 5;
    UVMapping = 300;
    CubeReflectionMapping = 301;
    CubeRefractionMapping = 302;
    EquirectangularReflectionMapping = 303;
    EquirectangularRefractionMapping = 304;
    CubeUVReflectionMapping = 306;
    CubeUVRefractionMapping = 307;
    RepeatWrapping = 1e3;
    ClampToEdgeWrapping = 1001;
    MirroredRepeatWrapping = 1002;
    NearestFilter = 1003;
    NearestMipmapNearestFilter = 1004;
    NearestMipmapLinearFilter = 1005;
    LinearFilter = 1006;
    LinearMipmapNearestFilter = 1007;
    LinearMipmapLinearFilter = 1008;
    UnsignedByteType = 1009;
    ByteType = 1010;
    ShortType = 1011;
    UnsignedShortType = 1012;
    IntType = 1013;
    UnsignedIntType = 1014;
    FloatType = 1015;
    HalfFloatType = 1016;
    UnsignedShort4444Type = 1017;
    UnsignedShort5551Type = 1018;
    UnsignedShort565Type = 1019;
    UnsignedInt248Type = 1020;
    AlphaFormat = 1021;
    RGBFormat = 1022;
    RGBAFormat = 1023;
    LuminanceFormat = 1024;
    LuminanceAlphaFormat = 1025;
    DepthFormat = 1026;
    DepthStencilFormat = 1027;
    RedFormat = 1028;
    RedIntegerFormat = 1029;
    RGFormat = 1030;
    RGIntegerFormat = 1031;
    RGBIntegerFormat = 1032;
    RGBAIntegerFormat = 1033;
    RGB_S3TC_DXT1_Format = 33776;
    RGBA_S3TC_DXT1_Format = 33777;
    RGBA_S3TC_DXT3_Format = 33778;
    RGBA_S3TC_DXT5_Format = 33779;
    RGB_PVRTC_4BPPV1_Format = 35840;
    RGB_PVRTC_2BPPV1_Format = 35841;
    RGBA_PVRTC_4BPPV1_Format = 35842;
    RGBA_PVRTC_2BPPV1_Format = 35843;
    RGB_ETC1_Format = 36196;
    RGB_ETC2_Format = 37492;
    RGBA_ETC2_EAC_Format = 37496;
    RGBA_ASTC_4x4_Format = 37808;
    RGBA_ASTC_5x4_Format = 37809;
    RGBA_ASTC_5x5_Format = 37810;
    RGBA_ASTC_6x5_Format = 37811;
    RGBA_ASTC_6x6_Format = 37812;
    RGBA_ASTC_8x5_Format = 37813;
    RGBA_ASTC_8x6_Format = 37814;
    RGBA_ASTC_8x8_Format = 37815;
    RGBA_ASTC_10x5_Format = 37816;
    RGBA_ASTC_10x6_Format = 37817;
    RGBA_ASTC_10x8_Format = 37818;
    RGBA_ASTC_10x10_Format = 37819;
    RGBA_ASTC_12x10_Format = 37820;
    RGBA_ASTC_12x12_Format = 37821;
    RGBA_BPTC_Format = 36492;
    SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
    SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
    SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
    SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
    SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
    SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
    SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
    SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
    SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
    SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
    SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
    SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
    SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
    SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
    LoopOnce = 2200;
    LoopRepeat = 2201;
    LoopPingPong = 2202;
    InterpolateDiscrete = 2300;
    InterpolateLinear = 2301;
    InterpolateSmooth = 2302;
    ZeroCurvatureEnding = 2400;
    ZeroSlopeEnding = 2401;
    WrapAroundEnding = 2402;
    NormalAnimationBlendMode = 2500;
    AdditiveAnimationBlendMode = 2501;
    TrianglesDrawMode = 0;
    TriangleStripDrawMode = 1;
    TriangleFanDrawMode = 2;
    LinearEncoding = 3e3;
    sRGBEncoding = 3001;
    GammaEncoding = 3007;
    RGBEEncoding = 3002;
    LogLuvEncoding = 3003;
    RGBM7Encoding = 3004;
    RGBM16Encoding = 3005;
    RGBDEncoding = 3006;
    BasicDepthPacking = 3200;
    RGBADepthPacking = 3201;
    TangentSpaceNormalMap = 0;
    ObjectSpaceNormalMap = 1;
    KeepStencilOp = 7680;
    AlwaysStencilFunc = 519;
    StaticDrawUsage = 35044;
    DynamicDrawUsage = 35048;
    Object.assign(EventDispatcher.prototype, {
      addEventListener: function(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === void 0)
          return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function(event) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l = array.length; i2 < l; i2++) {
            array[i2].call(this, event);
          }
        }
      }
    });
    _lut = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
    }
    _seed = 1234567;
    MathUtils = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      },
      clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
      },
      euclideanModulo: function(n, m2) {
        return (n % m2 + m2) % m2;
      },
      mapLinear: function(x2, a1, a2, b1, b2) {
        return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
      },
      lerp: function(x2, y, t2) {
        return (1 - t2) * x2 + t2 * y;
      },
      smoothstep: function(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * (3 - 2 * x2);
      },
      smootherstep: function(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
      },
      randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      seededRandom: function(s3) {
        if (s3 !== void 0)
          _seed = s3 % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
      },
      degToRad: function(degrees) {
        return degrees * MathUtils.DEG2RAD;
      },
      radToDeg: function(radians) {
        return radians * MathUtils.RAD2DEG;
      },
      isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
      },
      ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      },
      floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      },
      setQuaternionFromProperEuler: function(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s22 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch (order) {
          case "XYX":
            q.set(c2 * s13, s22 * c1_3, s22 * s1_3, c2 * c13);
            break;
          case "YZY":
            q.set(s22 * s1_3, c2 * s13, s22 * c1_3, c2 * c13);
            break;
          case "ZXZ":
            q.set(s22 * c1_3, s22 * s1_3, c2 * s13, c2 * c13);
            break;
          case "XZX":
            q.set(c2 * s13, s22 * s3_1, s22 * c3_1, c2 * c13);
            break;
          case "YXY":
            q.set(s22 * c3_1, c2 * s13, s22 * s3_1, c2 * c13);
            break;
          case "ZYZ":
            q.set(s22 * s3_1, s22 * c3_1, c2 * s13, c2 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
    };
    Object.defineProperties(Vector2.prototype, {
      "width": {
        get: function() {
          return this.x;
        },
        set: function(value) {
          this.x = value;
        }
      },
      "height": {
        get: function() {
          return this.y;
        },
        set: function(value) {
          this.y = value;
        }
      }
    });
    Object.assign(Vector2.prototype, {
      isVector2: true,
      set: function(x2, y) {
        this.x = x2;
        this.y = y;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      },
      setX: function(x2) {
        this.x = x2;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s3) {
        this.x += s3;
        this.y += s3;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      addScaledVector: function(v, s3) {
        this.x += v.x * s3;
        this.y += v.y * s3;
        return this;
      },
      sub: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s3) {
        this.x -= s3;
        this.y -= s3;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      applyMatrix3: function(m2) {
        const x2 = this.x, y = this.y;
        const e2 = m2.elements;
        this.x = e2[0] * x2 + e2[3] * y + e2[6];
        this.y = e2[1] * x2 + e2[4] * y + e2[7];
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      },
      clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      cross: function(v) {
        return this.x * v.y - this.y * v.x;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      angle: function() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      },
      setLength: function(length) {
        return this.normalize().multiplyScalar(length);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      },
      rotateAround: function(center, angle) {
        const c = Math.cos(angle), s3 = Math.sin(angle);
        const x2 = this.x - center.x;
        const y = this.y - center.y;
        this.x = x2 * c - y * s3 + center.x;
        this.y = x2 * s3 + y * c + center.y;
        return this;
      },
      random: function() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
    });
    Object.assign(Matrix3.prototype, {
      isMatrix3: true,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function(m2) {
        const te = this.elements;
        const me = m2.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      },
      setFromMatrix4: function(m2) {
        const me = m2.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      },
      multiply: function(m2) {
        return this.multiplyMatrices(this, m2);
      },
      premultiply: function(m2) {
        return this.multiplyMatrices(m2, this);
      },
      multiplyMatrices: function(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      },
      multiplyScalar: function(s3) {
        const te = this.elements;
        te[0] *= s3;
        te[3] *= s3;
        te[6] *= s3;
        te[1] *= s3;
        te[4] *= s3;
        te[7] *= s3;
        te[2] *= s3;
        te[5] *= s3;
        te[8] *= s3;
        return this;
      },
      determinant: function() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e2 = te[4], f3 = te[5], g = te[6], h2 = te[7], i2 = te[8];
        return a * e2 * i2 - a * f3 * h2 - b * d * i2 + b * f3 * g + c * d * h2 - c * e2 * g;
      },
      getInverse: function(matrix, throwOnDegenerate) {
        if (throwOnDegenerate !== void 0) {
          console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        }
        const me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      },
      transpose: function() {
        let tmp2;
        const m2 = this.elements;
        tmp2 = m2[1];
        m2[1] = m2[3];
        m2[3] = tmp2;
        tmp2 = m2[2];
        m2[2] = m2[6];
        m2[6] = tmp2;
        tmp2 = m2[5];
        m2[5] = m2[7];
        m2[7] = tmp2;
        return this;
      },
      getNormalMatrix: function(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
      },
      transposeIntoArray: function(r2) {
        const m2 = this.elements;
        r2[0] = m2[0];
        r2[1] = m2[3];
        r2[2] = m2[6];
        r2[3] = m2[1];
        r2[4] = m2[4];
        r2[5] = m2[7];
        r2[6] = m2[2];
        r2[7] = m2[5];
        r2[8] = m2[8];
        return this;
      },
      setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s3 = Math.sin(rotation);
        this.set(sx * c, sx * s3, -sx * (c * cx + s3 * cy) + cx + tx, -sy * s3, sy * c, -sy * (-s3 * cx + c * cy) + cy + ty, 0, 0, 1);
      },
      scale: function(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      },
      rotate: function(theta) {
        const c = Math.cos(theta);
        const s3 = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s3 * a21;
        te[3] = c * a12 + s3 * a22;
        te[6] = c * a13 + s3 * a23;
        te[1] = -s3 * a11 + c * a21;
        te[4] = -s3 * a12 + c * a22;
        te[7] = -s3 * a13 + c * a23;
        return this;
      },
      translate: function(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      },
      equals: function(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        for (let i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      }
    });
    ImageUtils = {
      getDataURL: function(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0)
            _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          const context = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
    };
    textureId = 0;
    Texture.DEFAULT_IMAGE = void 0;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Texture,
      isTexture: true,
      updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
      },
      toJSON: function(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (this.image !== void 0) {
          const image = this.image;
          if (image.uuid === void 0) {
            image.uuid = MathUtils.generateUUID();
          }
          if (!isRootObject && meta.images[image.uuid] === void 0) {
            let url;
            if (Array.isArray(image)) {
              url = [];
              for (let i2 = 0, l = image.length; i2 < l; i2++) {
                url.push(ImageUtils.getDataURL(image[i2]));
              }
            } else {
              url = ImageUtils.getDataURL(image);
            }
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url
            };
          }
          output.image = image.uuid;
        }
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      },
      transformUv: function(uv) {
        if (this.mapping !== UVMapping)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
    });
    Object.defineProperty(Texture.prototype, "needsUpdate", {
      set: function(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.defineProperties(Vector4.prototype, {
      "width": {
        get: function() {
          return this.z;
        },
        set: function(value) {
          this.z = value;
        }
      },
      "height": {
        get: function() {
          return this.w;
        },
        set: function(value) {
          this.w = value;
        }
      }
    });
    Object.assign(Vector4.prototype, {
      isVector4: true,
      set: function(x2, y, z, w) {
        this.x = x2;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      },
      setX: function(x2) {
        this.x = x2;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w) {
        this.w = w;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== void 0 ? v.w : 1;
        return this;
      },
      add: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s3) {
        this.x += s3;
        this.y += s3;
        this.z += s3;
        this.w += s3;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      addScaledVector: function(v, s3) {
        this.x += v.x * s3;
        this.y += v.y * s3;
        this.z += v.z * s3;
        this.w += v.w * s3;
        return this;
      },
      sub: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s3) {
        this.x -= s3;
        this.y -= s3;
        this.z -= s3;
        this.w -= s3;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      },
      applyMatrix4: function(m2) {
        const x2 = this.x, y = this.y, z = this.z, w = this.w;
        const e2 = m2.elements;
        this.x = e2[0] * x2 + e2[4] * y + e2[8] * z + e2[12] * w;
        this.y = e2[1] * x2 + e2[5] * y + e2[9] * z + e2[13] * w;
        this.z = e2[2] * x2 + e2[6] * y + e2[10] * z + e2[14] * w;
        this.w = e2[3] * x2 + e2[7] * y + e2[11] * z + e2[15] * w;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        const s3 = Math.sqrt(1 - q.w * q.w);
        if (s3 < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s3;
          this.y = q.y / s3;
          this.z = q.z / s3;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m2) {
        let angle, x2, y, z;
        const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          const xx = (m11 + 1) / 2;
          const yy = (m22 + 1) / 2;
          const zz = (m33 + 1) / 2;
          const xy = (m12 + m21) / 4;
          const xz = (m13 + m31) / 4;
          const yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x2 = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x2 = Math.sqrt(xx);
              y = xy / x2;
              z = xz / x2;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x2 = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x2 = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x2 = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x2 = xz / z;
              y = yz / z;
            }
          }
          this.set(x2, y, z, angle);
          return this;
        }
        let s3 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s3) < 1e-3)
          s3 = 1;
        this.x = (m32 - m23) / s3;
        this.y = (m13 - m31) / s3;
        this.z = (m21 - m12) / s3;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      },
      clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function(length) {
        return this.normalize().multiplyScalar(length);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
      },
      random: function() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
    });
    WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: WebGLRenderTarget,
      isWebGLRenderTarget: true,
      setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.texture.image.width = width;
          this.texture.image.height = height;
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
      constructor: WebGLMultisampleRenderTarget,
      isWebGLMultisampleRenderTarget: true,
      copy: function(source) {
        WebGLRenderTarget.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
      }
    });
    Object.assign(Quaternion, {
      slerp: function(qa, qb, qm, t2) {
        return qm.copy(qa).slerp(qb, t2);
      },
      slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          let s3 = 1 - t2, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s3 = Math.sin(s3 * len) / sin;
            t2 = Math.sin(t2 * len) / sin;
          }
          const tDir = t2 * dir;
          x0 = x0 * s3 + x1 * tDir;
          y0 = y0 * s3 + y1 * tDir;
          z0 = z0 * s3 + z1 * tDir;
          w0 = w0 * s3 + w1 * tDir;
          if (s3 === 1 - t2) {
            const f3 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f3;
            y0 *= f3;
            z0 *= f3;
            w0 *= f3;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      },
      multiplyQuaternionsFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
    });
    Object.defineProperties(Quaternion.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        set: function(value) {
          this._x = value;
          this._onChangeCallback();
        }
      },
      y: {
        get: function() {
          return this._y;
        },
        set: function(value) {
          this._y = value;
          this._onChangeCallback();
        }
      },
      z: {
        get: function() {
          return this._z;
        },
        set: function(value) {
          this._z = value;
          this._onChangeCallback();
        }
      },
      w: {
        get: function() {
          return this._w;
        },
        set: function(value) {
          this._w = value;
          this._onChangeCallback();
        }
      }
    });
    Object.assign(Quaternion.prototype, {
      isQuaternion: true,
      set: function(x2, y, z, w) {
        this._x = x2;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        const x2 = euler._x, y = euler._y, z = euler._z, order = euler.order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x2 / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x2 / 2);
        const s22 = sin(y / 2);
        const s3 = sin(z / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s22 * s3;
            this._y = c1 * s22 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s3;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s22 * s3;
            this._y = c1 * s22 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s3;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s22 * s3;
            this._y = c1 * s22 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s3;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s22 * s3;
            this._y = c1 * s22 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s3;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s22 * s3;
            this._y = c1 * s22 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s3;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s22 * s3;
            this._y = c1 * s22 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s3;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false)
          this._onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        const halfAngle = angle / 2, s3 = Math.sin(halfAngle);
        this._x = axis.x * s3;
        this._y = axis.y * s3;
        this._z = axis.z * s3;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m2) {
        const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
          const s3 = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s3;
          this._x = (m32 - m23) * s3;
          this._y = (m13 - m31) * s3;
          this._z = (m21 - m12) * s3;
        } else if (m11 > m22 && m11 > m33) {
          const s3 = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / s3;
          this._x = 0.25 * s3;
          this._y = (m12 + m21) / s3;
          this._z = (m13 + m31) / s3;
        } else if (m22 > m33) {
          const s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / s3;
          this._x = (m12 + m21) / s3;
          this._y = 0.25 * s3;
          this._z = (m23 + m32) / s3;
        } else {
          const s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / s3;
          this._x = (m13 + m31) / s3;
          this._y = (m23 + m32) / s3;
          this._z = 0.25 * s3;
        }
        this._onChangeCallback();
        return this;
      },
      setFromUnitVectors: function(vFrom, vTo) {
        const EPS = 1e-6;
        let r2 = vFrom.dot(vTo) + 1;
        if (r2 < EPS) {
          r2 = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r2;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r2;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r2;
        }
        return this.normalize();
      },
      angleTo: function(q) {
        return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
      },
      rotateTowards: function(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0)
          return this;
        const t2 = Math.min(1, step / angle);
        this.slerp(q, t2);
        return this;
      },
      identity: function() {
        return this.set(0, 0, 0, 1);
      },
      inverse: function() {
        return this.conjugate();
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        let l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      premultiply: function(q) {
        return this.multiplyQuaternions(q, this);
      },
      multiplyQuaternions: function(a, b) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      },
      slerp: function(qb, t2) {
        if (t2 === 0)
          return this;
        if (t2 === 1)
          return this.copy(qb);
        const x2 = this._x, y = this._y, z = this._z, w = this._w;
        let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w;
          this._x = x2;
          this._y = y;
          this._z = z;
          return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          const s3 = 1 - t2;
          this._w = s3 * w + t2 * this._w;
          this._x = s3 * x2 + t2 * this._x;
          this._y = s3 * y + t2 * this._y;
          this._z = s3 * z + t2 * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x2 * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      fromBufferAttribute: function(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
      },
      _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
      },
      _onChangeCallback: function() {
      }
    });
    _vector$b = new Vector3();
    _quaternion$4 = new Quaternion();
    Object.assign(Vector3.prototype, {
      isVector3: true,
      set: function(x2, y, z) {
        if (z === void 0)
          z = this.z;
        this.x = x2;
        this.y = y;
        this.z = z;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      },
      setX: function(x2) {
        this.x = x2;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s3) {
        this.x += s3;
        this.y += s3;
        this.z += s3;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      addScaledVector: function(v, s3) {
        this.x += v.x * s3;
        this.y += v.y * s3;
        this.z += v.z * s3;
        return this;
      },
      sub: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s3) {
        this.x -= s3;
        this.y -= s3;
        this.z -= s3;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      },
      applyAxisAngle: function(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      },
      applyMatrix3: function(m2) {
        const x2 = this.x, y = this.y, z = this.z;
        const e2 = m2.elements;
        this.x = e2[0] * x2 + e2[3] * y + e2[6] * z;
        this.y = e2[1] * x2 + e2[4] * y + e2[7] * z;
        this.z = e2[2] * x2 + e2[5] * y + e2[8] * z;
        return this;
      },
      applyNormalMatrix: function(m2) {
        return this.applyMatrix3(m2).normalize();
      },
      applyMatrix4: function(m2) {
        const x2 = this.x, y = this.y, z = this.z;
        const e2 = m2.elements;
        const w = 1 / (e2[3] * x2 + e2[7] * y + e2[11] * z + e2[15]);
        this.x = (e2[0] * x2 + e2[4] * y + e2[8] * z + e2[12]) * w;
        this.y = (e2[1] * x2 + e2[5] * y + e2[9] * z + e2[13]) * w;
        this.z = (e2[2] * x2 + e2[6] * y + e2[10] * z + e2[14]) * w;
        return this;
      },
      applyQuaternion: function(q) {
        const x2 = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix = qw * x2 + qy * z - qz * y;
        const iy = qw * y + qz * x2 - qx * z;
        const iz = qw * z + qx * y - qy * x2;
        const iw = -qx * x2 - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      },
      unproject: function(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      },
      transformDirection: function(m2) {
        const x2 = this.x, y = this.y, z = this.z;
        const e2 = m2.elements;
        this.x = e2[0] * x2 + e2[4] * y + e2[8] * z;
        this.y = e2[1] * x2 + e2[5] * y + e2[9] * z;
        this.z = e2[2] * x2 + e2[6] * y + e2[10] * z;
        return this.normalize();
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      },
      clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function(length) {
        return this.normalize().multiplyScalar(length);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      },
      cross: function(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
      },
      crossVectors: function(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function(v) {
        const denominator = v.lengthSq();
        if (denominator === 0)
          return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
      },
      projectOnPlane: function(planeNormal) {
        _vector$b.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$b);
      },
      reflect: function(normal) {
        return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
      },
      angleTo: function(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0)
          return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        return Math.acos(MathUtils.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      },
      setFromSpherical: function(s3) {
        return this.setFromSphericalCoords(s3.radius, s3.phi, s3.theta);
      },
      setFromSphericalCoords: function(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      },
      setFromCylindrical: function(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      },
      setFromCylindricalCoords: function(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
      },
      setFromMatrixPosition: function(m2) {
        const e2 = m2.elements;
        this.x = e2[12];
        this.y = e2[13];
        this.z = e2[14];
        return this;
      },
      setFromMatrixScale: function(m2) {
        const sx = this.setFromMatrixColumn(m2, 0).length();
        const sy = this.setFromMatrixColumn(m2, 1).length();
        const sz = this.setFromMatrixColumn(m2, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(m2, index) {
        return this.fromArray(m2.elements, index * 4);
      },
      setFromMatrix3Column: function(m2, index) {
        return this.fromArray(m2.elements, index * 3);
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
      },
      random: function() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
    });
    _v1$5 = new Vector3();
    _m1$3 = new Matrix4();
    _zero = new Vector3(0, 0, 0);
    _one = new Vector3(1, 1, 1);
    _x = new Vector3();
    _y = new Vector3();
    _z = new Vector3();
    Object.assign(Matrix4.prototype, {
      isMatrix4: true,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new Matrix4().fromArray(this.elements);
      },
      copy: function(m2) {
        const te = this.elements;
        const me = m2.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      },
      copyPosition: function(m2) {
        const te = this.elements, me = m2.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function(m2) {
        const te = this.elements;
        const me = m2.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      makeRotationFromEuler: function(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        const te = this.elements;
        const x2 = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x2), b = Math.sin(x2);
        const c = Math.cos(y), d = Math.sin(y);
        const e2 = Math.cos(z), f3 = Math.sin(z);
        if (euler.order === "XYZ") {
          const ae = a * e2, af = a * f3, be = b * e2, bf = b * f3;
          te[0] = c * e2;
          te[4] = -c * f3;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          const ce = c * e2, cf = c * f3, de = d * e2, df = d * f3;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f3;
          te[5] = a * e2;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          const ce = c * e2, cf = c * f3, de = d * e2, df = d * f3;
          te[0] = ce - df * b;
          te[4] = -a * f3;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e2;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          const ae = a * e2, af = a * f3, be = b * e2, bf = b * f3;
          te[0] = c * e2;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f3;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e2;
          te[4] = bd - ac * f3;
          te[8] = bc * f3 + ad;
          te[1] = f3;
          te[5] = a * e2;
          te[9] = -b * e2;
          te[2] = -d * e2;
          te[6] = ad * f3 + bc;
          te[10] = ac - bd * f3;
        } else if (euler.order === "XZY") {
          const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e2;
          te[4] = -f3;
          te[8] = d * e2;
          te[1] = ac * f3 + bd;
          te[5] = a * e2;
          te[9] = ad * f3 - bc;
          te[2] = bc * f3 - ad;
          te[6] = b * e2;
          te[10] = bd * f3 + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      makeRotationFromQuaternion: function(q) {
        return this.compose(_zero, q, _one);
      },
      lookAt: function(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 1e-4;
          } else {
            _z.z += 1e-4;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      },
      multiply: function(m2, n) {
        if (n !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m2, n);
        }
        return this.multiplyMatrices(this, m2);
      },
      premultiply: function(m2) {
        return this.multiplyMatrices(m2, this);
      },
      multiplyMatrices: function(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyScalar: function(s3) {
        const te = this.elements;
        te[0] *= s3;
        te[4] *= s3;
        te[8] *= s3;
        te[12] *= s3;
        te[1] *= s3;
        te[5] *= s3;
        te[9] *= s3;
        te[13] *= s3;
        te[2] *= s3;
        te[6] *= s3;
        te[10] *= s3;
        te[14] *= s3;
        te[3] *= s3;
        te[7] *= s3;
        te[11] *= s3;
        te[15] *= s3;
        return this;
      },
      determinant: function() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      },
      transpose: function() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
      },
      setPosition: function(x2, y, z) {
        const te = this.elements;
        if (x2.isVector3) {
          te[12] = x2.x;
          te[13] = x2.y;
          te[14] = x2.z;
        } else {
          te[12] = x2;
          te[13] = y;
          te[14] = z;
        }
        return this;
      },
      getInverse: function(m2, throwOnDegenerate) {
        if (throwOnDegenerate !== void 0) {
          console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        }
        const te = this.elements, me = m2.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      },
      scale: function(v) {
        const te = this.elements;
        const x2 = v.x, y = v.y, z = v.z;
        te[0] *= x2;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x2;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x2;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x2;
        te[7] *= y;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      },
      makeTranslation: function(x2, y, z) {
        this.set(1, 0, 0, x2, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        const c = Math.cos(theta), s3 = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s3, 0, 0, s3, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        const c = Math.cos(theta), s3 = Math.sin(theta);
        this.set(c, 0, s3, 0, 0, 1, 0, 0, -s3, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        const c = Math.cos(theta), s3 = Math.sin(theta);
        this.set(c, -s3, 0, 0, s3, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        const c = Math.cos(angle);
        const s3 = Math.sin(angle);
        const t2 = 1 - c;
        const x2 = axis.x, y = axis.y, z = axis.z;
        const tx = t2 * x2, ty = t2 * y;
        this.set(tx * x2 + c, tx * y - s3 * z, tx * z + s3 * y, 0, tx * y + s3 * z, ty * y + c, ty * z - s3 * x2, 0, tx * z - s3 * y, ty * z + s3 * x2, t2 * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x2, y, z) {
        this.set(x2, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      makeShear: function(x2, y, z) {
        this.set(1, y, z, 0, x2, 1, z, 0, x2, y, 1, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        const te = this.elements;
        const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x22 = x2 + x2, y2 = y + y, z2 = z + z;
        const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x22, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      },
      decompose: function(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$5.set(te[0], te[1], te[2]).length();
        let sy = _v1$5.set(te[4], te[5], te[6]).length();
        let sz = _v1$5.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1$3.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$3.elements[0] *= invSX;
        _m1$3.elements[1] *= invSX;
        _m1$3.elements[2] *= invSX;
        _m1$3.elements[4] *= invSY;
        _m1$3.elements[5] *= invSY;
        _m1$3.elements[6] *= invSY;
        _m1$3.elements[8] *= invSZ;
        _m1$3.elements[9] *= invSZ;
        _m1$3.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$3);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      },
      makePerspective: function(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        const te = this.elements;
        const x2 = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x2;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h2 = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x2 = (right + left) * w;
        const y = (top + bottom) * h2;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x2;
        te[1] = 0;
        te[5] = 2 * h2;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      equals: function(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 16; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        for (let i2 = 0; i2 < 16; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      }
    });
    _matrix = new Matrix4();
    _quaternion$3 = new Quaternion();
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    Euler.DefaultOrder = "XYZ";
    Object.defineProperties(Euler.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        set: function(value) {
          this._x = value;
          this._onChangeCallback();
        }
      },
      y: {
        get: function() {
          return this._y;
        },
        set: function(value) {
          this._y = value;
          this._onChangeCallback();
        }
      },
      z: {
        get: function() {
          return this._z;
        },
        set: function(value) {
          this._z = value;
          this._onChangeCallback();
        }
      },
      order: {
        get: function() {
          return this._order;
        },
        set: function(value) {
          this._order = value;
          this._onChangeCallback();
        }
      }
    });
    Object.assign(Euler.prototype, {
      isEuler: true,
      set: function(x2, y, z, order) {
        this._x = x2;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m2, order, update) {
        const clamp = MathUtils.clamp;
        const te = m2.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update !== false)
          this._onChangeCallback();
        return this;
      },
      setFromQuaternion: function(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
      },
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function(newOrder) {
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      },
      equals: function(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0)
          this._order = array[3];
        this._onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new Vector3(this._x, this._y, this._z);
        }
      },
      _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
      },
      _onChangeCallback: function() {
      }
    });
    Object.assign(Layers.prototype, {
      set: function(channel) {
        this.mask = 1 << channel | 0;
      },
      enable: function(channel) {
        this.mask |= 1 << channel | 0;
      },
      enableAll: function() {
        this.mask = 4294967295 | 0;
      },
      toggle: function(channel) {
        this.mask ^= 1 << channel | 0;
      },
      disable: function(channel) {
        this.mask &= ~(1 << channel | 0);
      },
      disableAll: function() {
        this.mask = 0;
      },
      test: function(layers) {
        return (this.mask & layers.mask) !== 0;
      }
    });
    _object3DId = 0;
    _v1$4 = new Vector3();
    _q1 = new Quaternion();
    _m1$2 = new Matrix4();
    _target = new Vector3();
    _position$3 = new Vector3();
    _scale$2 = new Vector3();
    _quaternion$2 = new Quaternion();
    _xAxis = new Vector3(1, 0, 0);
    _yAxis = new Vector3(0, 1, 0);
    _zAxis = new Vector3(0, 0, 1);
    _addedEvent = { type: "added" };
    _removedEvent = { type: "removed" };
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Object3D,
      isObject3D: true,
      onBeforeRender: function() {
      },
      onAfterRender: function() {
      },
      applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m2) {
        this.quaternion.setFromRotationMatrix(m2);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      },
      rotateOnWorldAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      },
      rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      },
      rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      },
      rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      },
      translateOnAxis: function(axis, distance) {
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      },
      translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
      },
      translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
      },
      translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
      },
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function(vector) {
        return vector.applyMatrix4(_m1$2.getInverse(this.matrixWorld));
      },
      lookAt: function(x2, y, z) {
        if (x2.isVector3) {
          _target.copy(x2);
        } else {
          _target.set(x2, y, z);
        }
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$2.lookAt(_position$3, _target, this.up);
        } else {
          _m1$2.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$2);
        if (parent) {
          _m1$2.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$2);
          this.quaternion.premultiply(_q1.inverse());
        }
      },
      add: function(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.remove(arguments[i2]);
          }
          return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          this.children.splice(index, 1);
          object.dispatchEvent(_removedEvent);
        }
        return this;
      },
      attach: function(object) {
        this.updateWorldMatrix(true, false);
        _m1$2.getInverse(this.matrixWorld);
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$2.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$2);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
      },
      getObjectById: function(id) {
        return this.getObjectByProperty("id", id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty("name", name);
      },
      getObjectByProperty: function(name, value) {
        if (this[name] === value)
          return this;
        for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
          const child = this.children[i2];
          const object = child.getObjectByProperty(name, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      },
      getWorldPosition: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldPosition() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
          target = new Quaternion();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
      },
      getWorldScale: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldScale() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
      },
      getWorldDirection: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldDirection() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        const e2 = this.matrixWorld.elements;
        return target.set(e2[8], e2[9], e2[10]).normalize();
      },
      raycast: function() {
      },
      traverse: function(callback) {
        callback(this);
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return;
        callback(this);
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].updateMatrixWorld(force);
        }
      },
      updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateWorldMatrix(false, true);
          }
        }
      },
      toJSON: function(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        const output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        function serialize(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          const parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            const shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                const shape = shapes[i2];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            const uuids = [];
            for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
              uuids.push(serialize(meta.materials, this.material[i2]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (let i2 = 0; i2 < this.children.length; i2++) {
            object.children.push(this.children[i2].toJSON(meta).object);
          }
        }
        if (isRootObject) {
          const geometries = extractFromCache(meta.geometries);
          const materials = extractFromCache(meta.materials);
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          const shapes = extractFromCache(meta.shapes);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (shapes.length > 0)
            output.shapes = shapes;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      },
      clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
      },
      copy: function(source, recursive) {
        if (recursive === void 0)
          recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (let i2 = 0; i2 < source.children.length; i2++) {
            const child = source.children[i2];
            this.add(child.clone());
          }
        }
        return this;
      }
    });
    Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Scene,
      isScene: true,
      copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      },
      toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null)
          data.object.background = this.background.toJSON(meta);
        if (this.environment !== null)
          data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    _points = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    _vector$a = new Vector3();
    _box$3 = new Box3();
    _v0$1 = new Vector3();
    _v1$3 = new Vector3();
    _v2$3 = new Vector3();
    _f0 = new Vector3();
    _f1 = new Vector3();
    _f2 = new Vector3();
    _center = new Vector3();
    _extents = new Vector3();
    _triangleNormal = new Vector3();
    _testAxis = new Vector3();
    Object.assign(Box3.prototype, {
      isBox3: true,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromArray: function(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
          const x2 = array[i2];
          const y = array[i2 + 1];
          const z = array[i2 + 2];
          if (x2 < minX)
            minX = x2;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x2 > maxX)
            maxX = x2;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      },
      setFromBufferAttribute: function(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
          const x2 = attribute.getX(i2);
          const y = attribute.getY(i2);
          const z = attribute.getZ(i2);
          if (x2 < minX)
            minX = x2;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x2 > maxX)
            maxX = x2;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      },
      setFromCenterAndSize: function(center, size) {
        const halfSize = _vector$a.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      },
      setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getCenter() target is now required");
          target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getSize() target is now required");
          target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      expandByObject: function(object) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== void 0) {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
        const children = object.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          this.expandByObject(children[i2]);
        }
        return this;
      },
      containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      },
      containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      },
      getParameter: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getParameter() target is now required");
          target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      intersectsBox: function(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      },
      intersectsSphere: function(sphere) {
        this.clampPoint(sphere.center, _vector$a);
        return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      },
      intersectsPlane: function(plane) {
        let min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      },
      intersectsTriangle: function(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0$1.subVectors(triangle.a, _center);
        _v1$3.subVectors(triangle.b, _center);
        _v2$3.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$3, _v0$1);
        _f1.subVectors(_v2$3, _v1$3);
        _f2.subVectors(_v0$1, _v2$3);
        let axes = [
          0,
          -_f0.z,
          _f0.y,
          0,
          -_f1.z,
          _f1.y,
          0,
          -_f2.z,
          _f2.y,
          _f0.z,
          0,
          -_f0.x,
          _f1.z,
          0,
          -_f1.x,
          _f2.z,
          0,
          -_f2.x,
          -_f0.y,
          _f0.x,
          0,
          -_f1.y,
          _f1.x,
          0,
          -_f2.y,
          _f2.x,
          0
        ];
        if (!satForAxes(axes, _v0$1, _v1$3, _v2$3, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$1, _v1$3, _v2$3, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$1, _v1$3, _v2$3, _extents);
      },
      clampPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .clampPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function(point) {
        const clampedPoint = _vector$a.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      },
      getBoundingSphere: function(target) {
        if (target === void 0) {
          console.error("THREE.Box3: .getBoundingSphere() target is now required");
        }
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$a).length() * 0.5;
        return target;
      },
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function(matrix) {
        if (this.isEmpty())
          return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    });
    _box$2 = new Box3();
    Object.assign(Sphere.prototype, {
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$2.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      isEmpty: function() {
        return this.radius < 0;
      },
      makeEmpty: function() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      },
      containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      },
      intersectsBox: function(box) {
        return box.intersectsSphere(this);
      },
      intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === void 0) {
          console.warn("THREE.Sphere: .clampPoint() target is now required");
          target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      },
      getBoundingBox: function(target) {
        if (target === void 0) {
          console.warn("THREE.Sphere: .getBoundingBox() target is now required");
          target = new Box3();
        }
        if (this.isEmpty()) {
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
    });
    _vector$9 = new Vector3();
    _segCenter = new Vector3();
    _segDir = new Vector3();
    _diff = new Vector3();
    _edge1 = new Vector3();
    _edge2 = new Vector3();
    _normal = new Vector3();
    Object.assign(Ray.prototype, {
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t2, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .at() target is now required");
          target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
      },
      lookAt: function(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      },
      recast: function(t2) {
        this.origin.copy(this.at(t2, _vector$9));
        return this;
      },
      closestPointToPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      },
      distanceSqToPoint: function(point) {
        const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$9.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$9.distanceToSquared(point);
      },
      distanceSqToSegment: function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                const invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
      },
      intersectSphere: function(sphere, target) {
        _vector$9.subVectors(sphere.center, this.origin);
        const tca = _vector$9.dot(this.direction);
        const d2 = _vector$9.dot(_vector$9) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      },
      intersectsSphere: function(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      },
      distanceToPlane: function(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t2 >= 0 ? t2 : null;
      },
      intersectPlane: function(plane, target) {
        const t2 = this.distanceToPlane(plane);
        if (t2 === null) {
          return null;
        }
        return this.at(t2, target);
      },
      intersectsPlane: function(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      intersectBox: function(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      },
      intersectsBox: function(box) {
        return this.intersectBox(box, _vector$9) !== null;
      },
      intersectTriangle: function(a, b, c, backfaceCulling, target) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal);
        let sign2;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign2 = 1;
        } else if (DdN < 0) {
          sign2 = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        const QdN = -sign2 * _diff.dot(_normal);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      },
      applyMatrix4: function(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
    });
    _vector1 = new Vector3();
    _vector2$1 = new Vector3();
    _normalMatrix = new Matrix3();
    Object.assign(Plane.prototype, {
      isPlane: true,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x2, y, z, w) {
        this.normal.set(x2, y, z);
        this.constant = w;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function(a, b, c) {
        const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .projectPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      },
      intersectLine: function(line, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .intersectLine() target is now required");
          target = new Vector3();
        }
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return void 0;
        }
        const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t2 < 0 || t2 > 1) {
          return void 0;
        }
        return target.copy(direction).multiplyScalar(t2).add(line.start);
      },
      intersectsLine: function(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      },
      intersectsBox: function(box) {
        return box.intersectsPlane(this);
      },
      intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
      },
      coplanarPoint: function(target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .coplanarPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      },
      translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
    });
    _v0 = new Vector3();
    _v1$2 = new Vector3();
    _v2$2 = new Vector3();
    _v3$1 = new Vector3();
    _vab = new Vector3();
    _vac = new Vector3();
    _vbc = new Vector3();
    _vap = new Vector3();
    _vbp = new Vector3();
    _vcp = new Vector3();
    Object.assign(Triangle, {
      getNormal: function(a, b, c, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getNormal() target is now required");
          target = new Vector3();
        }
        target.subVectors(c, b);
        _v0.subVectors(a, b);
        target.cross(_v0);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      },
      getBarycoord: function(point, a, b, c, target) {
        _v0.subVectors(c, a);
        _v1$2.subVectors(b, a);
        _v2$2.subVectors(point, a);
        const dot00 = _v0.dot(_v0);
        const dot01 = _v0.dot(_v1$2);
        const dot02 = _v0.dot(_v2$2);
        const dot11 = _v1$2.dot(_v1$2);
        const dot12 = _v1$2.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === void 0) {
          console.warn("THREE.Triangle: .getBarycoord() target is now required");
          target = new Vector3();
        }
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      },
      containsPoint: function(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, _v3$1);
        return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
      },
      getUV: function(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3$1.x);
        target.addScaledVector(uv2, _v3$1.y);
        target.addScaledVector(uv3, _v3$1.z);
        return target;
      },
      isFrontFacing: function(a, b, c, direction) {
        _v0.subVectors(c, b);
        _v1$2.subVectors(a, b);
        return _v0.cross(_v1$2).dot(direction) < 0 ? true : false;
      }
    });
    Object.assign(Triangle.prototype, {
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      getArea: function() {
        _v0.subVectors(this.c, this.b);
        _v1$2.subVectors(this.a, this.b);
        return _v0.cross(_v1$2).length() * 0.5;
      },
      getMidpoint: function(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getMidpoint() target is now required");
          target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      getNormal: function(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      },
      getPlane: function(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getPlane() target is now required");
          target = new Plane();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      getBarycoord: function(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      },
      getUV: function(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      },
      containsPoint: function(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      isFrontFacing: function(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      },
      intersectsBox: function(box) {
        return box.intersectsTriangle(this);
      },
      closestPointToPoint: function(p, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b).addScaledVector(_vbc, w);
        }
        const denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    });
    _colorKeywords = {
      "aliceblue": 15792383,
      "antiquewhite": 16444375,
      "aqua": 65535,
      "aquamarine": 8388564,
      "azure": 15794175,
      "beige": 16119260,
      "bisque": 16770244,
      "black": 0,
      "blanchedalmond": 16772045,
      "blue": 255,
      "blueviolet": 9055202,
      "brown": 10824234,
      "burlywood": 14596231,
      "cadetblue": 6266528,
      "chartreuse": 8388352,
      "chocolate": 13789470,
      "coral": 16744272,
      "cornflowerblue": 6591981,
      "cornsilk": 16775388,
      "crimson": 14423100,
      "cyan": 65535,
      "darkblue": 139,
      "darkcyan": 35723,
      "darkgoldenrod": 12092939,
      "darkgray": 11119017,
      "darkgreen": 25600,
      "darkgrey": 11119017,
      "darkkhaki": 12433259,
      "darkmagenta": 9109643,
      "darkolivegreen": 5597999,
      "darkorange": 16747520,
      "darkorchid": 10040012,
      "darkred": 9109504,
      "darksalmon": 15308410,
      "darkseagreen": 9419919,
      "darkslateblue": 4734347,
      "darkslategray": 3100495,
      "darkslategrey": 3100495,
      "darkturquoise": 52945,
      "darkviolet": 9699539,
      "deeppink": 16716947,
      "deepskyblue": 49151,
      "dimgray": 6908265,
      "dimgrey": 6908265,
      "dodgerblue": 2003199,
      "firebrick": 11674146,
      "floralwhite": 16775920,
      "forestgreen": 2263842,
      "fuchsia": 16711935,
      "gainsboro": 14474460,
      "ghostwhite": 16316671,
      "gold": 16766720,
      "goldenrod": 14329120,
      "gray": 8421504,
      "green": 32768,
      "greenyellow": 11403055,
      "grey": 8421504,
      "honeydew": 15794160,
      "hotpink": 16738740,
      "indianred": 13458524,
      "indigo": 4915330,
      "ivory": 16777200,
      "khaki": 15787660,
      "lavender": 15132410,
      "lavenderblush": 16773365,
      "lawngreen": 8190976,
      "lemonchiffon": 16775885,
      "lightblue": 11393254,
      "lightcoral": 15761536,
      "lightcyan": 14745599,
      "lightgoldenrodyellow": 16448210,
      "lightgray": 13882323,
      "lightgreen": 9498256,
      "lightgrey": 13882323,
      "lightpink": 16758465,
      "lightsalmon": 16752762,
      "lightseagreen": 2142890,
      "lightskyblue": 8900346,
      "lightslategray": 7833753,
      "lightslategrey": 7833753,
      "lightsteelblue": 11584734,
      "lightyellow": 16777184,
      "lime": 65280,
      "limegreen": 3329330,
      "linen": 16445670,
      "magenta": 16711935,
      "maroon": 8388608,
      "mediumaquamarine": 6737322,
      "mediumblue": 205,
      "mediumorchid": 12211667,
      "mediumpurple": 9662683,
      "mediumseagreen": 3978097,
      "mediumslateblue": 8087790,
      "mediumspringgreen": 64154,
      "mediumturquoise": 4772300,
      "mediumvioletred": 13047173,
      "midnightblue": 1644912,
      "mintcream": 16121850,
      "mistyrose": 16770273,
      "moccasin": 16770229,
      "navajowhite": 16768685,
      "navy": 128,
      "oldlace": 16643558,
      "olive": 8421376,
      "olivedrab": 7048739,
      "orange": 16753920,
      "orangered": 16729344,
      "orchid": 14315734,
      "palegoldenrod": 15657130,
      "palegreen": 10025880,
      "paleturquoise": 11529966,
      "palevioletred": 14381203,
      "papayawhip": 16773077,
      "peachpuff": 16767673,
      "peru": 13468991,
      "pink": 16761035,
      "plum": 14524637,
      "powderblue": 11591910,
      "purple": 8388736,
      "rebeccapurple": 6697881,
      "red": 16711680,
      "rosybrown": 12357519,
      "royalblue": 4286945,
      "saddlebrown": 9127187,
      "salmon": 16416882,
      "sandybrown": 16032864,
      "seagreen": 3050327,
      "seashell": 16774638,
      "sienna": 10506797,
      "silver": 12632256,
      "skyblue": 8900331,
      "slateblue": 6970061,
      "slategray": 7372944,
      "slategrey": 7372944,
      "snow": 16775930,
      "springgreen": 65407,
      "steelblue": 4620980,
      "tan": 13808780,
      "teal": 32896,
      "thistle": 14204888,
      "tomato": 16737095,
      "turquoise": 4251856,
      "violet": 15631086,
      "wheat": 16113331,
      "white": 16777215,
      "whitesmoke": 16119285,
      "yellow": 16776960,
      "yellowgreen": 10145074
    };
    _hslA = { h: 0, s: 0, l: 0 };
    _hslB = { h: 0, s: 0, l: 0 };
    Object.assign(Color.prototype, {
      isColor: true,
      r: 1,
      g: 1,
      b: 1,
      set: function(value) {
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
        return this;
      },
      setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r2, g, b) {
        this.r = r2;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function(h2, s3, l) {
        h2 = MathUtils.euclideanModulo(h2, 1);
        s3 = MathUtils.clamp(s3, 0, 1);
        l = MathUtils.clamp(l, 0, 1);
        if (s3 === 0) {
          this.r = this.g = this.b = l;
        } else {
          const p = l <= 0.5 ? l * (1 + s3) : l + s3 - l * s3;
          const q = 2 * l - p;
          this.r = hue2rgb(q, p, h2 + 1 / 3);
          this.g = hue2rgb(q, p, h2);
          this.b = hue2rgb(q, p, h2 - 1 / 3);
        }
        return this;
      },
      setStyle: function(style) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        let m2;
        if (m2 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
          let color;
          const name = m2[1];
          const components = m2[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[5]);
                return this;
              }
              if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[5]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                const h2 = parseFloat(color[1]) / 360;
                const s3 = parseInt(color[2], 10) / 100;
                const l = parseInt(color[3], 10) / 100;
                handleAlpha(color[5]);
                return this.setHSL(h2, s3, l);
              }
              break;
          }
        } else if (m2 = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
          const hex = m2[1];
          const size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style);
        }
        return this;
      },
      setColorName: function(style) {
        const hex = _colorKeywords[style];
        if (hex !== void 0) {
          this.setHex(hex);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      },
      clone: function() {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === void 0)
          gammaFactor = 2;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === void 0)
          gammaFactor = 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
      },
      convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
      },
      copySRGBToLinear: function(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      },
      copyLinearToSRGB: function(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      },
      convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
      },
      convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
      },
      getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
      },
      getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(target) {
        if (target === void 0) {
          console.warn("THREE.Color: .getHSL() target is now required");
          target = { h: 0, s: 0, l: 0 };
        }
        const r2 = this.r, g = this.g, b = this.b;
        const max = Math.max(r2, g, b);
        const min = Math.min(r2, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          const delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r2:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r2) / delta + 2;
              break;
            case b:
              hue = (r2 - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      },
      getStyle: function() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
      },
      offsetHSL: function(h2, s3, l) {
        this.getHSL(_hslA);
        _hslA.h += h2;
        _hslA.s += s3;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s3) {
        this.r += s3;
        this.g += s3;
        this.b += s3;
        return this;
      },
      sub: function(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s3) {
        this.r *= s3;
        this.g *= s3;
        this.b *= s3;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      lerpHSL: function(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h2 = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
        const s3 = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
        const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h2, s3, l);
        return this;
      },
      equals: function(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      },
      fromBufferAttribute: function(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
          this.r /= 255;
          this.g /= 255;
          this.b /= 255;
        }
        return this;
      },
      toJSON: function() {
        return this.getHex();
      }
    });
    Color.NAMES = _colorKeywords;
    Object.assign(Face3.prototype, {
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (let i2 = 0, il = source.vertexNormals.length; i2 < il; i2++) {
          this.vertexNormals[i2] = source.vertexNormals[i2].clone();
        }
        for (let i2 = 0, il = source.vertexColors.length; i2 < il; i2++) {
          this.vertexColors[i2] = source.vertexColors[i2].clone();
        }
        return this;
      }
    });
    materialId = 0;
    Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Material,
      isMaterial: true,
      onBeforeCompile: function() {
      },
      customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
      },
      setValues: function(values) {
        if (values === void 0)
          return;
        for (const key in values) {
          const newValue = values[key];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading ? true : false;
            continue;
          }
          const currentValue = this[key];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      },
      toJSON: function(meta) {
        const isRoot = meta === void 0 || typeof meta === "string";
        if (isRoot) {
          meta = {
            textures: {},
            images: {}
          };
        }
        const data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor)
          data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture)
          data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          data.reflectivity = this.reflectivity;
          data.refractionRatio = this.refractionRatio;
          if (this.combine !== void 0)
            data.combine = this.combine;
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.size !== void 0)
          data.size = this.size;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
          data.blending = this.blending;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.side !== FrontSide)
          data.side = this.side;
        if (this.vertexColors)
          data.vertexColors = true;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true)
          data.morphTargets = true;
        if (this.morphNormals === true)
          data.morphNormals = true;
        if (this.skinning === true)
          data.skinning = true;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data2 = cache[key];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRoot) {
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
          const n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2) {
            dstPlanes[i2] = srcPlanes[i2].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    Object.defineProperty(Material.prototype, "needsUpdate", {
      set: function(value) {
        if (value === true)
          this.version++;
      }
    });
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      return this;
    };
    _vector$8 = new Vector3();
    _vector2 = new Vector2();
    Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
      set: function(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.assign(BufferAttribute.prototype, {
      isBufferAttribute: true,
      onUploadCallback: function() {
      },
      setUsage: function(value) {
        this.usage = value;
        return this;
      },
      copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      },
      copyArray: function(array) {
        this.array.set(array);
        return this;
      },
      copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = colors.length; i2 < l; i2++) {
          let color = colors[i2];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
            color = new Color();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      },
      copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
            vector = new Vector2();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      },
      copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
            vector = new Vector3();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      },
      copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
            vector = new Vector4();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      },
      applyMatrix3: function(m2) {
        if (this.itemSize === 2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector2.fromBufferAttribute(this, i2);
            _vector2.applyMatrix3(m2);
            this.setXY(i2, _vector2.x, _vector2.y);
          }
        } else if (this.itemSize === 3) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$8.fromBufferAttribute(this, i2);
            _vector$8.applyMatrix3(m2);
            this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        return this;
      },
      applyMatrix4: function(m2) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$8.x = this.getX(i2);
          _vector$8.y = this.getY(i2);
          _vector$8.z = this.getZ(i2);
          _vector$8.applyMatrix4(m2);
          this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
        return this;
      },
      applyNormalMatrix: function(m2) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$8.x = this.getX(i2);
          _vector$8.y = this.getY(i2);
          _vector$8.z = this.getZ(i2);
          _vector$8.applyNormalMatrix(m2);
          this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
        return this;
      },
      transformDirection: function(m2) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$8.x = this.getX(i2);
          _vector$8.y = this.getY(i2);
          _vector$8.z = this.getZ(i2);
          _vector$8.transformDirection(m2);
          this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === void 0)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      getX: function(index) {
        return this.array[index * this.itemSize];
      },
      setX: function(index, x2) {
        this.array[index * this.itemSize] = x2;
        return this;
      },
      getY: function(index) {
        return this.array[index * this.itemSize + 1];
      },
      setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      getZ: function(index) {
        return this.array[index * this.itemSize + 2];
      },
      setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      getW: function(index) {
        return this.array[index * this.itemSize + 3];
      },
      setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
      },
      setXY: function(index, x2, y) {
        index *= this.itemSize;
        this.array[index + 0] = x2;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x2, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x2;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x2, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x2;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
      },
      clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
      toJSON: function() {
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
      }
    });
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
    Object.assign(DirectGeometry.prototype, {
      computeGroups: function(geometry) {
        const groups = [];
        let group, i2;
        let materialIndex = void 0;
        const faces = geometry.faces;
        for (i2 = 0; i2 < faces.length; i2++) {
          const face = faces[i2];
          if (face.materialIndex !== materialIndex) {
            materialIndex = face.materialIndex;
            if (group !== void 0) {
              group.count = i2 * 3 - group.start;
              groups.push(group);
            }
            group = {
              start: i2 * 3,
              materialIndex
            };
          }
        }
        if (group !== void 0) {
          group.count = i2 * 3 - group.start;
          groups.push(group);
        }
        this.groups = groups;
      },
      fromGeometry: function(geometry) {
        const faces = geometry.faces;
        const vertices = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
          morphTargetsPosition = [];
          for (let i2 = 0; i2 < morphTargetsLength; i2++) {
            morphTargetsPosition[i2] = {
              name: morphTargets[i2].name,
              data: []
            };
          }
          this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
          morphTargetsNormal = [];
          for (let i2 = 0; i2 < morphNormalsLength; i2++) {
            morphTargetsNormal[i2] = {
              name: morphNormals[i2].name,
              data: []
            };
          }
          this.morphTargets.normal = morphTargetsNormal;
        }
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices.length;
        const hasSkinWeights = skinWeights.length === vertices.length;
        if (vertices.length > 0 && faces.length === 0) {
          console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        }
        for (let i2 = 0; i2 < faces.length; i2++) {
          const face = faces[i2];
          this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
          const vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
          } else {
            const normal = face.normal;
            this.normals.push(normal, normal, normal);
          }
          const vertexColors = face.vertexColors;
          if (vertexColors.length === 3) {
            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
          } else {
            const color = face.color;
            this.colors.push(color, color, color);
          }
          if (hasFaceVertexUv === true) {
            const vertexUvs = faceVertexUvs[0][i2];
            if (vertexUvs !== void 0) {
              this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
              this.uvs.push(new Vector2(), new Vector2(), new Vector2());
            }
          }
          if (hasFaceVertexUv2 === true) {
            const vertexUvs = faceVertexUvs[1][i2];
            if (vertexUvs !== void 0) {
              this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
              this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
            }
          }
          for (let j = 0; j < morphTargetsLength; j++) {
            const morphTarget = morphTargets[j].vertices;
            morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
          }
          for (let j = 0; j < morphNormalsLength; j++) {
            const morphNormal = morphNormals[j].vertexNormals[i2];
            morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
          }
          if (hasSkinIndices) {
            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
          }
          if (hasSkinWeights) {
            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
          }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      }
    });
    _bufferGeometryId = 1;
    _m1$1 = new Matrix4();
    _obj$1 = new Object3D();
    _offset$1 = new Vector3();
    _box$1 = new Box3();
    _boxMorphTargets = new Box3();
    _vector$7 = new Vector3();
    BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: BufferGeometry,
      isBufferGeometry: true,
      getIndex: function() {
        return this.index;
      },
      setIndex: function(index) {
        if (Array.isArray(index)) {
          this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        } else {
          this.index = index;
        }
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      },
      deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
      },
      addGroup: function(start, count, materialIndex) {
        this.groups.push({
          start,
          count,
          materialIndex: materialIndex !== void 0 ? materialIndex : 0
        });
      },
      clearGroups: function() {
        this.groups = [];
      },
      setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      },
      applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== void 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      },
      rotateX: function(angle) {
        _m1$1.makeRotationX(angle);
        this.applyMatrix4(_m1$1);
        return this;
      },
      rotateY: function(angle) {
        _m1$1.makeRotationY(angle);
        this.applyMatrix4(_m1$1);
        return this;
      },
      rotateZ: function(angle) {
        _m1$1.makeRotationZ(angle);
        this.applyMatrix4(_m1$1);
        return this;
      },
      translate: function(x2, y, z) {
        _m1$1.makeTranslation(x2, y, z);
        this.applyMatrix4(_m1$1);
        return this;
      },
      scale: function(x2, y, z) {
        _m1$1.makeScale(x2, y, z);
        this.applyMatrix4(_m1$1);
        return this;
      },
      lookAt: function(vector) {
        _obj$1.lookAt(vector);
        _obj$1.updateMatrix();
        this.applyMatrix4(_obj$1.matrix);
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset$1).negate();
        this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
        return this;
      },
      setFromObject: function(object) {
        const geometry = object.geometry;
        if (object.isPoints || object.isLine) {
          const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
          const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
          this.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
          this.setAttribute("color", colors.copyColorsArray(geometry.colors));
          if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
            const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
            this.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
          }
          if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
          }
          if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
          }
        } else if (object.isMesh) {
          if (geometry && geometry.isGeometry) {
            this.fromGeometry(geometry);
          }
        }
        return this;
      },
      setFromPoints: function(points) {
        const position = [];
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      },
      updateFromObject: function(object) {
        let geometry = object.geometry;
        if (object.isMesh) {
          let direct = geometry.__directGeometry;
          if (geometry.elementsNeedUpdate === true) {
            direct = void 0;
            geometry.elementsNeedUpdate = false;
          }
          if (direct === void 0) {
            return this.fromGeometry(geometry);
          }
          direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
          direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
          direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
          direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
          direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
          geometry.verticesNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.groupsNeedUpdate = false;
          geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
          const attribute = this.attributes.position;
          if (attribute !== void 0) {
            attribute.copyVector3sArray(geometry.vertices);
            attribute.needsUpdate = true;
          }
          geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
          const attribute = this.attributes.normal;
          if (attribute !== void 0) {
            attribute.copyVector3sArray(geometry.normals);
            attribute.needsUpdate = true;
          }
          geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
          const attribute = this.attributes.color;
          if (attribute !== void 0) {
            attribute.copyColorsArray(geometry.colors);
            attribute.needsUpdate = true;
          }
          geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
          const attribute = this.attributes.uv;
          if (attribute !== void 0) {
            attribute.copyVector2sArray(geometry.uvs);
            attribute.needsUpdate = true;
          }
          geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
          const attribute = this.attributes.lineDistance;
          if (attribute !== void 0) {
            attribute.copyArray(geometry.lineDistances);
            attribute.needsUpdate = true;
          }
          geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
          geometry.computeGroups(object.geometry);
          this.groups = geometry.groups;
          geometry.groupsNeedUpdate = false;
        }
        return this;
      },
      fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
      },
      fromDirectGeometry: function(geometry) {
        const positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
          const normals = new Float32Array(geometry.normals.length * 3);
          this.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
          const colors = new Float32Array(geometry.colors.length * 3);
          this.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
          const uvs = new Float32Array(geometry.uvs.length * 2);
          this.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
          const uvs2 = new Float32Array(geometry.uvs2.length * 2);
          this.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        this.groups = geometry.groups;
        for (const name in geometry.morphTargets) {
          const array = [];
          const morphTargets = geometry.morphTargets[name];
          for (let i2 = 0, l = morphTargets.length; i2 < l; i2++) {
            const morphTarget = morphTargets[i2];
            const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
            attribute.name = morphTarget.name;
            array.push(attribute.copyVector3sArray(morphTarget.data));
          }
          this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
          const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
          this.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
          const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
          this.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _box$1.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$7.addVectors(this.boundingBox.min, _box$1.min);
                this.boundingBox.expandByPoint(_vector$7);
                _vector$7.addVectors(this.boundingBox.max, _box$1.max);
                this.boundingBox.expandByPoint(_vector$7);
              } else {
                this.boundingBox.expandByPoint(_box$1.min);
                this.boundingBox.expandByPoint(_box$1.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position) {
          const center = this.boundingSphere.center;
          _box$1.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
                _box$1.expandByPoint(_vector$7);
                _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
                _box$1.expandByPoint(_vector$7);
              } else {
                _box$1.expandByPoint(_boxMorphTargets.min);
                _box$1.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$1.getCenter(center);
          let maxRadiusSq = 0;
          for (let i2 = 0, il = position.count; i2 < il; i2++) {
            _vector$7.fromBufferAttribute(position, i2);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
          }
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              const morphTargetsRelative = this.morphTargetsRelative;
              for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                _vector$7.fromBufferAttribute(morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset$1.fromBufferAttribute(position, j);
                  _vector$7.add(_offset$1);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      },
      computeFaceNormals: function() {
      },
      computeVertexNormals: function() {
        const index = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          let normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
              normalAttribute.setXYZ(i2, 0, 0, 0);
            }
          }
          const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
          const cb = new Vector3(), ab = new Vector3();
          if (index) {
            for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
              const vA = index.getX(i2 + 0);
              const vB = index.getX(i2 + 1);
              const vC = index.getX(i2 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
              pA.fromBufferAttribute(positionAttribute, i2 + 0);
              pB.fromBufferAttribute(positionAttribute, i2 + 1);
              pC.fromBufferAttribute(positionAttribute, i2 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      },
      merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset === void 0) {
          offset = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          if (geometry.attributes[key] === void 0)
            continue;
          const attribute1 = attributes[key];
          const attributeArray1 = attribute1.array;
          const attribute2 = geometry.attributes[key];
          const attributeArray2 = attribute2.array;
          const attributeOffset = attribute2.itemSize * offset;
          const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
            attributeArray1[j] = attributeArray2[i2];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        const normals = this.attributes.normal;
        for (let i2 = 0, il = normals.count; i2 < il; i2++) {
          _vector$7.fromBufferAttribute(normals, i2);
          _vector$7.normalize();
          normals.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
        }
      },
      toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices2) {
          const array = attribute.array;
          const itemSize = attribute.itemSize;
          const normalized = attribute.normalized;
          const array2 = new array.constructor(indices2.length * itemSize);
          let index = 0, index2 = 0;
          for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
            index = indices2[i2] * itemSize;
            for (let j = 0; j < itemSize; j++) {
              array2[index2++] = array[index++];
            }
          }
          return new BufferAttribute(array2, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
          return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          const newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for (const name in morphAttributes) {
          const morphArray = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
            const attribute = morphAttribute[i2];
            const newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      },
      toJSON: function() {
        const data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = { attributes: {} };
        const index = this.index;
        if (index !== null) {
          data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
          };
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          const attributeData = attribute.toJSON(data.data);
          if (attribute.name !== "")
            attributeData.name = attribute.name;
          data.data.attributes[key] = attributeData;
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for (const key in this.morphAttributes) {
          const attributeArray = this.morphAttributes[key];
          const array = [];
          for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
            const attribute = attributeArray[i2];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== "")
              attributeData.name = attribute.name;
            array.push(attributeData);
          }
          if (array.length > 0) {
            morphAttributes[key] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      },
      clone: function() {
        return new BufferGeometry().copy(this);
      },
      copy: function(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index = source.index;
        if (index !== null) {
          this.setIndex(index.clone(data));
        }
        const attributes = source.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for (const name in morphAttributes) {
          const array = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
            array.push(morphAttribute[i2].clone(data));
          }
          this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    _inverseMatrix$2 = new Matrix4();
    _ray$2 = new Ray();
    _sphere$3 = new Sphere();
    _vA$1 = new Vector3();
    _vB$1 = new Vector3();
    _vC$1 = new Vector3();
    _tempA = new Vector3();
    _tempB = new Vector3();
    _tempC = new Vector3();
    _morphA = new Vector3();
    _morphB = new Vector3();
    _morphC = new Vector3();
    _uvA$1 = new Vector2();
    _uvB$1 = new Vector2();
    _uvC$1 = new Vector2();
    _intersectionPoint = new Vector3();
    _intersectionPointWorld = new Vector3();
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Mesh,
      isMesh: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                const name = morphAttribute[m2].name || String(m2);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m2;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      },
      raycast: function(raycaster, intersects2) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
          return;
        _inverseMatrix$2.getInverse(matrixWorld);
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        if (geometry.boundingBox !== null) {
          if (_ray$2.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const position = geometry.attributes.position;
          const morphPosition = geometry.morphAttributes.position;
          const morphTargetsRelative = geometry.morphTargetsRelative;
          const uv = geometry.attributes.uv;
          const uv2 = geometry.attributes.uv2;
          const groups = geometry.groups;
          const drawRange = geometry.drawRange;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = index.getX(j);
                  const b = index.getX(j + 1);
                  const c = index.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = index.getX(i2);
                const b = index.getX(i2 + 1);
                const c = index.getX(i2 + 2);
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = j;
                  const b = j + 1;
                  const c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(position.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = i2;
                const b = i2 + 1;
                const c = i2 + 2;
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        } else if (geometry.isGeometry) {
          const isMultiMaterial = Array.isArray(material);
          const vertices = geometry.vertices;
          const faces = geometry.faces;
          let uvs;
          const faceVertexUvs = geometry.faceVertexUvs[0];
          if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
          for (let f3 = 0, fl = faces.length; f3 < fl; f3++) {
            const face = faces[f3];
            const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
            if (faceMaterial === void 0)
              continue;
            const fvA = vertices[face.a];
            const fvB = vertices[face.b];
            const fvC = vertices[face.c];
            intersection = checkIntersection(this, faceMaterial, raycaster, _ray$2, fvA, fvB, fvC, _intersectionPoint);
            if (intersection) {
              if (uvs && uvs[f3]) {
                const uvs_f = uvs[f3];
                _uvA$1.copy(uvs_f[0]);
                _uvB$1.copy(uvs_f[1]);
                _uvC$1.copy(uvs_f[2]);
                intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA$1, _uvB$1, _uvC$1, new Vector2());
              }
              intersection.face = face;
              intersection.faceIndex = f3;
              intersects2.push(intersection);
            }
          }
        }
      }
    });
    _geometryId = 0;
    _m1 = new Matrix4();
    _obj = new Object3D();
    _offset = new Vector3();
    Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Geometry,
      isGeometry: true,
      applyMatrix4: function(matrix) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
          const vertex = this.vertices[i2];
          vertex.applyMatrix4(matrix);
        }
        for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
          const face = this.faces[i2];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
      },
      rotateX: function(angle) {
        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
      },
      rotateY: function(angle) {
        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
      },
      rotateZ: function(angle) {
        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
      },
      translate: function(x2, y, z) {
        _m1.makeTranslation(x2, y, z);
        this.applyMatrix4(_m1);
        return this;
      },
      scale: function(x2, y, z) {
        _m1.makeScale(x2, y, z);
        this.applyMatrix4(_m1);
        return this;
      },
      lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      },
      fromBufferGeometry: function(geometry) {
        const scope = this;
        const index = geometry.index !== null ? geometry.index : void 0;
        const attributes = geometry.attributes;
        if (attributes.position === void 0) {
          console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
          return this;
        }
        const position = attributes.position;
        const normal = attributes.normal;
        const color = attributes.color;
        const uv = attributes.uv;
        const uv2 = attributes.uv2;
        if (uv2 !== void 0)
          this.faceVertexUvs[1] = [];
        for (let i2 = 0; i2 < position.count; i2++) {
          scope.vertices.push(new Vector3().fromBufferAttribute(position, i2));
          if (color !== void 0) {
            scope.colors.push(new Color().fromBufferAttribute(color, i2));
          }
        }
        function addFace(a, b, c, materialIndex) {
          const vertexColors = color === void 0 ? [] : [
            scope.colors[a].clone(),
            scope.colors[b].clone(),
            scope.colors[c].clone()
          ];
          const vertexNormals = normal === void 0 ? [] : [
            new Vector3().fromBufferAttribute(normal, a),
            new Vector3().fromBufferAttribute(normal, b),
            new Vector3().fromBufferAttribute(normal, c)
          ];
          const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
          scope.faces.push(face);
          if (uv !== void 0) {
            scope.faceVertexUvs[0].push([
              new Vector2().fromBufferAttribute(uv, a),
              new Vector2().fromBufferAttribute(uv, b),
              new Vector2().fromBufferAttribute(uv, c)
            ]);
          }
          if (uv2 !== void 0) {
            scope.faceVertexUvs[1].push([
              new Vector2().fromBufferAttribute(uv2, a),
              new Vector2().fromBufferAttribute(uv2, b),
              new Vector2().fromBufferAttribute(uv2, c)
            ]);
          }
        }
        const groups = geometry.groups;
        if (groups.length > 0) {
          for (let i2 = 0; i2 < groups.length; i2++) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              if (index !== void 0) {
                addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
              } else {
                addFace(j, j + 1, j + 2, group.materialIndex);
              }
            }
          }
        } else {
          if (index !== void 0) {
            for (let i2 = 0; i2 < index.count; i2 += 3) {
              addFace(index.getX(i2), index.getX(i2 + 1), index.getX(i2 + 2));
            }
          } else {
            for (let i2 = 0; i2 < position.count; i2 += 3) {
              addFace(i2, i2 + 1, i2 + 2);
            }
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      },
      normalize: function() {
        this.computeBoundingSphere();
        const center = this.boundingSphere.center;
        const radius = this.boundingSphere.radius;
        const s3 = radius === 0 ? 1 : 1 / radius;
        const matrix = new Matrix4();
        matrix.set(s3, 0, 0, -s3 * center.x, 0, s3, 0, -s3 * center.y, 0, 0, s3, -s3 * center.z, 0, 0, 0, 1);
        this.applyMatrix4(matrix);
        return this;
      },
      computeFaceNormals: function() {
        const cb = new Vector3(), ab = new Vector3();
        for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
          const face = this.faces[f3];
          const vA = this.vertices[face.a];
          const vB = this.vertices[face.b];
          const vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === void 0)
          areaWeighted = true;
        const vertices = new Array(this.vertices.length);
        for (let v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new Vector3();
        }
        if (areaWeighted) {
          const cb = new Vector3(), ab = new Vector3();
          for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
            const face = this.faces[f3];
            const vA = this.vertices[face.a];
            const vB = this.vertices[face.b];
            const vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          this.computeFaceNormals();
          for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
            const face = this.faces[f3];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (let v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
          const face = this.faces[f3];
          const vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(vertices[face.a]);
            vertexNormals[1].copy(vertices[face.b]);
            vertexNormals[2].copy(vertices[face.c]);
          } else {
            vertexNormals[0] = vertices[face.a].clone();
            vertexNormals[1] = vertices[face.b].clone();
            vertexNormals[2] = vertices[face.c].clone();
          }
        }
        if (this.faces.length > 0) {
          this.normalsNeedUpdate = true;
        }
      },
      computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
          const face = this.faces[f3];
          const vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(face.normal);
            vertexNormals[1].copy(face.normal);
            vertexNormals[2].copy(face.normal);
          } else {
            vertexNormals[0] = face.normal.clone();
            vertexNormals[1] = face.normal.clone();
            vertexNormals[2] = face.normal.clone();
          }
        }
        if (this.faces.length > 0) {
          this.normalsNeedUpdate = true;
        }
      },
      computeMorphNormals: function() {
        for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
          const face = this.faces[f3];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (let i2 = 0, il = face.vertexNormals.length; i2 < il; i2++) {
            if (!face.__originalVertexNormals[i2]) {
              face.__originalVertexNormals[i2] = face.vertexNormals[i2].clone();
            } else {
              face.__originalVertexNormals[i2].copy(face.vertexNormals[i2]);
            }
          }
        }
        const tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for (let i2 = 0, il = this.morphTargets.length; i2 < il; i2++) {
          if (!this.morphNormals[i2]) {
            this.morphNormals[i2] = {};
            this.morphNormals[i2].faceNormals = [];
            this.morphNormals[i2].vertexNormals = [];
            const dstNormalsFace = this.morphNormals[i2].faceNormals;
            const dstNormalsVertex = this.morphNormals[i2].vertexNormals;
            for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
              const faceNormal = new Vector3();
              const vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          const morphNormals = this.morphNormals[i2];
          tmpGeo.vertices = this.morphTargets[i2].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
            const face = this.faces[f3];
            const faceNormal = morphNormals.faceNormals[f3];
            const vertexNormals = morphNormals.vertexNormals[f3];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (let f3 = 0, fl = this.faces.length; f3 < fl; f3++) {
          const face = this.faces[f3];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
          console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
          return;
        }
        let normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === void 0)
          materialIndexOffset = 0;
        if (matrix !== void 0) {
          normalMatrix = new Matrix3().getNormalMatrix(matrix);
        }
        for (let i2 = 0, il = vertices2.length; i2 < il; i2++) {
          const vertex = vertices2[i2];
          const vertexCopy = vertex.clone();
          if (matrix !== void 0)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (let i2 = 0, il = colors2.length; i2 < il; i2++) {
          colors1.push(colors2[i2].clone());
        }
        for (let i2 = 0, il = faces2.length; i2 < il; i2++) {
          let face = faces2[i2], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
          faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== void 0) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== void 0) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (let i2 = 0, il = geometry.faceVertexUvs.length; i2 < il; i2++) {
          const faceVertexUvs2 = geometry.faceVertexUvs[i2];
          if (this.faceVertexUvs[i2] === void 0)
            this.faceVertexUvs[i2] = [];
          for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
            const uvs2 = faceVertexUvs2[j], uvsCopy = [];
            for (let k = 0, kl = uvs2.length; k < kl; k++) {
              uvsCopy.push(uvs2[k].clone());
            }
            this.faceVertexUvs[i2].push(uvsCopy);
          }
        }
      },
      mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
          console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
          return;
        }
        if (mesh.matrixAutoUpdate)
          mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        const verticesMap = {};
        const unique = [], changes = [];
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
          const v = this.vertices[i2];
          const key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
          if (verticesMap[key] === void 0) {
            verticesMap[key] = i2;
            unique.push(this.vertices[i2]);
            changes[i2] = unique.length - 1;
          } else {
            changes[i2] = changes[verticesMap[key]];
          }
        }
        const faceIndicesToRemove = [];
        for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
          const face = this.faces[i2];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          const indices = [face.a, face.b, face.c];
          for (let n = 0; n < 3; n++) {
            if (indices[n] === indices[(n + 1) % 3]) {
              faceIndicesToRemove.push(i2);
              break;
            }
          }
        }
        for (let i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--) {
          const idx = faceIndicesToRemove[i2];
          this.faces.splice(idx, 1);
          for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        const diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      setFromPoints: function(points) {
        this.vertices = [];
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function() {
        const faces = this.faces;
        const length = faces.length;
        for (let i2 = 0; i2 < length; i2++) {
          faces[i2]._id = i2;
        }
        function materialIndexSort(a, b) {
          return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        const uvs1 = this.faceVertexUvs[0];
        const uvs2 = this.faceVertexUvs[1];
        let newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length)
          newUvs1 = [];
        if (uvs2 && uvs2.length === length)
          newUvs2 = [];
        for (let i2 = 0; i2 < length; i2++) {
          const id = faces[i2]._id;
          if (newUvs1)
            newUvs1.push(uvs1[id]);
          if (newUvs2)
            newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
          this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
          this.faceVertexUvs[1] = newUvs2;
      },
      toJSON: function() {
        const data = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        const vertices = [];
        for (let i2 = 0; i2 < this.vertices.length; i2++) {
          const vertex = this.vertices[i2];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        const faces = [];
        const normals = [];
        const normalsHash = {};
        const colors = [];
        const colorsHash = {};
        const uvs = [];
        const uvsHash = {};
        for (let i2 = 0; i2 < this.faces.length; i2++) {
          const face = this.faces[i2];
          const hasMaterial = true;
          const hasFaceUv = false;
          const hasFaceVertexUv = this.faceVertexUvs[0][i2] !== void 0;
          const hasFaceNormal = face.normal.length() > 0;
          const hasFaceVertexNormal = face.vertexNormals.length > 0;
          const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          const hasFaceVertexColor = face.vertexColors.length > 0;
          let faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          faces.push(face.materialIndex);
          if (hasFaceVertexUv) {
            const faceVertexUvs = this.faceVertexUvs[0][i2];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            const vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            const vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value, position, enabled) {
          return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
          const hash2 = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash2] !== void 0) {
            return normalsHash[hash2];
          }
          normalsHash[hash2] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash2];
        }
        function getColorIndex(color) {
          const hash2 = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash2] !== void 0) {
            return colorsHash[hash2];
          }
          colorsHash[hash2] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash2];
        }
        function getUvIndex(uv) {
          const hash2 = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash2] !== void 0) {
            return uvsHash[hash2];
          }
          uvsHash[hash2] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash2];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
          data.data.colors = colors;
        if (uvs.length > 0)
          data.data.uvs = [uvs];
        data.data.faces = faces;
        return data;
      },
      clone: function() {
        return new Geometry().copy(this);
      },
      copy: function(source) {
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.name = source.name;
        const vertices = source.vertices;
        for (let i2 = 0, il = vertices.length; i2 < il; i2++) {
          this.vertices.push(vertices[i2].clone());
        }
        const colors = source.colors;
        for (let i2 = 0, il = colors.length; i2 < il; i2++) {
          this.colors.push(colors[i2].clone());
        }
        const faces = source.faces;
        for (let i2 = 0, il = faces.length; i2 < il; i2++) {
          this.faces.push(faces[i2].clone());
        }
        for (let i2 = 0, il = source.faceVertexUvs.length; i2 < il; i2++) {
          const faceVertexUvs = source.faceVertexUvs[i2];
          if (this.faceVertexUvs[i2] === void 0) {
            this.faceVertexUvs[i2] = [];
          }
          for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {
            const uvs = faceVertexUvs[j], uvsCopy = [];
            for (let k = 0, kl = uvs.length; k < kl; k++) {
              const uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            this.faceVertexUvs[i2].push(uvsCopy);
          }
        }
        const morphTargets = source.morphTargets;
        for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          const morphTarget = {};
          morphTarget.name = morphTargets[i2].name;
          if (morphTargets[i2].vertices !== void 0) {
            morphTarget.vertices = [];
            for (let j = 0, jl = morphTargets[i2].vertices.length; j < jl; j++) {
              morphTarget.vertices.push(morphTargets[i2].vertices[j].clone());
            }
          }
          if (morphTargets[i2].normals !== void 0) {
            morphTarget.normals = [];
            for (let j = 0, jl = morphTargets[i2].normals.length; j < jl; j++) {
              morphTarget.normals.push(morphTargets[i2].normals[j].clone());
            }
          }
          this.morphTargets.push(morphTarget);
        }
        const morphNormals = source.morphNormals;
        for (let i2 = 0, il = morphNormals.length; i2 < il; i2++) {
          const morphNormal = {};
          if (morphNormals[i2].vertexNormals !== void 0) {
            morphNormal.vertexNormals = [];
            for (let j = 0, jl = morphNormals[i2].vertexNormals.length; j < jl; j++) {
              const srcVertexNormal = morphNormals[i2].vertexNormals[j];
              const destVertexNormal = {};
              destVertexNormal.a = srcVertexNormal.a.clone();
              destVertexNormal.b = srcVertexNormal.b.clone();
              destVertexNormal.c = srcVertexNormal.c.clone();
              morphNormal.vertexNormals.push(destVertexNormal);
            }
          }
          if (morphNormals[i2].faceNormals !== void 0) {
            morphNormal.faceNormals = [];
            for (let j = 0, jl = morphNormals[i2].faceNormals.length; j < jl; j++) {
              morphNormal.faceNormals.push(morphNormals[i2].faceNormals[j].clone());
            }
          }
          this.morphNormals.push(morphNormal);
        }
        const skinWeights = source.skinWeights;
        for (let i2 = 0, il = skinWeights.length; i2 < il; i2++) {
          this.skinWeights.push(skinWeights[i2].clone());
        }
        const skinIndices = source.skinIndices;
        for (let i2 = 0, il = skinIndices.length; i2 < il; i2++) {
          this.skinIndices.push(skinIndices[i2].clone());
        }
        const lineDistances = source.lineDistances;
        for (let i2 = 0, il = lineDistances.length; i2 < il; i2++) {
          this.lineDistances.push(lineDistances[i2]);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    BoxGeometry = class extends Geometry {
      constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
      }
    };
    BoxBufferGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();
        this.type = "BoxBufferGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          const segmentWidth = width2 / gridX;
          const segmentHeight = height2 / gridY;
          const widthHalf = width2 / 2;
          const heightHalf = height2 / 2;
          const depthHalf = depth2 / 2;
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          let vertexCounter = 0;
          let groupCount = 0;
          const vector = new Vector3();
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segmentHeight - heightHalf;
            for (let ix = 0; ix < gridX1; ix++) {
              const x2 = ix * segmentWidth - widthHalf;
              vector[u] = x2 * udir;
              vector[v] = y * vdir;
              vector[w] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u] = 0;
              vector[v] = 0;
              vector[w] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = numberOfVertices + ix + gridX1 * iy;
              const b = numberOfVertices + ix + gridX1 * (iy + 1);
              const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              const d = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
    };
    UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    default_vertex = `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`;
    default_fragment = `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.extensions = Object.assign({}, source.extensions);
      return this;
    };
    ShaderMaterial.prototype.toJSON = function(meta) {
      const data = Material.prototype.toJSON.call(this, meta);
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    };
    Camera$1.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Camera$1,
      isCamera: true,
      copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      },
      getWorldDirection: function(target) {
        if (target === void 0) {
          console.warn("THREE.Camera: .getWorldDirection() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        const e2 = this.matrixWorld.elements;
        return target.set(-e2[8], -e2[9], -e2[10]).normalize();
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    });
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera$1.prototype), {
      constructor: PerspectiveCamera,
      isPerspectiveCamera: true,
      copy: function(source, recursive) {
        Camera$1.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      },
      setFocalLength: function(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      },
      getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      },
      getEffectiveFOV: function() {
        return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
      },
      getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function(fullWidth, fullHeight, x2, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x2;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      },
      clearViewOffset: function() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function() {
        let near = this.near, top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
        if (this.view !== null && this.view.enabled) {
          const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    });
    fov = 90;
    aspect = 1;
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;
    WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.format = RGBAFormat;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const scene = new Scene();
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,
        fragmentShader: `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
      };
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
      scene.add(mesh);
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, scene);
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    };
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;
    _sphere$2 = new Sphere();
    _vector$6 = new Vector3();
    Object.assign(Frustum.prototype, {
      set: function(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(frustum) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          planes[i2].copy(frustum.planes[i2]);
        }
        return this;
      },
      setFromProjectionMatrix: function(m2) {
        const planes = this.planes;
        const me = m2.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      },
      intersectsSprite: function(sprite) {
        _sphere$2.center.set(0, 0, 0);
        _sphere$2.radius = 0.7071067811865476;
        _sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      },
      intersectsSphere: function(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for (let i2 = 0; i2 < 6; i2++) {
          const distance = planes[i2].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function(box) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          const plane = planes[i2];
          _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$6) < 0) {
            return false;
          }
        }
        return true;
      },
      containsPoint: function(point) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          if (planes[i2].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
    });
    UniformsLib = {
      common: {
        diffuse: { value: new Color(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new Matrix3() },
        uv2Transform: { value: new Matrix3() },
        alphaMap: { value: null }
      },
      specularmap: {
        specularMap: { value: null }
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 }
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 }
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
      },
      emissivemap: {
        emissiveMap: { value: null }
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpScale: { value: 1 }
      },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new Vector2(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: {
        roughnessMap: { value: null }
      },
      metalnessmap: {
        metalnessMap: { value: null }
      },
      gradientmap: {
        gradientMap: { value: null }
      },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Color(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: { value: [], properties: {
          direction: {},
          color: {}
        } },
        directionalLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        } },
        spotLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: { value: [], properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        } },
        pointLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        } },
        rectAreaLights: { value: [], properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        } }
      },
      points: {
        diffuse: { value: new Color(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new Matrix3() }
      },
      sprite: {
        diffuse: { value: new Color(15658734) },
        opacity: { value: 1 },
        center: { value: new Vector2(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new Matrix3() }
      }
    };
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
    alphamap_fragment = `
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`;
    alphamap_pars_fragment = `
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;
    alphatest_fragment = `
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`;
    aomap_fragment = `
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`;
    aomap_pars_fragment = `
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`;
    begin_vertex = `
vec3 transformed = vec3( position );
`;
    beginnormal_vertex = `
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`;
    bsdfs = `

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney\u2019s reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)\u22C5G(v) / 4(n\u22C5l)(n\u22C5v)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney\u2019s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Ag\xFCera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`;
    bumpmap_pars_fragment = `
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 );

		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`;
    clipping_planes_fragment = `
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`;
    clipping_planes_pars_fragment = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`;
    clipping_planes_pars_vertex = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`;
    clipping_planes_vertex = `
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`;
    color_fragment = `
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif
`;
    color_pars_fragment = `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`;
    color_pars_vertex = `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`;
    color_vertex = `
#ifdef USE_COLOR

	vColor.xyz = color.xyz;

#endif
`;
    common = `
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`;
    cube_uv_reflection_fragment = `
#ifdef ENVMAP_TYPE_CUBE_UV

#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0

// These shader functions convert between the UV coordinates of a single face of
// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
// sampling a textureCube (not generally normalized).

float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}

// RH coordinate system; PMREM face-indexing convention
vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
    } else if (face == 1.0) {
      uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
    } else if (face == 2.0) {
      uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
    } else if (face == 3.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
    } else if (face == 4.0) {
      uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
    } else {
      uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
    }
    return 0.5 * (uv + 1.0);
}

vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);

  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);

  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;

  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}

// These defines must match with PMREMGenerator

#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0

float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
  }
  return mip;
}

vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);

  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif
`;
    defaultnormal_vertex = `
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`;
    displacementmap_pars_vertex = `
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`;
    displacementmap_vertex = `
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`;
    emissivemap_fragment = `
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`;
    emissivemap_pars_fragment = `
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`;
    encodings_fragment = `
gl_FragColor = linearToOutputTexel( gl_FragColor );
`;
    encodings_pars_fragment = `
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`;
    envmap_fragment = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;
		
		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		}  else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#elif defined( ENVMAP_TYPE_EQUIREC )

		reflectVec = normalize( reflectVec );

		vec2 sampleUV = equirectUv( reflectVec );

		vec4 envColor = texture2D( envMap, sampleUV );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`;
    envmap_common_pars_fragment = `
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`;
    envmap_pars_fragment = `
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`;
    envmap_pars_vertex = `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`;
    envmap_vertex = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`;
    fog_vertex = `
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`;
    fog_pars_vertex = `
#ifdef USE_FOG

	varying float fogDepth;

#endif
`;
    fog_fragment = `
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`;
    fog_pars_fragment = `
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`;
    gradientmap_pars_fragment = `

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`;
    lightmap_fragment = `
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`;
    lightmap_pars_fragment = `
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`;
    lights_lambert_vertex = `
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`;
    lights_pars_begin = `
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`;
    envmap_physical_pars_fragment = `
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

		  vec3 reflectVec = reflect( -viewDir, normal );

		  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#elif defined( ENVMAP_TYPE_EQUIREC )

			vec2 sampleUV = equirectUv( reflectVec );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );

			#else

				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`;
    lights_toon_fragment = `
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`;
    lights_toon_pars_fragment = `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`;
    lights_phong_fragment = `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`;
    lights_phong_pars_fragment = `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`;
    lights_physical_fragment = `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`;
    lights_physical_pars_fragment = `
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`;
    lights_fragment_begin = `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`;
    lights_fragment_maps = `
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`;
    lights_fragment_end = `
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`;
    logdepthbuf_fragment = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`;
    logdepthbuf_pars_fragment = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`;
    logdepthbuf_pars_vertex = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`;
    logdepthbuf_vertex = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`;
    map_fragment = `
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`;
    map_pars_fragment = `
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`;
    map_particle_fragment = `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;
    map_particle_pars_fragment = `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;
    metalnessmap_fragment = `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`;
    metalnessmap_pars_fragment = `
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`;
    morphnormal_vertex = `
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`;
    morphtarget_pars_vertex = `
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`;
    morphtarget_vertex = `
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`;
    normal_fragment_begin = `
#ifdef FLAT_SHADED

	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`;
    normal_fragment_maps = `

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );

#endif
`;
    normalmap_pars_fragment = `
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Per-Pixel Tangent Space Normal Mapping
	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );

		mat3 tsn = mat3( S, T, N );

		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		return normalize( tsn * mapN );

	}

#endif
`;
    clearcoat_normal_fragment_begin = `
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`;
    clearcoat_normal_fragment_maps = `
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );

	#endif

#endif
`;
    clearcoat_pars_fragment = `

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`;
    packing = `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`;
    premultiplied_alpha_fragment = `
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`;
    project_vertex = `
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`;
    dithering_fragment = `
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`;
    dithering_pars_fragment = `
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`;
    roughnessmap_fragment = `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`;
    roughnessmap_pars_fragment = `
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`;
    shadowmap_pars_fragment = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`;
    shadowmap_pars_vertex = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`;
    shadowmap_vertex = `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`;
    shadowmask_pars_fragment = `
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`;
    skinbase_vertex = `
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`;
    skinning_pars_vertex = `
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`;
    skinning_vertex = `
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`;
    skinnormal_vertex = `
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`;
    specularmap_fragment = `
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`;
    specularmap_pars_fragment = `
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`;
    tonemapping_fragment = `
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`;
    tonemapping_pars_fragment = `
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`;
    transmissionmap_fragment = `
#ifdef USE_TRANSMISSIONMAP

	totalTransmission *= texture2D( transmissionMap, vUv ).r;

#endif
`;
    transmissionmap_pars_fragment = `
#ifdef USE_TRANSMISSIONMAP

	uniform sampler2D transmissionMap;

#endif
`;
    uv_pars_fragment = `
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`;
    uv_pars_vertex = `
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`;
    uv_vertex = `
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`;
    uv2_pars_fragment = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`;
    uv2_pars_vertex = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`;
    uv2_vertex = `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`;
    worldpos_vertex = `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`;
    background_frag = `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
    background_vert = `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`;
    cube_frag = `
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
    cube_vert = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;
    depth_frag = `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`;
    depth_vert = `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`;
    distanceRGBA_frag = `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`;
    distanceRGBA_vert = `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`;
    equirect_frag = `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;
    equirect_vert = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`;
    linedashed_frag = `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;
    linedashed_vert = `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;
    meshbasic_frag = `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
    meshbasic_vert = `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`;
    meshlambert_frag = `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
    meshlambert_vert = `
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`;
    meshmatcap_frag = `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
    meshmatcap_vert = `
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`;
    meshtoon_frag = `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
    meshtoon_vert = `
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
    meshphong_frag = `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
    meshphong_vert = `
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
    meshphysical_frag = `
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSMISSION
	uniform float transmission;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transmission model
	#ifdef TRANSMISSION
		diffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;
    meshphysical_vert = `
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
    normal_frag = `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`;
    normal_vert = `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`;
    points_frag = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;
    points_vert = `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;
    shadow_frag = `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;
    shadow_vert = `
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;
    sprite_frag = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;
    sprite_vert = `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;
    ShaderChunk = {
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      encodings_fragment,
      encodings_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_fragment,
      lightmap_pars_fragment,
      lights_lambert_vertex,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      transmissionmap_fragment,
      transmissionmap_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      uv2_pars_fragment,
      uv2_pars_vertex,
      uv2_vertex,
      worldpos_vertex,
      background_frag,
      background_vert,
      cube_frag,
      cube_vert,
      depth_frag,
      depth_vert,
      distanceRGBA_frag,
      distanceRGBA_vert,
      equirect_frag,
      equirect_vert,
      linedashed_frag,
      linedashed_vert,
      meshbasic_frag,
      meshbasic_vert,
      meshlambert_frag,
      meshlambert_vert,
      meshmatcap_frag,
      meshmatcap_vert,
      meshtoon_frag,
      meshtoon_vert,
      meshphong_frag,
      meshphong_vert,
      meshphysical_frag,
      meshphysical_vert,
      normal_frag,
      normal_vert,
      points_frag,
      points_vert,
      shadow_frag,
      shadow_vert,
      sprite_frag,
      sprite_vert
    };
    ShaderLib = {
      basic: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            specular: { value: new Color(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.roughnessmap,
          UniformsLib.metalnessmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.gradientmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          {
            matcap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: mergeUniforms([
          UniformsLib.points,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
      },
      sprite: {
        uniforms: mergeUniforms([
          UniformsLib.sprite,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: { value: new Matrix3() },
          t2D: { value: null }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      cube: {
        uniforms: mergeUniforms([
          UniformsLib.envmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap,
          {
            referencePosition: { value: new Vector3() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: mergeUniforms([
          UniformsLib.lights,
          UniformsLib.fog,
          {
            color: { value: new Color(0) },
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new Vector2(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: new Color(0) },
          transmission: { value: 0 },
          transmissionMap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, "images", {
      get: function() {
        return this.image;
      },
      set: function(value) {
        this.image = value;
      }
    });
    DataTexture2DArray.prototype = Object.create(Texture.prototype);
    DataTexture2DArray.prototype.constructor = DataTexture2DArray;
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    DataTexture3D.prototype = Object.create(Texture.prototype);
    DataTexture3D.prototype.constructor = DataTexture3D;
    DataTexture3D.prototype.isDataTexture3D = true;
    emptyTexture = new Texture();
    emptyTexture2dArray = new DataTexture2DArray();
    emptyTexture3d = new DataTexture3D();
    emptyCubeTexture = new CubeTexture();
    arrayCacheF32 = [];
    arrayCacheI32 = [];
    mat4array = new Float32Array(16);
    mat3array = new Float32Array(9);
    mat2array = new Float32Array(4);
    PureArrayUniform.prototype.updateCache = function(data) {
      let cache = this.cache;
      if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
      }
      copyArray(cache, data);
    };
    StructuredUniform.prototype.setValue = function(gl, value, textures) {
      const seq = this.seq;
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        u.setValue(gl, value[u.id], textures);
      }
    };
    RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
      const u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
      const v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, textures) {
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
      const r2 = [];
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        if (u.id in values)
          r2.push(u);
      }
      return r2;
    };
    programIdCount = 0;
    includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
    nextVersion = 0;
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.depthPacking = source.depthPacking;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    MeshDistanceMaterial.prototype = Object.create(Material.prototype);
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    };
    vsm_frag = `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

  float mean = 0.0;
  float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );

  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

    #ifdef HORIZONAL_PASS

      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

    #else

      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;

    #endif

  }

  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;

  float std_dev = sqrt( squared_mean - mean * mean );

  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;
    vsm_vert = `
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
      constructor: ArrayCamera,
      isArrayCamera: true
    });
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Group,
      isGroup: true
    });
    Object.assign(WebXRController.prototype, {
      constructor: WebXRController,
      getHandSpace: function() {
        if (this._hand === null) {
          this._hand = new Group();
          this._hand.matrixAutoUpdate = false;
          this._hand.visible = false;
          this._hand.joints = [];
          this._hand.inputState = { pinching: false };
          if (window.XRHand) {
            for (let i2 = 0; i2 <= window.XRHand.LITTLE_PHALANX_TIP; i2++) {
              let joint = new Group();
              joint.matrixAutoUpdate = false;
              joint.visible = false;
              this._hand.joints.push(joint);
              this._hand.add(joint);
            }
          }
        }
        return this._hand;
      },
      getTargetRaySpace: function() {
        if (this._targetRay === null) {
          this._targetRay = new Group();
          this._targetRay.matrixAutoUpdate = false;
          this._targetRay.visible = false;
        }
        return this._targetRay;
      },
      getGripSpace: function() {
        if (this._grip === null) {
          this._grip = new Group();
          this._grip.matrixAutoUpdate = false;
          this._grip.visible = false;
        }
        return this._grip;
      },
      dispatchEvent: function(event) {
        if (this._targetRay !== null) {
          this._targetRay.dispatchEvent(event);
        }
        if (this._grip !== null) {
          this._grip.dispatchEvent(event);
        }
        if (this._hand !== null) {
          this._hand.dispatchEvent(event);
        }
        return this;
      },
      disconnect: function(inputSource) {
        this.dispatchEvent({ type: "disconnected", data: inputSource });
        if (this._targetRay !== null) {
          this._targetRay.visible = false;
        }
        if (this._grip !== null) {
          this._grip.visible = false;
        }
        if (this._hand !== null) {
          this._hand.visible = false;
        }
        return this;
      },
      update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource) {
          if (inputSource.hand) {
            handPose = true;
            for (let i2 = 0; i2 <= window.XRHand.LITTLE_PHALANX_TIP; i2++) {
              if (inputSource.hand[i2]) {
                let jointPose = frame.getJointPose(inputSource.hand[i2], referenceSpace);
                const joint = hand.joints[i2];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
                const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
                const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const distanceToPinch = 0.02;
                const threshold = 5e-3;
                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                  hand.inputState.pinching = false;
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: inputSource.handedness,
                    target: this
                  });
                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                  hand.inputState.pinching = true;
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: inputSource.handedness,
                    target: this
                  });
                }
              }
            }
          } else {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
              }
            }
            if (grip !== null && inputSource.gripSpace) {
              gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
              if (gripPose !== null) {
                grip.matrix.fromArray(gripPose.transform.matrix);
                grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              }
            }
          }
        }
        if (targetRay !== null) {
          targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
          grip.visible = gripPose !== null;
        }
        if (hand !== null) {
          hand.visible = handPose !== null;
        }
        return this;
      }
    });
    Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
    WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
      constructor: WebGL1Renderer,
      isWebGL1Renderer: true
    });
    Object.assign(FogExp2.prototype, {
      isFogExp2: true,
      clone: function() {
        return new FogExp2(this.color, this.density);
      },
      toJSON: function() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      }
    });
    Object.assign(Fog.prototype, {
      isFog: true,
      clone: function() {
        return new Fog(this.color, this.near, this.far);
      },
      toJSON: function() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    });
    Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
      set: function(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.assign(InterleavedBuffer.prototype, {
      isInterleavedBuffer: true,
      onUploadCallback: function() {
      },
      setUsage: function(value) {
        this.usage = value;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (let i2 = 0, l = this.stride; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === void 0)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      clone: function(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = MathUtils.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      },
      onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
      },
      toJSON: function(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = MathUtils.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    });
    _vector$5 = new Vector3();
    Object.defineProperties(InterleavedBufferAttribute.prototype, {
      count: {
        get: function() {
          return this.data.count;
        }
      },
      array: {
        get: function() {
          return this.data.array;
        }
      },
      needsUpdate: {
        set: function(value) {
          this.data.needsUpdate = value;
        }
      }
    });
    Object.assign(InterleavedBufferAttribute.prototype, {
      isInterleavedBufferAttribute: true,
      applyMatrix4: function(m2) {
        for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
          _vector$5.x = this.getX(i2);
          _vector$5.y = this.getY(i2);
          _vector$5.z = this.getZ(i2);
          _vector$5.applyMatrix4(m2);
          this.setXYZ(i2, _vector$5.x, _vector$5.y, _vector$5.z);
        }
        return this;
      },
      setX: function(index, x2) {
        this.data.array[index * this.data.stride + this.offset] = x2;
        return this;
      },
      setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
      },
      setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      },
      setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      },
      getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
      },
      getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
      },
      getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
      },
      getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
      },
      setXY: function(index, x2, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x2;
        this.data.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x2, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x2;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x2, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x2;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      },
      clone: function(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      },
      toJSON: function(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    });
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    SpriteMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    };
    _intersectPoint = new Vector3();
    _worldScale = new Vector3();
    _mvPosition = new Vector3();
    _alignedPosition = new Vector2();
    _rotatedPosition = new Vector2();
    _viewWorldMatrix = new Matrix4();
    _vA = new Vector3();
    _vB = new Vector3();
    _vC = new Vector3();
    _uvA = new Vector2();
    _uvB = new Vector2();
    _uvC = new Vector2();
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Sprite,
      isSprite: true,
      raycast: function(raycaster, intersects2) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);
        let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect === null) {
          transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
          face: null,
          object: this
        });
      },
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== void 0)
          this.center.copy(source.center);
        this.material = source.material;
        return this;
      }
    });
    _v1$1 = new Vector3();
    _v2$1 = new Vector3();
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: LOD,
      isLOD: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for (let i2 = 0, l = levels.length; i2 < l; i2++) {
          const level = levels[i2];
          this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      },
      addLevel: function(object, distance) {
        if (distance === void 0)
          distance = 0;
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for (l = 0; l < levels.length; l++) {
          if (distance < levels[l].distance) {
            break;
          }
        }
        levels.splice(l, 0, { distance, object });
        this.add(object);
        return this;
      },
      getCurrentLevel: function() {
        return this._currentLevel;
      },
      getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
          let i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance < levels[i2].distance) {
              break;
            }
          }
          return levels[i2 - 1].object;
        }
        return null;
      },
      raycast: function(raycaster, intersects2) {
        const levels = this.levels;
        if (levels.length > 0) {
          _v1$1.setFromMatrixPosition(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(_v1$1);
          this.getObjectForDistance(distance).raycast(raycaster, intersects2);
        }
      },
      update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
          _v1$1.setFromMatrixPosition(camera.matrixWorld);
          _v2$1.setFromMatrixPosition(this.matrixWorld);
          const distance = _v1$1.distanceTo(_v2$1) / camera.zoom;
          levels[0].object.visible = true;
          let i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance >= levels[i2].distance) {
              levels[i2 - 1].object.visible = false;
              levels[i2].object.visible = true;
            } else {
              break;
            }
          }
          this._currentLevel = i2 - 1;
          for (; i2 < l; i2++) {
            levels[i2].object.visible = false;
          }
        }
      },
      toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false)
          data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for (let i2 = 0, l = levels.length; i2 < l; i2++) {
          const level = levels[i2];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance
          });
        }
        return data;
      }
    });
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
      constructor: SkinnedMesh,
      isSkinnedMesh: true,
      copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
      },
      bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
      },
      pose: function() {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
          vector.x = skinWeight.getX(i2);
          vector.y = skinWeight.getY(i2);
          vector.z = skinWeight.getZ(i2);
          vector.w = skinWeight.getW(i2);
          const scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
      },
      updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === "attached") {
          this.bindMatrixInverse.getInverse(this.matrixWorld);
        } else if (this.bindMode === "detached") {
          this.bindMatrixInverse.getInverse(this.bindMatrix);
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      },
      boneTransform: function() {
        const basePosition = new Vector3();
        const skinIndex = new Vector4();
        const skinWeight = new Vector4();
        const vector = new Vector3();
        const matrix = new Matrix4();
        return function(index, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
          skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
          basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i2 = 0; i2 < 4; i2++) {
            const weight = skinWeight.getComponent(i2);
            if (weight !== 0) {
              const boneIndex = skinIndex.getComponent(i2);
              matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        };
      }()
    });
    _offsetMatrix = new Matrix4();
    _identityMatrix = new Matrix4();
    Object.assign(Skeleton.prototype, {
      calculateInverses: function() {
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const inverse = new Matrix4();
          if (this.bones[i2]) {
            inverse.getInverse(this.bones[i2].matrixWorld);
          }
          this.boneInverses.push(inverse);
        }
      },
      pose: function() {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            bone.matrixWorld.getInverse(this.boneInverses[i2]);
          }
        }
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            if (bone.parent && bone.parent.isBone) {
              bone.matrix.getInverse(bone.parent.matrixWorld);
              bone.matrix.multiply(bone.matrixWorld);
            } else {
              bone.matrix.copy(bone.matrixWorld);
            }
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          }
        }
      },
      update: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        for (let i2 = 0, il = bones.length; i2 < il; i2++) {
          const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
          _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
          _offsetMatrix.toArray(boneMatrices, i2 * 16);
        }
        if (boneTexture !== void 0) {
          boneTexture.needsUpdate = true;
        }
      },
      clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
      },
      getBoneByName: function(name) {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone.name === name) {
            return bone;
          }
        }
        return void 0;
      },
      dispose: function() {
        if (this.boneTexture) {
          this.boneTexture.dispose();
          this.boneTexture = void 0;
        }
      }
    });
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Bone,
      isBone: true
    });
    _instanceLocalMatrix = new Matrix4();
    _instanceWorldMatrix = new Matrix4();
    _instanceIntersects = [];
    _mesh = new Mesh();
    InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
      constructor: InstancedMesh,
      isInstancedMesh: true,
      copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        this.count = source.count;
        return this;
      },
      getMatrixAt: function(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
      },
      raycast: function(raycaster, intersects2) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === void 0)
          return;
        for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
          _mesh.matrixWorld = _instanceWorldMatrix;
          _mesh.raycast(raycaster, _instanceIntersects);
          for (let i2 = 0, l = _instanceIntersects.length; i2 < l; i2++) {
            const intersect = _instanceIntersects[i2];
            intersect.instanceId = instanceId;
            intersect.object = this;
            intersects2.push(intersect);
          }
          _instanceIntersects.length = 0;
        }
      },
      setMatrixAt: function(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
      },
      updateMorphTargets: function() {
      }
    });
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.morphTargets = source.morphTargets;
      return this;
    };
    _start$1 = new Vector3();
    _end$1 = new Vector3();
    _inverseMatrix$1 = new Matrix4();
    _ray$1 = new Ray();
    _sphere$1 = new Sphere();
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Line,
      isLine: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [0];
            for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
              _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
              _end$1.fromBufferAttribute(positionAttribute, i2);
              lineDistances[i2] = lineDistances[i2 - 1];
              lineDistances[i2] += _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          const vertices = geometry.vertices;
          const lineDistances = geometry.lineDistances;
          lineDistances[0] = 0;
          for (let i2 = 1, l = vertices.length; i2 < l; i2++) {
            lineDistances[i2] = lineDistances[i2 - 1];
            lineDistances[i2] += vertices[i2 - 1].distanceTo(vertices[i2]);
          }
        }
        return this;
      },
      raycast: function(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false)
          return;
        _inverseMatrix$1.getInverse(matrixWorld);
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this && this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positions = attributes.position.array;
          if (index !== null) {
            const indices = index.array;
            for (let i2 = 0, l = indices.length - 1; i2 < l; i2 += step) {
              const a = indices[i2];
              const b = indices[i2 + 1];
              vStart.fromArray(positions, a * 3);
              vEnd.fromArray(positions, b * 3);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            for (let i2 = 0, l = positions.length / 3 - 1; i2 < l; i2 += step) {
              vStart.fromArray(positions, 3 * i2);
              vEnd.fromArray(positions, 3 * i2 + 3);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry.isGeometry) {
          const vertices = geometry.vertices;
          const nbVertices = vertices.length;
          for (let i2 = 0; i2 < nbVertices - 1; i2 += step) {
            const distSq = _ray$1.distanceSqToSegment(vertices[i2], vertices[i2 + 1], interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i2,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      },
      updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                const name = morphAttribute[m2].name || String(m2);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m2;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    });
    _start = new Vector3();
    _end = new Vector3();
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
      constructor: LineSegments,
      isLineSegments: true,
      computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
              _start.fromBufferAttribute(positionAttribute, i2);
              _end.fromBufferAttribute(positionAttribute, i2 + 1);
              lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
              lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          const vertices = geometry.vertices;
          const lineDistances = geometry.lineDistances;
          for (let i2 = 0, l = vertices.length; i2 < l; i2 += 2) {
            _start.copy(vertices[i2]);
            _end.copy(vertices[i2 + 1]);
            lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
            lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
          }
        }
        return this;
      }
    });
    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
      constructor: LineLoop,
      isLineLoop: true
    });
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.morphTargets = source.morphTargets;
      return this;
    };
    _inverseMatrix = new Matrix4();
    _ray = new Ray();
    _sphere = new Sphere();
    _position$2 = new Vector3();
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Points,
      isPoints: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      raycast: function(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false)
          return;
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positions = attributes.position.array;
          if (index !== null) {
            const indices = index.array;
            for (let i2 = 0, il = indices.length; i2 < il; i2++) {
              const a = indices[i2];
              _position$2.fromArray(positions, a * 3);
              testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          } else {
            for (let i2 = 0, l = positions.length / 3; i2 < l; i2++) {
              _position$2.fromArray(positions, i2 * 3);
              testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          }
        } else {
          const vertices = geometry.vertices;
          for (let i2 = 0, l = vertices.length; i2 < l; i2++) {
            testPoint(vertices[i2], i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      },
      updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                const name = morphAttribute[m2].name || String(m2);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m2;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    });
    VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
      constructor: VideoTexture,
      isVideoTexture: true,
      update: function() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    });
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    CanvasTexture.prototype.isCanvasTexture = true;
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;
    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;
    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;
    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
    TubeBufferGeometry.prototype.toJSON = function() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      data.path = this.parameters.path.toJSON();
      return data;
    };
    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;
    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    Earcut = {
      triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        let hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        let minX, minY, maxX, maxY, x2, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (let i2 = dim; i2 < outerLen; i2 += dim) {
            x2 = data[i2];
            y = data[i2 + 1];
            if (x2 < minX)
              minX = x2;
            if (y < minY)
              minY = y;
            if (x2 > maxX)
              maxX = x2;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
    };
    ShapeUtils = {
      area: function(contour) {
        const n = contour.length;
        let a = 0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      },
      isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
      },
      triangulateShape: function(contour, holes) {
        const vertices = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i2 = 0; i2 < holes.length; i2++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i2].length;
          addContour(vertices, holes[i2]);
        }
        const triangles = Earcut.triangulate(vertices, holeIndices);
        for (let i2 = 0; i2 < triangles.length; i2 += 3) {
          faces.push(triangles.slice(i2, i2 + 3));
        }
        return faces;
      }
    };
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
    ExtrudeGeometry.prototype.toJSON = function() {
      const data = Geometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      const options2 = this.parameters.options;
      return toJSON$1(shapes, options2, data);
    };
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
    ExtrudeBufferGeometry.prototype.toJSON = function() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      const options2 = this.parameters.options;
      return toJSON$1(shapes, options2, data);
    };
    WorldUVGenerator = {
      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
          new Vector2(a_x, a_y),
          new Vector2(b_x, b_y),
          new Vector2(c_x, c_y)
        ];
      },
      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) {
          return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
          ];
        } else {
          return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
          ];
        }
      }
    };
    TextGeometry.prototype = Object.create(Geometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;
    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;
    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    ShapeGeometry.prototype.toJSON = function() {
      const data = Geometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      return toJSON(shapes, data);
    };
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    ShapeBufferGeometry.prototype.toJSON = function() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      return toJSON(shapes, data);
    };
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;
    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    Geometries = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      WireframeGeometry,
      ParametricGeometry,
      ParametricBufferGeometry,
      TetrahedronGeometry,
      TetrahedronBufferGeometry,
      OctahedronGeometry,
      OctahedronBufferGeometry,
      IcosahedronGeometry,
      IcosahedronBufferGeometry,
      DodecahedronGeometry,
      DodecahedronBufferGeometry,
      PolyhedronGeometry,
      PolyhedronBufferGeometry,
      TubeGeometry,
      TubeBufferGeometry,
      TorusKnotGeometry,
      TorusKnotBufferGeometry,
      TorusGeometry,
      TorusBufferGeometry,
      TextGeometry,
      TextBufferGeometry,
      SphereGeometry,
      SphereBufferGeometry,
      RingGeometry,
      RingBufferGeometry,
      PlaneGeometry,
      PlaneBufferGeometry,
      LatheGeometry,
      LatheBufferGeometry,
      ShapeGeometry,
      ShapeBufferGeometry,
      ExtrudeGeometry,
      ExtrudeBufferGeometry,
      EdgesGeometry,
      ConeGeometry,
      ConeBufferGeometry,
      CylinderGeometry,
      CylinderBufferGeometry,
      CircleGeometry,
      CircleBufferGeometry,
      BoxGeometry,
      BoxBufferGeometry
    });
    ShadowMaterial.prototype = Object.create(Material.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;
    ShadowMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      return this;
    };
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.defines = { "STANDARD": "" };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.vertexTangents = source.vertexTangents;
      return this;
    };
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function(source) {
      MeshStandardMaterial.prototype.copy.call(this, source);
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.reflectivity = source.reflectivity;
      if (source.sheen) {
        this.sheen = (this.sheen || new Color()).copy(source.sheen);
      } else {
        this.sheen = null;
      }
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      return this;
    };
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    MeshToonMaterial.prototype = Object.create(Material.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    MeshMatcapMaterial.prototype = Object.create(Material.prototype);
    MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    MeshMatcapMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.defines = { "MATCAP": "" };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function(source) {
      LineBasicMaterial.prototype.copy.call(this, source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    };
    Materials = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    });
    AnimationUtils = {
      arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) {
          return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
        }
        return array.slice(from, to);
      },
      convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
          return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array);
        }
        return Array.prototype.slice.call(array);
      },
      isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function(times) {
        function compareTime(i2, j) {
          return times[i2] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for (let i2 = 0; i2 !== n; ++i2)
          result[i2] = i2;
        result.sort(compareTime);
        return result;
      },
      sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
          const srcOffset = order[i2] * stride;
          for (let j = 0; j !== stride; ++j) {
            result[dstOffset++] = values[srcOffset + j];
          }
        }
        return result;
      },
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i2 = 1, key = jsonKeys[0];
        while (key !== void 0 && key[valuePropertyName] === void 0) {
          key = jsonKeys[i2++];
        }
        if (key === void 0)
          return;
        let value = key[valuePropertyName];
        if (value === void 0)
          return;
        if (Array.isArray(value)) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push.apply(values, value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else if (value.toArray !== void 0) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              value.toArray(values, values.length);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push(value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        }
      },
      subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          const track = clip.tracks[i2];
          const valueSize = track.getValueSize();
          const times = [];
          const values = [];
          for (let j = 0; j < track.times.length; ++j) {
            const frame = track.times[j] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j]);
            for (let k = 0; k < valueSize; ++k) {
              values.push(track.values[j * valueSize + k]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils.convertArray(times, track.times.constructor);
          track.values = AnimationUtils.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          if (minStartTime > clip.tracks[i2].times[0]) {
            minStartTime = clip.tracks[i2].times[0];
          }
        }
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          clip.tracks[i2].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      },
      makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === void 0)
          referenceFrame = 0;
        if (referenceClip === void 0)
          referenceClip = targetClip;
        if (fps === void 0 || fps <= 0)
          fps = 30;
        const numTracks = targetClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for (let i2 = 0; i2 < numTracks; ++i2) {
          const referenceTrack = referenceClip.tracks[i2];
          const referenceTrackType = referenceTrack.ValueTypeName;
          if (referenceTrackType === "bool" || referenceTrackType === "string")
            continue;
          const targetTrack = targetClip.tracks.find(function(track) {
            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
          });
          if (targetTrack === void 0)
            continue;
          const valueSize = referenceTrack.getValueSize();
          const lastIndex = referenceTrack.times.length - 1;
          let referenceValue;
          if (referenceTime <= referenceTrack.times[0]) {
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, 0, referenceTrack.valueSize);
          } else if (referenceTime >= referenceTrack.times[lastIndex]) {
            const startIndex = lastIndex * valueSize;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex);
          } else {
            const interpolant = referenceTrack.createInterpolant();
            interpolant.evaluate(referenceTime);
            referenceValue = interpolant.resultBuffer;
          }
          if (referenceTrackType === "quaternion") {
            const referenceQuat = new Quaternion(referenceValue[0], referenceValue[1], referenceValue[2], referenceValue[3]).normalize().conjugate();
            referenceQuat.toArray(referenceValue);
          }
          const numTimes = targetTrack.times.length;
          for (let j = 0; j < numTimes; ++j) {
            const valueStart = j * valueSize;
            if (referenceTrackType === "quaternion") {
              Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
            } else {
              for (let k = 0; k < valueSize; ++k) {
                targetTrack.values[valueStart + k] -= referenceValue[k];
              }
            }
          }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
      }
    };
    Object.assign(Interpolant.prototype, {
      evaluate: function(t2) {
        let pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            let right;
            linear_scan: {
              forward_scan:
                if (!(t2 < t1)) {
                  for (let giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t2 < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.afterEnd_(i1 - 1, t2, t0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t2 < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t2 >= t0)) {
                const t1global = pp[1];
                if (t2 < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (let giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t2, t1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t2 >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              const mid = i1 + right >>> 1;
              if (t2 < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.beforeStart_(0, t2, t1);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.afterEnd_(i1 - 1, t0, t2);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t2, t1);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function() {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function(index) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset + i2];
        }
        return result;
      },
      interpolate_: function() {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function() {
      }
    });
    Object.assign(Interpolant.prototype, {
      beforeStart_: Interpolant.prototype.copySampleValue_,
      afterEnd_: Interpolant.prototype.copySampleValue_
    });
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: CubicInterpolant,
      DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      },
      intervalChanged_: function(i1, t0, t1) {
        let pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      },
      interpolate_: function(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t2 - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
        }
        return result;
      }
    });
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: LinearInterpolant,
      interpolate_: function(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
        }
        return result;
      }
    });
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: DiscreteInterpolant,
      interpolate_: function(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    });
    Object.assign(KeyframeTrack, {
      toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== void 0) {
          json = trackType.toJSON(track);
        } else {
          json = {
            "name": track.name,
            "times": AnimationUtils.convertArray(track.times, Array),
            "values": AnimationUtils.convertArray(track.values, Array)
          };
          const interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
    });
    Object.assign(KeyframeTrack.prototype, {
      constructor: KeyframeTrack,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: InterpolateLinear,
      InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      setInterpolation: function(interpolation) {
        let factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      },
      getInterpolation: function() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      },
      getValueSize: function() {
        return this.values.length / this.times.length;
      },
      shift: function(timeOffset) {
        if (timeOffset !== 0) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] += timeOffset;
          }
        }
        return this;
      },
      scale: function(timeScale) {
        if (timeScale !== 1) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] *= timeScale;
          }
        }
        return this;
      },
      trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          const stride = this.getValueSize();
          this.times = AnimationUtils.arraySlice(times, from, to);
          this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
      },
      validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        let prevTime = null;
        for (let i2 = 0; i2 !== nKeys; i2++) {
          const currTime = times[i2];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils.isTypedArray(values)) {
            for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
              const value = values[i2];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      },
      optimize: function() {
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for (let i2 = 1; i2 < lastIndex; ++i2) {
          let keep = false;
          const time = times[i2];
          const timeNext = times[i2 + 1];
          if (time !== timeNext && (i2 !== 1 || time !== time[0])) {
            if (!smoothInterpolation) {
              const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (let j = 0; j !== stride; ++j) {
                const value = values[offset + j];
                if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i2 !== writeIndex) {
              times[writeIndex] = times[i2];
              const readOffset = i2 * stride, writeOffset = writeIndex * stride;
              for (let j = 0; j !== stride; ++j) {
                values[writeOffset + j] = values[readOffset + j];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      },
      clone: function() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    });
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: BooleanKeyframeTrack,
      ValueTypeName: "bool",
      ValueBufferType: Array,
      DefaultInterpolation: InterpolateDiscrete,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    });
    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: ColorKeyframeTrack,
      ValueTypeName: "color"
    });
    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: NumberKeyframeTrack,
      ValueTypeName: "number"
    });
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: QuaternionLinearInterpolant,
      interpolate_: function(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
        let offset = i1 * stride;
        for (let end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    });
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: QuaternionKeyframeTrack,
      ValueTypeName: "quaternion",
      DefaultInterpolation: InterpolateLinear,
      InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodSmooth: void 0
    });
    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: StringKeyframeTrack,
      ValueTypeName: "string",
      ValueBufferType: Array,
      DefaultInterpolation: InterpolateDiscrete,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    });
    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: VectorKeyframeTrack,
      ValueTypeName: "vector"
    });
    Object.assign(AnimationClip, {
      parse: function(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
          tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
        }
        return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
      },
      toJSON: function(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
          "name": clip.name,
          "duration": clip.duration,
          "tracks": tracks,
          "uuid": clip.uuid,
          "blendMode": clip.blendMode
        };
        for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
        }
        return json;
      },
      CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for (let i2 = 0; i2 < numMorphTargets; i2++) {
          let times = [];
          let values = [];
          times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
          values.push(0, 1, 0);
          const order = AnimationUtils.getKeyframeOrder(times);
          times = AnimationUtils.sortedArray(times, 1, order);
          values = AnimationUtils.sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
      },
      findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          const o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (let i2 = 0; i2 < clipArray.length; i2++) {
          if (clipArray[i2].name === name) {
            return clipArray[i2];
          }
        }
        return null;
      },
      CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        const pattern = /^([\w-]*?)([\d]+)$/;
        for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          const morphTarget = morphTargets[i2];
          const parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            const name = parts[1];
            let animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        const clips = [];
        for (const name in animationToMorphTargets) {
          clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
      },
      parseAnimation: function(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
          if (animationKeys.length !== 0) {
            const times = [];
            const values = [];
            AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
            if (times.length !== 0) {
              destTracks.push(new trackType(trackName, times, values));
            }
          }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
          const animationKeys = hierarchyTracks[h2].keys;
          if (!animationKeys || animationKeys.length === 0)
            continue;
          if (animationKeys[0].morphTargets) {
            const morphTargetNames = {};
            let k;
            for (k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (let m2 = 0; m2 < animationKeys[k].morphTargets.length; m2++) {
                  morphTargetNames[animationKeys[k].morphTargets[m2]] = -1;
                }
              }
            }
            for (const morphTargetName in morphTargetNames) {
              const times = [];
              const values = [];
              for (let m2 = 0; m2 !== animationKeys[k].morphTargets.length; ++m2) {
                const animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * (fps || 1);
          } else {
            const boneName = ".bones[" + bones[h2].name + "]";
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
            addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        const clip = new AnimationClip(clipName, duration, tracks, blendMode);
        return clip;
      }
    });
    Object.assign(AnimationClip.prototype, {
      resetDuration: function() {
        const tracks = this.tracks;
        let duration = 0;
        for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
          const track = this.tracks[i2];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      },
      trim: function() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].trim(0, this.duration);
        }
        return this;
      },
      validate: function() {
        let valid = true;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          valid = valid && this.tracks[i2].validate();
        }
        return valid;
      },
      optimize: function() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].optimize();
        }
        return this;
      },
      clone: function() {
        const tracks = [];
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          tracks.push(this.tracks[i2].clone());
        }
        return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
      }
    });
    Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    DefaultLoadingManager = new LoadingManager();
    Object.assign(Loader.prototype, {
      load: function() {
      },
      loadAsync: function(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve2, reject) {
          scope.load(url, resolve2, onProgress, reject);
        });
      },
      parse: function() {
      },
      setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      },
      setPath: function(path) {
        this.path = path;
        return this;
      },
      setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      },
      setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    });
    loading = {};
    FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: FileLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading[url] !== void 0) {
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        if (dataUriRegexResult) {
          const mimeType = dataUriRegexResult[1];
          const isBase64 = !!dataUriRegexResult[2];
          let data = dataUriRegexResult[3];
          data = decodeURIComponent(data);
          if (isBase64)
            data = atob(data);
          try {
            let response;
            const responseType = (this.responseType || "").toLowerCase();
            switch (responseType) {
              case "arraybuffer":
              case "blob":
                const view = new Uint8Array(data.length);
                for (let i2 = 0; i2 < data.length; i2++) {
                  view[i2] = data.charCodeAt(i2);
                }
                if (responseType === "blob") {
                  response = new Blob([view.buffer], { type: mimeType });
                } else {
                  response = view.buffer;
                }
                break;
              case "document":
                const parser = new DOMParser();
                response = parser.parseFromString(data, mimeType);
                break;
              case "json":
                response = JSON.parse(data);
                break;
              default:
                response = data;
                break;
            }
            setTimeout(function() {
              if (onLoad)
                onLoad(response);
              scope.manager.itemEnd(url);
            }, 0);
          } catch (error2) {
            setTimeout(function() {
              if (onError)
                onError(error2);
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }, 0);
          }
        } else {
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          request = new XMLHttpRequest();
          request.open("GET", url, true);
          request.addEventListener("load", function(event) {
            const response = this.response;
            const callbacks = loading[url];
            delete loading[url];
            if (this.status === 200 || this.status === 0) {
              if (this.status === 0)
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              Cache.add(url, response);
              for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                const callback = callbacks[i2];
                if (callback.onLoad)
                  callback.onLoad(response);
              }
              scope.manager.itemEnd(url);
            } else {
              for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                const callback = callbacks[i2];
                if (callback.onError)
                  callback.onError(event);
              }
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }
          }, false);
          request.addEventListener("progress", function(event) {
            const callbacks = loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onProgress)
                callback.onProgress(event);
            }
          }, false);
          request.addEventListener("error", function(event) {
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, false);
          request.addEventListener("abort", function(event) {
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, false);
          if (this.responseType !== void 0)
            request.responseType = this.responseType;
          if (this.withCredentials !== void 0)
            request.withCredentials = this.withCredentials;
          if (request.overrideMimeType)
            request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
          for (const header in this.requestHeader) {
            request.setRequestHeader(header, this.requestHeader[header]);
          }
          request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
      },
      setResponseType: function(value) {
        this.responseType = value;
        return this;
      },
      setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
      },
      setMimeType: function(value) {
        this.mimeType = value;
        return this;
      }
    });
    AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: AnimationLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e2) {
            if (onError) {
              onError(e2);
            } else {
              console.error(e2);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      },
      parse: function(json) {
        const animations = [];
        for (let i2 = 0; i2 < json.length; i2++) {
          const clip = AnimationClip.parse(json[i2]);
          animations.push(clip);
        }
        return animations;
      }
    });
    CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: CompressedTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        texture.image = images;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        let loaded = 0;
        function loadTexture(i2) {
          loader.load(url[i2], function(buffer) {
            const texDatas = scope.parse(buffer, true);
            images[i2] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1)
                texture.minFilter = LinearFilter;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url)) {
          for (let i2 = 0, il = url.length; i2 < il; ++i2) {
            loadTexture(i2);
          }
        } else {
          loader.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (let f3 = 0; f3 < faces; f3++) {
                images[f3] = { mipmaps: [] };
                for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                  images[f3].mipmaps.push(texDatas.mipmaps[f3 * texDatas.mipmapCount + i2]);
                  images[f3].format = texDatas.format;
                  images[f3].width = texDatas.width;
                  images[f3].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    });
    DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: DataTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.load(url, function(buffer) {
          const texData = scope.parse(buffer);
          if (!texData)
            return;
          if (texData.image !== void 0) {
            texture.image = texData.image;
          } else if (texData.data !== void 0) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
          texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
          texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
          texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
          texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
          if (texData.format !== void 0) {
            texture.format = texData.format;
          }
          if (texData.type !== void 0) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== void 0) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter;
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    });
    ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ImageLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function onImageLoad() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          if (onError)
            onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.substr(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    });
    CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: CubeTextureLoader,
      load: function(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i2) {
          loader.load(urls[i2], function(image) {
            texture.images[i2] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, void 0, onError);
        }
        for (let i2 = 0; i2 < urls.length; ++i2) {
          loadTexture(i2);
        }
        return texture;
      }
    });
    TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: TextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
          texture.image = image;
          const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
          texture.format = isJPEG ? RGBFormat : RGBAFormat;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    });
    Object.assign(Curve.prototype, {
      getPoint: function() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      },
      getPointAt: function(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getPoint(t2, optionalTarget);
      },
      getPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 5;
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPoint(d / divisions));
        }
        return points;
      },
      getSpacedPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 5;
        const points = [];
        for (let d = 0; d <= divisions; d++) {
          points.push(this.getPointAt(d / divisions));
        }
        return points;
      },
      getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function(divisions) {
        if (divisions === void 0)
          divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for (let p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
      },
      getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i2 = 0, il = arcLengths.length;
        let targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        let low = 0, high = il - 1, comparison;
        while (low <= high) {
          i2 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i2] - targetArcLength;
          if (comparison < 0) {
            low = i2 + 1;
          } else if (comparison > 0) {
            high = i2 - 1;
          } else {
            high = i2;
            break;
          }
        }
        i2 = high;
        if (arcLengths[i2] === targetArcLength) {
          return i2 / (il - 1);
        }
        const lengthBefore = arcLengths[i2];
        const lengthAfter = arcLengths[i2 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t2 = (i2 + segmentFraction) / (il - 1);
        return t2;
      },
      getTangent: function(t2, optionalTarget) {
        const delta = 1e-4;
        let t1 = t2 - delta;
        let t22 = t2 + delta;
        if (t1 < 0)
          t1 = 0;
        if (t22 > 1)
          t22 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t22);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      },
      getTangentAt: function(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getTangent(t2, optionalTarget);
      },
      computeFrenetFrames: function(segments, closed) {
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        for (let i2 = 0; i2 <= segments; i2++) {
          const u = i2 / segments;
          tangents[i2] = this.getTangentAt(u, new Vector3());
          tangents[i2].normalize();
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (let i2 = 1; i2 <= segments; i2++) {
          normals[i2] = normals[i2 - 1].clone();
          binormals[i2] = binormals[i2 - 1].clone();
          vec.crossVectors(tangents[i2 - 1], tangents[i2]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            const theta = Math.acos(MathUtils.clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
            normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[i2].crossVectors(tangents[i2], normals[i2]);
        }
        if (closed === true) {
          let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
          theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            theta = -theta;
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      },
      toJSON: function() {
        const data = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      },
      fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    });
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const twoPi = Math.PI * 2;
      let deltaAngle = this.aEndAngle - this.aStartAngle;
      const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0)
        deltaAngle += twoPi;
      while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      const angle = this.aStartAngle + t2 * deltaAngle;
      let x2 = this.aX + this.xRadius * Math.cos(angle);
      let y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x2 - this.aX;
        const ty = y - this.aY;
        x2 = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
      }
      return point.set(x2, y);
    };
    EllipseCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    };
    EllipseCurve.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    };
    EllipseCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    };
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    ArcCurve.prototype.isArcCurve = true;
    tmp = new Vector3();
    px = new CubicPoly();
    py = new CubicPoly();
    pz = new CubicPoly();
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CatmullRomCurve3.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector3();
      const points = this.points;
      const l = points.length;
      const p = (l - (this.closed ? 0 : 1)) * t2;
      let intPoint = Math.floor(p);
      let weight = p - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      let p0, p1, p2, p3;
      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      p1 = points[intPoint % l];
      p2 = points[(intPoint + 1) % l];
      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }
      if (this.curveType === "centripetal" || this.curveType === "chordal") {
        const pow = this.curveType === "chordal" ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 1e-4)
          dt1 = 1;
        if (dt0 < 1e-4)
          dt0 = dt1;
        if (dt2 < 1e-4)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }
      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    };
    CatmullRomCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.points = [];
      for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
        const point = source.points[i2];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    };
    CatmullRomCurve3.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.points = [];
      for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
        const point = this.points[i2];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    };
    CatmullRomCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.points = [];
      for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
        const point = json.points[i2];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    };
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
      return point;
    };
    CubicBezierCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    };
    CubicBezierCurve.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    };
    CubicBezierCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    };
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    CubicBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector3();
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
      return point;
    };
    CubicBezierCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    };
    CubicBezierCurve3.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    };
    CubicBezierCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    };
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      if (t2 === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
      }
      return point;
    };
    LineCurve.prototype.getPointAt = function(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    };
    LineCurve.prototype.getTangent = function(t2, optionalTarget) {
      const tangent = optionalTarget || new Vector2();
      tangent.copy(this.v2).sub(this.v1).normalize();
      return tangent;
    };
    LineCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    LineCurve.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    LineCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.isLineCurve3 = true;
    LineCurve3.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector3();
      if (t2 === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
      }
      return point;
    };
    LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    };
    LineCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    LineCurve3.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    LineCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
      return point;
    };
    QuadraticBezierCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    QuadraticBezierCurve.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    QuadraticBezierCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    QuadraticBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector3();
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
      return point;
    };
    QuadraticBezierCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    QuadraticBezierCurve3.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    QuadraticBezierCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const points = this.points;
      const p = (points.length - 1) * t2;
      const intPoint = Math.floor(p);
      const weight = p - intPoint;
      const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      const p1 = points[intPoint];
      const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      return point;
    };
    SplineCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.points = [];
      for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
        const point = source.points[i2];
        this.points.push(point.clone());
      }
      return this;
    };
    SplineCurve.prototype.toJSON = function() {
      const data = Curve.prototype.toJSON.call(this);
      data.points = [];
      for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
        const point = this.points[i2];
        data.points.push(point.toArray());
      }
      return data;
    };
    SplineCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.points = [];
      for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
        const point = json.points[i2];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    };
    Curves = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      ArcCurve,
      CatmullRomCurve3,
      CubicBezierCurve,
      CubicBezierCurve3,
      EllipseCurve,
      LineCurve,
      LineCurve3,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      SplineCurve
    });
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
      constructor: CurvePath,
      add: function(curve) {
        this.curves.push(curve);
      },
      closePath: function() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          this.curves.push(new LineCurve(endPoint, startPoint));
        }
      },
      getPoint: function(t2) {
        const d = t2 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i2 = 0;
        while (i2 < curveLengths.length) {
          if (curveLengths[i2] >= d) {
            const diff = curveLengths[i2] - d;
            const curve = this.curves[i2];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u);
          }
          i2++;
        }
        return null;
      },
      getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      },
      getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        const lengths = [];
        let sums = 0;
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          sums += this.curves[i2].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      },
      getSpacedPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 40;
        const points = [];
        for (let i2 = 0; i2 <= divisions; i2++) {
          points.push(this.getPoint(i2 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      },
      getPoints: function(divisions) {
        divisions = divisions || 12;
        const points = [];
        let last;
        for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
          const curve = curves[i2];
          const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
          const pts = curve.getPoints(resolution);
          for (let j = 0; j < pts.length; j++) {
            const point = pts[j];
            if (last && last.equals(point))
              continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      },
      copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
          const curve = source.curves[i2];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      },
      toJSON: function() {
        const data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          const curve = this.curves[i2];
          data.curves.push(curve.toJSON());
        }
        return data;
      },
      fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
          const curve = json.curves[i2];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    });
    Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
      constructor: Path,
      setFromPoints: function(points) {
        this.moveTo(points[0].x, points[0].y);
        for (let i2 = 1, l = points.length; i2 < l; i2++) {
          this.lineTo(points[i2].x, points[i2].y);
        }
        return this;
      },
      moveTo: function(x2, y) {
        this.currentPoint.set(x2, y);
        return this;
      },
      lineTo: function(x2, y) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y));
        this.curves.push(curve);
        this.currentPoint.set(x2, y);
        return this;
      },
      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      },
      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      },
      splineThru: function(pts) {
        const npts = [this.currentPoint.clone()].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      },
      arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      },
      absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      },
      ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      },
      absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          const firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      },
      copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      },
      toJSON: function() {
        const data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
      },
      fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    });
    Shape.prototype = Object.assign(Object.create(Path.prototype), {
      constructor: Shape,
      getPointsHoles: function(divisions) {
        const holesPts = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          holesPts[i2] = this.holes[i2].getPoints(divisions);
        }
        return holesPts;
      },
      extractPoints: function(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      },
      copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
          const hole = source.holes[i2];
          this.holes.push(hole.clone());
        }
        return this;
      },
      toJSON: function() {
        const data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          const hole = this.holes[i2];
          data.holes.push(hole.toJSON());
        }
        return data;
      },
      fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
          const hole = json.holes[i2];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    });
    Light$1.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Light$1,
      isLight: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      },
      toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      }
    });
    HemisphereLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: HemisphereLight,
      isHemisphereLight: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    });
    Object.assign(LightShadow.prototype, {
      _projScreenMatrix: new Matrix4(),
      _lightPositionWorld: new Vector3(),
      _lookTarget: new Vector3(),
      getViewportCount: function() {
        return this._viewportCount;
      },
      getFrustum: function() {
        return this._frustum;
      },
      updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      },
      getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
      },
      getFrameExtents: function() {
        return this._frameExtents;
      },
      copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      toJSON: function() {
        const object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.normalBias !== 0)
          object.normalBias = this.normalBias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    });
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: SpotLightShadow,
      isSpotLightShadow: true,
      updateMatrices: function(light) {
        const camera = this.camera;
        const fov2 = MathUtils.RAD2DEG * 2 * light.angle;
        const aspect2 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
          camera.fov = fov2;
          camera.aspect = aspect2;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        LightShadow.prototype.updateMatrices.call(this, light);
      }
    });
    SpotLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: SpotLight,
      isSpotLight: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: PointLightShadow,
      isPointLightShadow: true,
      updateMatrices: function(light, viewportIndex) {
        if (viewportIndex === void 0)
          viewportIndex = 0;
        const camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
      }
    });
    PointLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: PointLight,
      isPointLight: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    OrthographicCamera.prototype = Object.assign(Object.create(Camera$1.prototype), {
      constructor: OrthographicCamera,
      isOrthographicCamera: true,
      copy: function(source, recursive) {
        Camera$1.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      },
      setViewOffset: function(fullWidth, fullHeight, x2, y, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x2;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      },
      clearViewOffset: function() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      }
    });
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: DirectionalLightShadow,
      isDirectionalLightShadow: true,
      updateMatrices: function(light) {
        LightShadow.prototype.updateMatrices.call(this, light);
      }
    });
    DirectionalLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: DirectionalLight,
      isDirectionalLight: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    AmbientLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: AmbientLight,
      isAmbientLight: true
    });
    RectAreaLight.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: RectAreaLight,
      isRectAreaLight: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
      },
      toJSON: function(meta) {
        const data = Light$1.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    });
    Object.assign(SphericalHarmonics3.prototype, {
      isSphericalHarmonics3: true,
      set: function(coefficients) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].copy(coefficients[i2]);
        }
        return this;
      },
      zero: function() {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].set(0, 0, 0);
        }
        return this;
      },
      getAt: function(normal, target) {
        const x2 = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x2);
        target.addScaledVector(coeff[4], 1.092548 * (x2 * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x2 * z));
        target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y * y));
        return target;
      },
      getIrradianceAt: function(normal, target) {
        const x2 = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 2 * 0.511664 * y);
        target.addScaledVector(coeff[2], 2 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
        target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y);
        target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z);
        target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y * y));
        return target;
      },
      add: function(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].add(sh.coefficients[i2]);
        }
        return this;
      },
      addScaledSH: function(sh, s3) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].addScaledVector(sh.coefficients[i2], s3);
        }
        return this;
      },
      scale: function(s3) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].multiplyScalar(s3);
        }
        return this;
      },
      lerp: function(sh, alpha) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
        }
        return this;
      },
      equals: function(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
            return false;
          }
        }
        return true;
      },
      copy: function(sh) {
        return this.set(sh.coefficients);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].fromArray(array, offset + i2 * 3);
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].toArray(array, offset + i2 * 3);
        }
        return array;
      }
    });
    Object.assign(SphericalHarmonics3, {
      getBasisAt: function(normal, shBasis) {
        const x2 = normal.x, y = normal.y, z = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x2;
        shBasis[4] = 1.092548 * x2 * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x2 * z;
        shBasis[8] = 0.546274 * (x2 * x2 - y * y);
      }
    });
    LightProbe.prototype = Object.assign(Object.create(Light$1.prototype), {
      constructor: LightProbe,
      isLightProbe: true,
      copy: function(source) {
        Light$1.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
      },
      fromJSON: function(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
      },
      toJSON: function(meta) {
        const data = Light$1.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
      }
    });
    MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: MaterialLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e2) {
            if (onError) {
              onError(e2);
            } else {
              console.error(e2);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      },
      parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
          if (textures[name] === void 0) {
            console.warn("THREE.MaterialLoader: Undefined texture", name);
          }
          return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== void 0)
          material.uuid = json.uuid;
        if (json.name !== void 0)
          material.name = json.name;
        if (json.color !== void 0)
          material.color.setHex(json.color);
        if (json.roughness !== void 0)
          material.roughness = json.roughness;
        if (json.metalness !== void 0)
          material.metalness = json.metalness;
        if (json.sheen !== void 0)
          material.sheen = new Color().setHex(json.sheen);
        if (json.emissive !== void 0)
          material.emissive.setHex(json.emissive);
        if (json.specular !== void 0)
          material.specular.setHex(json.specular);
        if (json.shininess !== void 0)
          material.shininess = json.shininess;
        if (json.clearcoat !== void 0)
          material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== void 0)
          material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== void 0)
          material.fog = json.fog;
        if (json.flatShading !== void 0)
          material.flatShading = json.flatShading;
        if (json.blending !== void 0)
          material.blending = json.blending;
        if (json.combine !== void 0)
          material.combine = json.combine;
        if (json.side !== void 0)
          material.side = json.side;
        if (json.opacity !== void 0)
          material.opacity = json.opacity;
        if (json.transparent !== void 0)
          material.transparent = json.transparent;
        if (json.alphaTest !== void 0)
          material.alphaTest = json.alphaTest;
        if (json.depthTest !== void 0)
          material.depthTest = json.depthTest;
        if (json.depthWrite !== void 0)
          material.depthWrite = json.depthWrite;
        if (json.colorWrite !== void 0)
          material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== void 0)
          material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== void 0)
          material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== void 0)
          material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== void 0)
          material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== void 0)
          material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== void 0)
          material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== void 0)
          material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== void 0)
          material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== void 0)
          material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== void 0)
          material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== void 0)
          material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== void 0)
          material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== void 0)
          material.rotation = json.rotation;
        if (json.linewidth !== 1)
          material.linewidth = json.linewidth;
        if (json.dashSize !== void 0)
          material.dashSize = json.dashSize;
        if (json.gapSize !== void 0)
          material.gapSize = json.gapSize;
        if (json.scale !== void 0)
          material.scale = json.scale;
        if (json.polygonOffset !== void 0)
          material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== void 0)
          material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== void 0)
          material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== void 0)
          material.skinning = json.skinning;
        if (json.morphTargets !== void 0)
          material.morphTargets = json.morphTargets;
        if (json.morphNormals !== void 0)
          material.morphNormals = json.morphNormals;
        if (json.dithering !== void 0)
          material.dithering = json.dithering;
        if (json.vertexTangents !== void 0)
          material.vertexTangents = json.vertexTangents;
        if (json.visible !== void 0)
          material.visible = json.visible;
        if (json.toneMapped !== void 0)
          material.toneMapped = json.toneMapped;
        if (json.userData !== void 0)
          material.userData = json.userData;
        if (json.vertexColors !== void 0) {
          if (typeof json.vertexColors === "number") {
            material.vertexColors = json.vertexColors > 0 ? true : false;
          } else {
            material.vertexColors = json.vertexColors;
          }
        }
        if (json.uniforms !== void 0) {
          for (const name in json.uniforms) {
            const uniform = json.uniforms[name];
            material.uniforms[name] = {};
            switch (uniform.type) {
              case "t":
                material.uniforms[name].value = getTexture(uniform.value);
                break;
              case "c":
                material.uniforms[name].value = new Color().setHex(uniform.value);
                break;
              case "v2":
                material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                break;
              case "v3":
                material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                break;
              case "v4":
                material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                break;
              case "m3":
                material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              case "m4":
                material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                break;
              default:
                material.uniforms[name].value = uniform.value;
            }
          }
        }
        if (json.defines !== void 0)
          material.defines = json.defines;
        if (json.vertexShader !== void 0)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== void 0)
          material.fragmentShader = json.fragmentShader;
        if (json.extensions !== void 0) {
          for (const key in json.extensions) {
            material.extensions[key] = json.extensions[key];
          }
        }
        if (json.shading !== void 0)
          material.flatShading = json.shading === 1;
        if (json.size !== void 0)
          material.size = json.size;
        if (json.sizeAttenuation !== void 0)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== void 0)
          material.map = getTexture(json.map);
        if (json.matcap !== void 0)
          material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== void 0)
          material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== void 0)
          material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== void 0)
          material.bumpScale = json.bumpScale;
        if (json.normalMap !== void 0)
          material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== void 0)
          material.normalMapType = json.normalMapType;
        if (json.normalScale !== void 0) {
          let normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            normalScale = [normalScale, normalScale];
          }
          material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== void 0)
          material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== void 0)
          material.displacementScale = json.displacementScale;
        if (json.displacementBias !== void 0)
          material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== void 0)
          material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== void 0)
          material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== void 0)
          material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== void 0)
          material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== void 0)
          material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== void 0)
          material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== void 0)
          material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== void 0)
          material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== void 0)
          material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== void 0)
          material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== void 0)
          material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== void 0)
          material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== void 0)
          material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== void 0)
          material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== void 0)
          material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== void 0)
          material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== void 0)
          material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== void 0)
          material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.transmission !== void 0)
          material.transmission = json.transmission;
        if (json.transmissionMap !== void 0)
          material.transmissionMap = getTexture(json.transmissionMap);
        return material;
      },
      setTextures: function(value) {
        this.textures = value;
        return this;
      }
    });
    LoaderUtils = {
      decodeText: function(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        let s3 = "";
        for (let i2 = 0, il = array.length; i2 < il; i2++) {
          s3 += String.fromCharCode(array[i2]);
        }
        try {
          return decodeURIComponent(escape(s3));
        } catch (e2) {
          return s3;
        }
      },
      extractUrlBase: function(url) {
        const index = url.lastIndexOf("/");
        if (index === -1)
          return "./";
        return url.substr(0, index + 1);
      }
    };
    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
      constructor: InstancedBufferGeometry,
      isInstancedBufferGeometry: true,
      copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      toJSON: function() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    });
    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
      constructor: InstancedBufferAttribute,
      isInstancedBufferAttribute: true,
      copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      },
      toJSON: function() {
        const data = BufferAttribute.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    });
    BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: BufferGeometryLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e2) {
            if (onError) {
              onError(e2);
            } else {
              console.error(e2);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      },
      parse: function(json) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json2, uuid) {
          if (interleavedBufferMap[uuid] !== void 0)
            return interleavedBufferMap[uuid];
          const interleavedBuffers = json2.interleavedBuffers;
          const interleavedBuffer = interleavedBuffers[uuid];
          const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
          const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
          const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
          ib.uuid = interleavedBuffer.uuid;
          interleavedBufferMap[uuid] = ib;
          return ib;
        }
        function getArrayBuffer(json2, uuid) {
          if (arrayBufferMap[uuid] !== void 0)
            return arrayBufferMap[uuid];
          const arrayBuffers = json2.arrayBuffers;
          const arrayBuffer = arrayBuffers[uuid];
          const ab = new Uint32Array(arrayBuffer).buffer;
          arrayBufferMap[uuid] = ab;
          return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json.data.index;
        if (index !== void 0) {
          const typedArray = new TYPED_ARRAYS[index.type](index.array);
          geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
            bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (const key in morphAttributes) {
            const attributeArray = morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              let bufferAttribute;
              if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
              } else {
                const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
              }
              if (attribute.name !== void 0)
                bufferAttribute.name = attribute.name;
              array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
          }
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== void 0) {
          for (let i2 = 0, n = groups.length; i2 !== n; ++i2) {
            const group = groups[i2];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== void 0) {
          const center = new Vector3();
          if (boundingSphere.center !== void 0) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name)
          geometry.name = json.name;
        if (json.userData)
          geometry.userData = json.userData;
        return geometry;
      }
    });
    TYPED_ARRAYS = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    };
    ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ObjectLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.load(url, function(text) {
          let json = null;
          try {
            json = JSON.parse(text);
          } catch (error2) {
            if (onError !== void 0)
              onError(error2);
            console.error("THREE:ObjectLoader: Can't parse " + url + ".", error2.message);
            return;
          }
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            console.error("THREE.ObjectLoader: Can't load " + url);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      },
      parse: function(json, onLoad) {
        const shapes = this.parseShape(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
          if (onLoad !== void 0)
            onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
          object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === void 0 || json.images.length === 0) {
          if (onLoad !== void 0)
            onLoad(object);
        }
        return object;
      },
      parseShape: function(json) {
        const shapes = {};
        if (json !== void 0) {
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const shape = new Shape().fromJSON(json[i2]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      },
      parseGeometries: function(json, shapes) {
        const geometries = {};
        let geometryShapes;
        if (json !== void 0) {
          const bufferGeometryLoader = new BufferGeometryLoader();
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            let geometry;
            const data = json[i2];
            switch (data.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                geometryShapes = [];
                for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                  const shape = shapes[data.shapes[j]];
                  geometryShapes.push(shape);
                }
                geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                geometryShapes = [];
                for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                  const shape = shapes[data.shapes[j]];
                  geometryShapes.push(shape);
                }
                const extrudePath = data.options.extrudePath;
                if (extrudePath !== void 0) {
                  data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                }
                geometry = new Geometries[data.type](geometryShapes, data.options);
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                geometry = bufferGeometryLoader.parse(data);
                break;
              case "Geometry":
                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                continue;
            }
            geometry.uuid = data.uuid;
            if (data.name !== void 0)
              geometry.name = data.name;
            if (geometry.isBufferGeometry === true && data.userData !== void 0)
              geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        const cache = {};
        const materials = {};
        if (json !== void 0) {
          const loader = new MaterialLoader();
          loader.setTextures(textures);
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const data = json[i2];
            if (data.type === "MultiMaterial") {
              const array = [];
              for (let j = 0; j < data.materials.length; j++) {
                const material = data.materials[j];
                if (cache[material.uuid] === void 0) {
                  cache[material.uuid] = loader.parse(material);
                }
                array.push(cache[material.uuid]);
              }
              materials[data.uuid] = array;
            } else {
              if (cache[data.uuid] === void 0) {
                cache[data.uuid] = loader.parse(data);
              }
              materials[data.uuid] = cache[data.uuid];
            }
          }
        }
        return materials;
      },
      parseAnimations: function(json) {
        const animations = [];
        for (let i2 = 0; i2 < json.length; i2++) {
          const data = json[i2];
          const clip = AnimationClip.parse(data);
          if (data.uuid !== void 0)
            clip.uuid = data.uuid;
          animations.push(clip);
        }
        return animations;
      },
      parseImages: function(json, onLoad) {
        const scope = this;
        const images = {};
        let loader;
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader.load(url, function() {
            scope.manager.itemEnd(url);
          }, void 0, function() {
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
        }
        if (json !== void 0 && json.length > 0) {
          const manager = new LoadingManager(onLoad);
          loader = new ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (let i2 = 0, il = json.length; i2 < il; i2++) {
            const image = json[i2];
            const url = image.url;
            if (Array.isArray(url)) {
              images[image.uuid] = [];
              for (let j = 0, jl = url.length; j < jl; j++) {
                const currentUrl = url[j];
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
                images[image.uuid].push(loadImage(path));
              }
            } else {
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
              images[image.uuid] = loadImage(path);
            }
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        function parseConstant(value, type) {
          if (typeof value === "number")
            return value;
          console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
          return type[value];
        }
        const textures = {};
        if (json !== void 0) {
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const data = json[i2];
            if (data.image === void 0) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined image", data.image);
            }
            let texture;
            if (Array.isArray(images[data.image])) {
              texture = new CubeTexture(images[data.image]);
            } else {
              texture = new Texture(images[data.image]);
            }
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== void 0)
              texture.name = data.name;
            if (data.mapping !== void 0)
              texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== void 0)
              texture.offset.fromArray(data.offset);
            if (data.repeat !== void 0)
              texture.repeat.fromArray(data.repeat);
            if (data.center !== void 0)
              texture.center.fromArray(data.center);
            if (data.rotation !== void 0)
              texture.rotation = data.rotation;
            if (data.wrap !== void 0) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== void 0)
              texture.format = data.format;
            if (data.type !== void 0)
              texture.type = data.type;
            if (data.encoding !== void 0)
              texture.encoding = data.encoding;
            if (data.minFilter !== void 0)
              texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== void 0)
              texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== void 0)
              texture.anisotropy = data.anisotropy;
            if (data.flipY !== void 0)
              texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== void 0)
              texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== void 0)
              texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function(data, geometries, materials) {
        let object;
        function getGeometry(name) {
          if (geometries[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined geometry", name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === void 0)
            return void 0;
          if (Array.isArray(name)) {
            const array = [];
            for (let i2 = 0, l = name.length; i2 < l; i2++) {
              const uuid = name[i2];
              if (materials[uuid] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined material", uuid);
              }
              array.push(materials[uuid]);
            }
            return array;
          }
          if (materials[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", name);
          }
          return materials[name];
        }
        let geometry, material;
        switch (data.type) {
          case "Scene":
            object = new Scene();
            if (data.background !== void 0) {
              if (Number.isInteger(data.background)) {
                object.background = new Color(data.background);
              }
            }
            if (data.fog !== void 0) {
              if (data.fog.type === "Fog") {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === "FogExp2") {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
              }
            }
            break;
          case "PerspectiveCamera":
            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== void 0)
              object.focus = data.focus;
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.filmGauge !== void 0)
              object.filmGauge = data.filmGauge;
            if (data.filmOffset !== void 0)
              object.filmOffset = data.filmOffset;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "OrthographicCamera":
            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "AmbientLight":
            object = new AmbientLight(data.color, data.intensity);
            break;
          case "DirectionalLight":
            object = new DirectionalLight(data.color, data.intensity);
            break;
          case "PointLight":
            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case "RectAreaLight":
            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
            break;
          case "SpotLight":
            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            break;
          case "HemisphereLight":
            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case "LightProbe":
            object = new LightProbe().fromJSON(data);
            break;
          case "SkinnedMesh":
            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
          case "Mesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new Mesh(geometry, material);
            break;
          case "InstancedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            const count = data.count;
            const instanceMatrix = data.instanceMatrix;
            object = new InstancedMesh(geometry, material, count);
            object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
            break;
          case "LOD":
            object = new LOD();
            break;
          case "Line":
            object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
            break;
          case "LineLoop":
            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineSegments":
            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "PointCloud":
          case "Points":
            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "Sprite":
            object = new Sprite(getMaterial(data.material));
            break;
          case "Group":
            object = new Group();
            break;
          default:
            object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== void 0)
          object.name = data.name;
        if (data.matrix !== void 0) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== void 0)
            object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate)
            object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== void 0)
            object.position.fromArray(data.position);
          if (data.rotation !== void 0)
            object.rotation.fromArray(data.rotation);
          if (data.quaternion !== void 0)
            object.quaternion.fromArray(data.quaternion);
          if (data.scale !== void 0)
            object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== void 0)
          object.castShadow = data.castShadow;
        if (data.receiveShadow !== void 0)
          object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.bias !== void 0)
            object.shadow.bias = data.shadow.bias;
          if (data.shadow.normalBias !== void 0)
            object.shadow.normalBias = data.shadow.normalBias;
          if (data.shadow.radius !== void 0)
            object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== void 0)
            object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== void 0)
            object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== void 0)
          object.visible = data.visible;
        if (data.frustumCulled !== void 0)
          object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== void 0)
          object.renderOrder = data.renderOrder;
        if (data.userData !== void 0)
          object.userData = data.userData;
        if (data.layers !== void 0)
          object.layers.mask = data.layers;
        if (data.children !== void 0) {
          const children = data.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            object.add(this.parseObject(children[i2], geometries, materials));
          }
        }
        if (data.type === "LOD") {
          if (data.autoUpdate !== void 0)
            object.autoUpdate = data.autoUpdate;
          const levels = data.levels;
          for (let l = 0; l < levels.length; l++) {
            const level = levels[l];
            const child = object.getObjectByProperty("uuid", level.object);
            if (child !== void 0) {
              object.addLevel(child, level.distance);
            }
          }
        }
        return object;
      }
    });
    TEXTURE_MAPPING = {
      UVMapping,
      CubeReflectionMapping,
      CubeRefractionMapping,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      CubeUVReflectionMapping,
      CubeUVRefractionMapping
    };
    TEXTURE_WRAPPING = {
      RepeatWrapping,
      ClampToEdgeWrapping,
      MirroredRepeatWrapping
    };
    TEXTURE_FILTER = {
      NearestFilter,
      NearestMipmapNearestFilter,
      NearestMipmapLinearFilter,
      LinearFilter,
      LinearMipmapNearestFilter,
      LinearMipmapLinearFilter
    };
    ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ImageBitmapLoader,
      isImageBitmapLoader: true,
      setOptions: function setOptions(options2) {
        this.options = options2;
        return this;
      },
      load: function(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        fetch(url).then(function(res) {
          return res.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, scope.options);
        }).then(function(imageBitmap) {
          Cache.add(url, imageBitmap);
          if (onLoad)
            onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch(function(e2) {
          if (onError)
            onError(e2);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
      }
    });
    Object.assign(ShapePath.prototype, {
      moveTo: function(x2, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x2, y);
        return this;
      },
      lineTo: function(x2, y) {
        this.currentPath.lineTo(x2, y);
        return this;
      },
      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      },
      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      },
      splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
      },
      toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
          const shapes2 = [];
          for (let i2 = 0, l = inSubpaths.length; i2 < l; i2++) {
            const tmpPath2 = inSubpaths[i2];
            const tmpShape2 = new Shape();
            tmpShape2.curves = tmpPath2.curves;
            shapes2.push(tmpShape2);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          const polyLen = inPolygon.length;
          let inside = false;
          for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            let edgeLowPt = inPolygon[p];
            let edgeHighPt = inPolygon[q];
            let edgeDx = edgeHighPt.x - edgeLowPt.x;
            let edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                  return true;
              } else {
                const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                  return true;
                if (perpEdge < 0)
                  continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y)
                continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
            }
          }
          return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0)
          return [];
        if (noHoles === true)
          return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape, shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (let i2 = 0, l = subPaths.length; i2 < l; i2++) {
          tmpPath = subPaths[i2];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx])
              mainIdx++;
            newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst)
              mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
          }
        }
        if (!newShapes[0])
          return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          let ambiguous = false;
          const toChange = [];
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            const sho = newShapeHoles[sIdx];
            for (let hIdx = 0; hIdx < sho.length; hIdx++) {
              const ho = sho[hIdx];
              let hole_unassigned = true;
              for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (sIdx !== s2Idx)
                    toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
              }
            }
          }
          if (toChange.length > 0) {
            if (!ambiguous)
              newShapeHoles = betterShapeHoles;
          }
        }
        let tmpHoles;
        for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
          tmpShape = newShapes[i2].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[i2];
          for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }
        return shapes;
      }
    });
    Object.assign(Font.prototype, {
      isFont: true,
      generateShapes: function(text, size) {
        if (size === void 0)
          size = 100;
        const shapes = [];
        const paths = createPaths(text, size, this.data);
        for (let p = 0, pl = paths.length; p < pl; p++) {
          Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
      }
    });
    FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: FontLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.load(url, function(text) {
          let json;
          try {
            json = JSON.parse(text);
          } catch (e2) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
            json = JSON.parse(text.substring(65, text.length - 2));
          }
          const font = scope.parse(json);
          if (onLoad)
            onLoad(font);
        }, onProgress, onError);
      },
      parse: function(json) {
        return new Font(json);
      }
    });
    AudioContext = {
      getContext: function() {
        if (_context === void 0) {
          _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
      },
      setContext: function(value) {
        _context = value;
      }
    };
    AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: AudioLoader,
      load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.load(url, function(buffer) {
          try {
            const bufferCopy = buffer.slice(0);
            const context = AudioContext.getContext();
            context.decodeAudioData(bufferCopy, function(audioBuffer) {
              onLoad(audioBuffer);
            });
          } catch (e2) {
            if (onError) {
              onError(e2);
            } else {
              console.error(e2);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    });
    HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
      constructor: HemisphereLightProbe,
      isHemisphereLightProbe: true,
      copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
      },
      toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
      }
    });
    AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
      constructor: AmbientLightProbe,
      isAmbientLightProbe: true,
      copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
      },
      toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
      }
    });
    _eyeRight = new Matrix4();
    _eyeLeft = new Matrix4();
    Object.assign(StereoCamera.prototype, {
      update: function(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera.focus;
          cache.fov = camera.fov;
          cache.aspect = camera.aspect * this.aspect;
          cache.near = camera.near;
          cache.far = camera.far;
          cache.zoom = camera.zoom;
          cache.eyeSep = this.eyeSep;
          const projectionMatrix = camera.projectionMatrix.clone();
          const eyeSepHalf = cache.eyeSep / 2;
          const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
          let xmin, xmax;
          _eyeLeft.elements[12] = -eyeSepHalf;
          _eyeRight.elements[12] = eyeSepHalf;
          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(projectionMatrix);
          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
      }
    });
    Object.assign(Clock.prototype, {
      start: function() {
        this.startTime = (typeof performance === "undefined" ? Date : performance).now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        let diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          const newTime = (typeof performance === "undefined" ? Date : performance).now();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    });
    _position$1 = new Vector3();
    _quaternion$1 = new Quaternion();
    _scale$1 = new Vector3();
    _orientation$1 = new Vector3();
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: AudioListener,
      getInput: function() {
        return this.gain;
      },
      removeFilter: function() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      },
      getFilter: function() {
        return this.filter;
      },
      setFilter: function(value) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      },
      getMasterVolume: function() {
        return this.gain.gain.value;
      },
      setMasterVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
        if (listener.positionX) {
          const endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
          listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
        }
      }
    });
    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Audio,
      getOutput: function() {
        return this.gain;
      },
      setNodeSource: function(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      },
      setMediaElementSource: function(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      },
      setMediaStreamSource: function(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      },
      setBuffer: function(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay)
          this.play();
        return this;
      },
      play: function(delay) {
        if (delay === void 0)
          delay = 0;
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      },
      pause: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      },
      stop: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
      },
      connect: function() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].connect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        return this;
      },
      disconnect: function() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].disconnect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        return this;
      },
      getFilters: function() {
        return this.filters;
      },
      setFilters: function(value) {
        if (!value)
          value = [];
        if (this.isPlaying === true) {
          this.disconnect();
          this.filters = value;
          this.connect();
        } else {
          this.filters = value;
        }
        return this;
      },
      setDetune: function(value) {
        this.detune = value;
        if (this.source.detune === void 0)
          return;
        if (this.isPlaying === true) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      },
      getDetune: function() {
        return this.detune;
      },
      getFilter: function() {
        return this.getFilters()[0];
      },
      setFilter: function(filter) {
        return this.setFilters(filter ? [filter] : []);
      },
      setPlaybackRate: function(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      },
      getPlaybackRate: function() {
        return this.playbackRate;
      },
      onEnded: function() {
        this.isPlaying = false;
      },
      getLoop: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      },
      setLoop: function(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      },
      setLoopStart: function(value) {
        this.loopStart = value;
        return this;
      },
      setLoopEnd: function(value) {
        this.loopEnd = value;
        return this;
      },
      getVolume: function() {
        return this.gain.gain.value;
      },
      setVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    });
    _position = new Vector3();
    _quaternion = new Quaternion();
    _scale = new Vector3();
    _orientation = new Vector3();
    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
      constructor: PositionalAudio,
      getOutput: function() {
        return this.panner;
      },
      getRefDistance: function() {
        return this.panner.refDistance;
      },
      setRefDistance: function(value) {
        this.panner.refDistance = value;
        return this;
      },
      getRolloffFactor: function() {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function(value) {
        this.panner.rolloffFactor = value;
        return this;
      },
      getDistanceModel: function() {
        return this.panner.distanceModel;
      },
      setDistanceModel: function(value) {
        this.panner.distanceModel = value;
        return this;
      },
      getMaxDistance: function() {
        return this.panner.maxDistance;
      },
      setMaxDistance: function(value) {
        this.panner.maxDistance = value;
        return this;
      },
      setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        if (this.hasPlaybackControl === true && this.isPlaying === false)
          return;
        this.matrixWorld.decompose(_position, _quaternion, _scale);
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
          const endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
        } else {
          panner.setPosition(_position.x, _position.y, _position.z);
          panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
        }
      }
    });
    Object.assign(AudioAnalyser.prototype, {
      getFrequencyData: function() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      },
      getAverageFrequency: function() {
        let value = 0;
        const data = this.getFrequencyData();
        for (let i2 = 0; i2 < data.length; i2++) {
          value += data[i2];
        }
        return value / data.length;
      }
    });
    Object.assign(PropertyMixer.prototype, {
      accumulate: function(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[offset + i2] = buffer[i2];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          const mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      },
      accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      },
      apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          const originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
          this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
          if (buffer[i2] !== buffer[i2 + stride]) {
            binding.setValue(buffer, offset);
            break;
          }
        }
      },
      saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
          buffer[i2] = buffer[originalValueOffset + i2 % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      },
      restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      },
      _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          this.buffer[i2] = 0;
        }
      },
      _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * 4 + 3] = 1;
      },
      _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for (let i2 = 0; i2 < this.valueSize; i2++) {
          this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
        }
      },
      _select: function(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[dstOffset + i2] = buffer[srcOffset + i2];
          }
        }
      },
      _slerp: function(buffer, dstOffset, srcOffset, t2) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
      },
      _slerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
      },
      _lerp: function(buffer, dstOffset, srcOffset, t2, stride) {
        const s3 = 1 - t2;
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] * s3 + buffer[srcOffset + i2] * t2;
        }
      },
      _lerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] + buffer[srcOffset + i2] * t2;
        }
      }
    });
    _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
    _supportedObjectNames = ["material", "materials", "bones"];
    Object.assign(Composite.prototype, {
      getValue: function(array, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array, offset);
      },
      setValue: function(array, offset) {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].setValue(array, offset);
        }
      },
      bind: function() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].bind();
        }
      },
      unbind: function() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].unbind();
        }
      }
    });
    Object.assign(PropertyBinding, {
      Composite,
      create: function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      },
      sanitizeNodeName: function(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      },
      parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          const objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      },
      findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          const bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          const searchNodeSubtree = function(children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const childNode = children[i2];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              const result = searchNodeSubtree(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          const subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
    });
    Object.assign(PropertyBinding.prototype, {
      _getValue_unavailable: function() {
      },
      _setValue_unavailable: function() {
      },
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      },
      Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      },
      GetterByBindingType: [
        function getValue_direct(buffer, offset) {
          buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
            buffer[offset++] = source[i2];
          }
        },
        function getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function setValue_direct(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
          },
          function setValue_direct_setNeedsUpdate(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
            this.targetObject.needsUpdate = true;
          },
          function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
          }
        ],
        [
          function setValue_array(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
              dest[i2] = buffer[offset++];
            }
          },
          function setValue_array_setNeedsUpdate(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
              dest[i2] = buffer[offset++];
            }
            this.targetObject.needsUpdate = true;
          },
          function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
              dest[i2] = buffer[offset++];
            }
            this.targetObject.matrixWorldNeedsUpdate = true;
          }
        ],
        [
          function setValue_arrayElement(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
          },
          function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.needsUpdate = true;
          },
          function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
          }
        ],
        [
          function setValue_fromArray(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
          },
          function setValue_fromArray_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.needsUpdate = true;
          },
          function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.matrixWorldNeedsUpdate = true;
          }
        ]
      ],
      getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      },
      setValue: function getValue_unbound2(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      },
      bind: function() {
        let targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          let objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (let i2 = 0; i2 < targetObject.length; i2++) {
                if (targetObject[i2].name === objectIndex) {
                  objectIndex = i2;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          const nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (targetObject.geometry.isBufferGeometry) {
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            } else {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              return;
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      },
      unbind: function() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    });
    Object.assign(PropertyBinding.prototype, {
      _getValue_unbound: PropertyBinding.prototype.getValue,
      _setValue_unbound: PropertyBinding.prototype.setValue
    });
    Object.assign(AnimationObjectGroup.prototype, {
      isAnimationObjectGroup: true,
      add: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid;
          let index = indicesByUUID[uuid];
          if (index === void 0) {
            index = nObjects++;
            indicesByUUID[uuid] = index;
            objects.push(object);
            for (let j = 0, m2 = nBindings; j !== m2; ++j) {
              bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            }
          } else if (index < nCachedObjects) {
            knownObject = objects[index];
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (let j = 0, m2 = nBindings; j !== m2; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
              let binding = bindingsForPath[index];
              bindingsForPath[index] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      remove: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0 && index >= nCachedObjects) {
            const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index;
            objects[index] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (let j = 0, m2 = nBindings; j !== m2; ++j) {
              const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
              bindingsForPath[index] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      uncache: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0) {
            delete indicesByUUID[uuid];
            if (index < nCachedObjects) {
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              const lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastObject.uuid] = index;
              objects[index] = lastObject;
              objects.pop();
              for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                const bindingsForPath = bindings[j];
                bindingsForPath[index] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      subscribe_: function(path, parsedPath) {
        let indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
        if (index !== void 0)
          return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
          const object = objects[i2];
          bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      },
      unsubscribe_: function(path) {
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== void 0) {
          const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index;
          bindings[index] = lastBindings;
          bindings.pop();
          parsedPaths[index] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    });
    Object.assign(AnimationAction.prototype, {
      play: function() {
        this._mixer._activateAction(this);
        return this;
      },
      stop: function() {
        this._mixer._deactivateAction(this);
        return this.reset();
      },
      reset: function() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      },
      isRunning: function() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      },
      isScheduled: function() {
        return this._mixer._isActiveAction(this);
      },
      startAt: function(time) {
        this._startTime = time;
        return this;
      },
      setLoop: function(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      },
      setEffectiveWeight: function(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      },
      getEffectiveWeight: function() {
        return this._effectiveWeight;
      },
      fadeIn: function(duration) {
        return this._scheduleFading(duration, 0, 1);
      },
      fadeOut: function(duration) {
        return this._scheduleFading(duration, 1, 0);
      },
      crossFadeFrom: function(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      },
      crossFadeTo: function(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      },
      stopFading: function() {
        let weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      },
      setEffectiveTimeScale: function(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      },
      getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
      },
      setDuration: function(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      },
      syncWith: function(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      },
      halt: function(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      },
      warp: function(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      },
      stopWarping: function() {
        let timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      },
      getMixer: function() {
        return this._mixer;
      },
      getClip: function() {
        return this._clip;
      },
      getRoot: function() {
        return this._localRoot || this._mixer._root;
      },
      _update: function(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time);
          return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
          const timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            return;
          }
          this._startTime = null;
          deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        const weight = this._updateWeight(time);
        if (weight > 0) {
          const interpolants = this._interpolants;
          const propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
              for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode:
            default:
              for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
              }
          }
        }
      },
      _updateWeight: function(time) {
        let weight = 0;
        if (this.enabled) {
          weight = this.weight;
          const interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      },
      _updateTimeScale: function(time) {
        let timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          const interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      },
      _updateTime: function(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
          if (loopCount === -1)
            return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            const loopDelta = Math.floor(time / duration);
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            const pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                const atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time;
          }
        }
        return time;
      },
      _setEndings: function(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      },
      _scheduleFading: function(duration, weightNow, weightThen) {
        const mixer = this._mixer, now = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
      }
    });
    AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: AnimationMixer,
      _bindAction: function(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const track = tracks[i2], trackName = track.name;
          let binding = bindingsByName[trackName];
          if (binding !== void 0) {
            bindings[i2] = binding;
          } else {
            binding = bindings[i2];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i2] = binding;
          }
          interpolants[i2].resultBuffer = binding.buffer;
        }
      },
      _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      },
      _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      },
      _initMemoryManager: function() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      },
      _isActiveAction: function(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
      },
      _addInactiveAction: function(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          const knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      },
      _removeInactiveAction: function(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      },
      _removeInactiveBindingsForAction: function(action) {
        const bindings = action._propertyBindings;
        for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
          const binding = bindings[i2];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      },
      _lendAction: function(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      },
      _takeBackAction: function(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      },
      _addInactiveBinding: function(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      },
      _removeInactiveBinding: function(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      },
      _lendBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      },
      _takeBackBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      },
      _lendControlInterpolant: function() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      },
      _takeBackControlInterpolant: function(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        let actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (blendMode === void 0) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode;
          }
        }
        if (actionsForClip !== void 0) {
          const existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
          return null;
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      },
      existingAction: function(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      },
      stopAllAction: function() {
        const actions = this._actions, nActions = this._nActiveActions;
        for (let i2 = nActions - 1; i2 >= 0; --i2) {
          actions[i2].stop();
        }
        return this;
      },
      update: function(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (let i2 = 0; i2 !== nActions; ++i2) {
          const action = actions[i2];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for (let i2 = 0; i2 !== nBindings; ++i2) {
          bindings[i2].apply(accuIndex);
        }
        return this;
      },
      setTime: function(timeInSeconds) {
        this.time = 0;
        for (let i2 = 0; i2 < this._actions.length; i2++) {
          this._actions[i2].time = 0;
        }
        return this.update(timeInSeconds);
      },
      getRoot: function() {
        return this._root;
      },
      uncacheClip: function(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          const actionsToRemove = actionsForClip.knownActions;
          for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
            const action = actionsToRemove[i2];
            this._deactivateAction(action);
            const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      },
      uncacheRoot: function(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (const clipUuid in actionsByClip) {
          const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (const trackName in bindingByName) {
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      },
      uncacheAction: function(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    });
    Uniform.prototype.clone = function() {
      return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    };
    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
      constructor: InstancedInterleavedBuffer,
      isInstancedInterleavedBuffer: true,
      copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      },
      clone: function(data) {
        const ib = InterleavedBuffer.prototype.clone.call(this, data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      },
      toJSON: function(data) {
        const json = InterleavedBuffer.prototype.toJSON.call(this, data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    });
    Object.assign(Raycaster.prototype, {
      set: function(origin, direction) {
        this.ray.set(origin, direction);
      },
      setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type.");
        }
      },
      intersectObject: function(object, recursive, optionalTarget) {
        const intersects2 = optionalTarget || [];
        intersectObject(object, this, intersects2, recursive);
        intersects2.sort(ascSort);
        return intersects2;
      },
      intersectObjects: function(objects, recursive, optionalTarget) {
        const intersects2 = optionalTarget || [];
        if (Array.isArray(objects) === false) {
          console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
          return intersects2;
        }
        for (let i2 = 0, l = objects.length; i2 < l; i2++) {
          intersectObject(objects[i2], this, intersects2, recursive);
        }
        intersects2.sort(ascSort);
        return intersects2;
      }
    });
    Spherical = class {
      constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      }
      makeSafe() {
        const EPS = 1e-6;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      }
      setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
      setFromCartesianCoords(x2, y, z) {
        this.radius = Math.sqrt(x2 * x2 + y * y + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x2, z);
          this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
        }
        return this;
      }
    };
    Object.assign(Cylindrical.prototype, {
      set: function(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      },
      setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      },
      setFromCartesianCoords: function(x2, y, z) {
        this.radius = Math.sqrt(x2 * x2 + z * z);
        this.theta = Math.atan2(x2, z);
        this.y = y;
        return this;
      }
    });
    _vector$4 = new Vector2();
    Object.assign(Box2.prototype, {
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      },
      setFromCenterAndSize: function(center, size) {
        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getCenter() target is now required");
          target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getSize() target is now required");
          target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
      },
      containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      },
      getParameter: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getParameter() target is now required");
          target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      intersectsBox: function(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
      },
      clampPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .clampPoint() target is now required");
          target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function(point) {
        const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      },
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    });
    _startP = new Vector3();
    _startEnd = new Vector3();
    Object.assign(Line3.prototype, {
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .getCenter() target is now required");
          target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .delta() target is now required");
          target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t2, target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .at() target is now required");
          target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t2).add(this.start);
      },
      closestPointToPointParameter: function(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t2 = startEnd_startP / startEnd2;
        if (clampToLine) {
          t2 = MathUtils.clamp(t2, 0, 1);
        }
        return t2;
      },
      closestPointToPoint: function(point, clampToLine, target) {
        const t2 = this.closestPointToPointParameter(point, clampToLine);
        if (target === void 0) {
          console.warn("THREE.Line3: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t2).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
    });
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    _vector$3 = new Vector3();
    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    SpotLightHelper.prototype.update = function() {
      this.light.updateMatrixWorld();
      const coneLength = this.light.distance ? this.light.distance : 1e3;
      const coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(_vector$3);
      if (this.color !== void 0) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    };
    _vector$2 = new Vector3();
    _boneMatrix = new Matrix4();
    _matrixWorldInv = new Matrix4();
    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    SkeletonHelper.prototype.isSkeletonHelper = true;
    SkeletonHelper.prototype.updateMatrixWorld = function(force) {
      const bones = this.bones;
      const geometry = this.geometry;
      const position = geometry.getAttribute("position");
      _matrixWorldInv.getInverse(this.root.matrixWorld);
      for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
        const bone = bones[i2];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;
    PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    PointLightHelper.prototype.update = function() {
      if (this.color !== void 0) {
        this.material.color.set(this.color);
      } else {
        this.material.color.copy(this.light.color);
      }
    };
    _vector$1 = new Vector3();
    _color1 = new Color();
    _color2 = new Color();
    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    HemisphereLightHelper.prototype.dispose = function() {
      this.children[0].geometry.dispose();
      this.children[0].material.dispose();
    };
    HemisphereLightHelper.prototype.update = function() {
      const mesh = this.children[0];
      if (this.color !== void 0) {
        this.material.color.set(this.color);
      } else {
        const colors = mesh.geometry.getAttribute("color");
        _color1.copy(this.light.color);
        _color2.copy(this.light.groundColor);
        for (let i2 = 0, l = colors.count; i2 < l; i2++) {
          const color = i2 < l / 2 ? _color1 : _color2;
          colors.setXYZ(i2, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
      }
      mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
    GridHelper.prototype = Object.create(LineSegments.prototype);
    GridHelper.prototype.constructor = GridHelper;
    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;
    _v1 = new Vector3();
    _v2 = new Vector3();
    _v3 = new Vector3();
    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    DirectionalLightHelper.prototype.update = function() {
      _v1.setFromMatrixPosition(this.light.matrixWorld);
      _v2.setFromMatrixPosition(this.light.target.matrixWorld);
      _v3.subVectors(_v2, _v1);
      this.lightPlane.lookAt(_v2);
      if (this.color !== void 0) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }
      this.targetLine.lookAt(_v2);
      this.targetLine.scale.z = _v3.length();
    };
    _vector = new Vector3();
    _camera = new Camera$1();
    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;
    CameraHelper.prototype.update = function() {
      const geometry = this.geometry;
      const pointMap = this.pointMap;
      const w = 1, h2 = 1;
      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
      setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
      setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
      setPoint("n1", pointMap, geometry, _camera, -w, -h2, -1);
      setPoint("n2", pointMap, geometry, _camera, w, -h2, -1);
      setPoint("n3", pointMap, geometry, _camera, -w, h2, -1);
      setPoint("n4", pointMap, geometry, _camera, w, h2, -1);
      setPoint("f1", pointMap, geometry, _camera, -w, -h2, 1);
      setPoint("f2", pointMap, geometry, _camera, w, -h2, 1);
      setPoint("f3", pointMap, geometry, _camera, -w, h2, 1);
      setPoint("f4", pointMap, geometry, _camera, w, h2, 1);
      setPoint("u1", pointMap, geometry, _camera, w * 0.7, h2 * 1.1, -1);
      setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h2 * 1.1, -1);
      setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
      setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
      setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
      setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
      setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
      setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
      setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
      setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
      setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
      geometry.getAttribute("position").needsUpdate = true;
    };
    _box = new Box3();
    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;
    BoxHelper.prototype.update = function(object) {
      if (object !== void 0) {
        console.warn("THREE.BoxHelper: .update() has no longer arguments.");
      }
      if (this.object !== void 0) {
        _box.setFromObject(this.object);
      }
      if (_box.isEmpty())
        return;
      const min = _box.min;
      const max = _box.max;
      const position = this.geometry.attributes.position;
      const array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    };
    BoxHelper.prototype.setFromObject = function(object) {
      this.object = object;
      this.update();
      return this;
    };
    BoxHelper.prototype.copy = function(source) {
      LineSegments.prototype.copy.call(this, source);
      this.object = source.object;
      return this;
    };
    Box3Helper.prototype = Object.create(LineSegments.prototype);
    Box3Helper.prototype.constructor = Box3Helper;
    Box3Helper.prototype.updateMatrixWorld = function(force) {
      const box = this.box;
      if (box.isEmpty())
        return;
      box.getCenter(this.position);
      box.getSize(this.scale);
      this.scale.multiplyScalar(0.5);
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    PlaneHelper.prototype = Object.create(Line.prototype);
    PlaneHelper.prototype.constructor = PlaneHelper;
    PlaneHelper.prototype.updateMatrixWorld = function(force) {
      let scale = -this.plane.constant;
      if (Math.abs(scale) < 1e-8)
        scale = 1e-8;
      this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
      this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
      this.lookAt(this.plane.normal);
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    _axis = new Vector3();
    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;
    ArrowHelper.prototype.setDirection = function(dir) {
      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        _axis.set(dir.z, 0, -dir.x).normalize();
        const radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(_axis, radians);
      }
    };
    ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
      if (headLength === void 0)
        headLength = 0.2 * length;
      if (headWidth === void 0)
        headWidth = 0.2 * headLength;
      this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    };
    ArrowHelper.prototype.setColor = function(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    ArrowHelper.prototype.copy = function(source) {
      Object3D.prototype.copy.call(this, source, false);
      this.line.copy(source.line);
      this.cone.copy(source.cone);
      return this;
    };
    AxesHelper.prototype = Object.create(LineSegments.prototype);
    AxesHelper.prototype.constructor = AxesHelper;
    LOD_MIN = 4;
    LOD_MAX = 8;
    EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    new OrthographicCamera();
    _createPlanes();
    PHI = (1 + Math.sqrt(5)) / 2;
    INV_PHI = 1 / PHI;
    [
      new Vector3(1, 1, 1),
      new Vector3(-1, 1, 1),
      new Vector3(1, 1, -1),
      new Vector3(-1, 1, -1),
      new Vector3(0, PHI, INV_PHI),
      new Vector3(0, PHI, -INV_PHI),
      new Vector3(INV_PHI, 0, PHI),
      new Vector3(-INV_PHI, 0, PHI),
      new Vector3(PHI, INV_PHI, 0),
      new Vector3(-PHI, INV_PHI, 0)
    ];
    Curve.create = function(construct, getPoint) {
      console.log("THREE.Curve.create() has been deprecated");
      construct.prototype = Object.create(Curve.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;
      return construct;
    };
    Object.assign(CurvePath.prototype, {
      createPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const pts = this.getPoints(divisions);
        return this.createGeometry(pts);
      },
      createSpacedPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
      },
      createGeometry: function(points) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        const geometry = new Geometry();
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
      }
    });
    Object.assign(Path.prototype, {
      fromPoints: function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      }
    });
    Spline.prototype = Object.create(CatmullRomCurve3.prototype);
    Object.assign(Spline.prototype, {
      initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      },
      getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
      },
      reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
      }
    });
    GridHelper.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    };
    SkeletonHelper.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    };
    Object.assign(Loader.prototype, {
      extractUrlBase: function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
      }
    });
    Loader.Handlers = {
      add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      },
      get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      }
    };
    Object.assign(ObjectLoader.prototype, {
      setTexturePath: function(value) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value);
      }
    });
    Object.assign(Box2.prototype, {
      center: function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      },
      empty: function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      },
      isIntersectionBox: function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      size: function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      }
    });
    Object.assign(Box3.prototype, {
      center: function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      },
      empty: function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      },
      isIntersectionBox: function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      isIntersectionSphere: function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      },
      size: function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      }
    });
    Object.assign(Sphere.prototype, {
      empty: function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      }
    });
    Frustum.prototype.setFromMatrix = function(m2) {
      console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
      return this.setFromProjectionMatrix(m2);
    };
    Line3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Object.assign(MathUtils, {
      random16: function() {
        console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
        return Math.random();
      },
      nearestPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
        return MathUtils.floorPowerOfTwo(value);
      },
      nextPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
        return MathUtils.ceilPowerOfTwo(value);
      }
    });
    Object.assign(Matrix3.prototype, {
      flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      },
      multiplyVector3: function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      },
      applyToBufferAttribute: function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      },
      applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      }
    });
    Object.assign(Matrix4.prototype, {
      extractPosition: function(m2) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m2);
      },
      flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      },
      getPosition: function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
      },
      setRotationFromQuaternion: function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      },
      multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      },
      multiplyVector3: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      multiplyVector4: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      },
      rotateAxis: function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      },
      rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      },
      rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      },
      rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      },
      rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      },
      applyToBufferAttribute: function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      },
      applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      },
      makeFrustum: function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      }
    });
    Plane.prototype.isIntersectionLine = function(line) {
      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
      return this.intersectsLine(line);
    };
    Quaternion.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    };
    Object.assign(Ray.prototype, {
      isIntersectionBox: function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      isIntersectionPlane: function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      },
      isIntersectionSphere: function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      }
    });
    Object.assign(Triangle.prototype, {
      area: function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      },
      barycoordFromPoint: function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      },
      midpoint: function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      },
      normal: function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      },
      plane: function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      }
    });
    Object.assign(Triangle, {
      barycoordFromPoint: function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
      },
      normal: function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
      }
    });
    Object.assign(Shape.prototype, {
      extractAllPoints: function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      },
      extrude: function(options2) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options2);
      },
      makeGeometry: function(options2) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options2);
      }
    });
    Object.assign(Vector2.prototype, {
      fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      },
      distanceToManhattan: function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Vector3.prototype, {
      setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      },
      setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      },
      getPositionFromMatrix: function(m2) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m2);
      },
      getScaleFromMatrix: function(m2) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m2);
      },
      getColumnFromMatrix: function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
      },
      applyProjection: function(m2) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m2);
      },
      fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      },
      distanceToManhattan: function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Vector4.prototype, {
      fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Geometry.prototype, {
      computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      },
      computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
      },
      applyMatrix: function(matrix) {
        console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      }
    });
    Object.assign(Object3D.prototype, {
      getChildByName: function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      },
      renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      },
      translate: function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      },
      getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      },
      applyMatrix: function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      }
    });
    Object.defineProperties(Object3D.prototype, {
      eulerOrder: {
        get: function() {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          return this.rotation.order;
        },
        set: function(value) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          this.rotation.order = value;
        }
      },
      useQuaternion: {
        get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
      }
    });
    Object.assign(Mesh.prototype, {
      setDrawMode: function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    });
    Object.defineProperties(Mesh.prototype, {
      drawMode: {
        get: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
          return TrianglesDrawMode;
        },
        set: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
      }
    });
    Object.defineProperties(LOD.prototype, {
      objects: {
        get: function() {
          console.warn("THREE.LOD: .objects has been renamed to .levels.");
          return this.levels;
        }
      }
    });
    Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
      get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
      set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      }
    });
    SkinnedMesh.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    };
    Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
      get: function() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions;
      },
      set: function(value) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = value;
      }
    });
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
      if (filmGauge !== void 0)
        this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light$1.prototype, {
      onlyShadow: {
        set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        }
      },
      shadowCameraFov: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
          this.shadow.camera.fov = value;
        }
      },
      shadowCameraLeft: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
          this.shadow.camera.left = value;
        }
      },
      shadowCameraRight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
          this.shadow.camera.right = value;
        }
      },
      shadowCameraTop: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
          this.shadow.camera.top = value;
        }
      },
      shadowCameraBottom: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
          this.shadow.camera.bottom = value;
        }
      },
      shadowCameraNear: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
          this.shadow.camera.near = value;
        }
      },
      shadowCameraFar: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
          this.shadow.camera.far = value;
        }
      },
      shadowCameraVisible: {
        set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
      },
      shadowBias: {
        set: function(value) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
          this.shadow.bias = value;
        }
      },
      shadowDarkness: {
        set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
      },
      shadowMapWidth: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
          this.shadow.mapSize.width = value;
        }
      },
      shadowMapHeight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
          this.shadow.mapSize.height = value;
        }
      }
    });
    Object.defineProperties(BufferAttribute.prototype, {
      length: {
        get: function() {
          console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
          return this.array.length;
        }
      },
      dynamic: {
        get: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          this.setUsage(DynamicDrawUsage);
        }
      }
    });
    Object.assign(BufferAttribute.prototype, {
      setDynamic: function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      },
      copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      },
      setArray: function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }
    });
    Object.assign(BufferGeometry.prototype, {
      addIndex: function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
      },
      addAttribute: function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      },
      addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      },
      clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      },
      computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
      },
      computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      },
      removeAttribute: function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      },
      applyMatrix: function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      }
    });
    Object.defineProperties(BufferGeometry.prototype, {
      drawcalls: {
        get: function() {
          console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
          return this.groups;
        }
      },
      offsets: {
        get: function() {
          console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
          return this.groups;
        }
      }
    });
    Object.defineProperties(InstancedBufferGeometry.prototype, {
      maxInstancedCount: {
        get: function() {
          console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
          return this.instanceCount;
        },
        set: function(value) {
          console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
          this.instanceCount = value;
        }
      }
    });
    Object.defineProperties(Raycaster.prototype, {
      linePrecision: {
        get: function() {
          console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
          return this.params.Line.threshold;
        },
        set: function(value) {
          console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
          this.params.Line.threshold = value;
        }
      }
    });
    Object.defineProperties(InterleavedBuffer.prototype, {
      dynamic: {
        get: function() {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function(value) {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          this.setUsage(value);
        }
      }
    });
    Object.assign(InterleavedBuffer.prototype, {
      setDynamic: function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      },
      setArray: function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }
    });
    Object.assign(ExtrudeBufferGeometry.prototype, {
      getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
      },
      addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
      },
      addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
      }
    });
    Object.defineProperties(Uniform.prototype, {
      dynamic: {
        set: function() {
          console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        }
      },
      onUpdate: {
        value: function() {
          console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
          return this;
        }
      }
    });
    Object.defineProperties(Material.prototype, {
      wrapAround: {
        get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }
      },
      overdraw: {
        get: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }
      },
      wrapRGB: {
        get: function() {
          console.warn("THREE.Material: .wrapRGB has been removed.");
          return new Color();
        }
      },
      shading: {
        get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = value === FlatShading;
        }
      },
      stencilMask: {
        get: function() {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          return this.stencilFuncMask;
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          this.stencilFuncMask = value;
        }
      }
    });
    Object.defineProperties(MeshPhongMaterial.prototype, {
      metal: {
        get: function() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
      }
    });
    Object.defineProperties(MeshPhysicalMaterial.prototype, {
      transparency: {
        get: function() {
          console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
          return this.transmission;
        },
        set: function(value) {
          console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
          this.transmission = value;
        }
      }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
      derivatives: {
        get: function() {
          console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          return this.extensions.derivatives;
        },
        set: function(value) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          this.extensions.derivatives = value;
        }
      }
    });
    Object.assign(WebGLRenderer.prototype, {
      clearTarget: function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      },
      animate: function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      },
      getCurrentRenderTarget: function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      },
      getMaxAnisotropy: function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      },
      getPrecision: function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      },
      resetGLState: function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      },
      supportsFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      },
      supportsHalfFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      },
      supportsStandardDerivatives: function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      },
      supportsCompressedTextureS3TC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      },
      supportsCompressedTexturePVRTC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      },
      supportsBlendMinMax: function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      },
      supportsVertexTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      },
      supportsInstancedArrays: function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      },
      enableScissorTest: function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      },
      initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      },
      addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      },
      addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      },
      updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      },
      setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      },
      allocTextureUnit: function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      },
      setTexture: function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      },
      setTexture2D: function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      },
      setTextureCube: function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      },
      getActiveMipMapLevel: function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      }
    });
    Object.defineProperties(WebGLRenderer.prototype, {
      shadowMapEnabled: {
        get: function() {
          return this.shadowMap.enabled;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
          this.shadowMap.enabled = value;
        }
      },
      shadowMapType: {
        get: function() {
          return this.shadowMap.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
          this.shadowMap.type = value;
        }
      },
      shadowMapCullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      context: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
          return this.getContext();
        }
      },
      vr: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
          return this.xr;
        }
      },
      gammaInput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
      },
      gammaOutput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          return false;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
      },
      toneMappingWhitePoint: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          return 1;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
      }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
      cullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      renderReverseSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
      },
      renderSingleSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
      }
    });
    Object.defineProperties(WebGLRenderTarget.prototype, {
      wrapS: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          return this.texture.wrapS;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          this.texture.wrapS = value;
        }
      },
      wrapT: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          return this.texture.wrapT;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          this.texture.wrapT = value;
        }
      },
      magFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          return this.texture.magFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          this.texture.magFilter = value;
        }
      },
      minFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          return this.texture.minFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          this.texture.minFilter = value;
        }
      },
      anisotropy: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          return this.texture.anisotropy;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          this.texture.anisotropy = value;
        }
      },
      offset: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          return this.texture.offset;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          this.texture.offset = value;
        }
      },
      repeat: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          return this.texture.repeat;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          this.texture.repeat = value;
        }
      },
      format: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          return this.texture.format;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          this.texture.format = value;
        }
      },
      type: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          return this.texture.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          this.texture.type = value;
        }
      },
      generateMipmaps: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          return this.texture.generateMipmaps;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          this.texture.generateMipmaps = value;
        }
      }
    });
    Object.defineProperties(Audio.prototype, {
      load: {
        value: function(file) {
          console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
          const scope = this;
          const audioLoader = new AudioLoader();
          audioLoader.load(file, function(buffer) {
            scope.setBuffer(buffer);
          });
          return this;
        }
      },
      startTime: {
        set: function() {
          console.warn("THREE.Audio: .startTime is now .play( delay ).");
        }
      }
    });
    AudioAnalyser.prototype.getData = function() {
      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
      return this.getFrequencyData();
    };
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
      return this.update(renderer, scene);
    };
    ImageUtils.crossOrigin = void 0;
    ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const loader = new TextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      const texture = loader.load(url, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const loader = new CubeTextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      const texture = loader.load(urls, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    (function() {
      function GLTFLoader(manager) {
        Loader.call(this, manager);
        this.dracoLoader = null;
        this.ddsLoader = null;
        this.ktx2Loader = null;
        this.pluginCallbacks = [];
        this.register(function(parser) {
          return new GLTFMaterialsClearcoatExtension(parser);
        });
        this.register(function(parser) {
          return new GLTFTextureBasisUExtension(parser);
        });
        this.register(function(parser) {
          return new GLTFMaterialsTransmissionExtension(parser);
        });
      }
      GLTFLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: GLTFLoader,
        load: function(url, onLoad, onProgress, onError) {
          var scope = this;
          var resourcePath;
          if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
          } else if (this.path !== "") {
            resourcePath = this.path;
          } else {
            resourcePath = LoaderUtils.extractUrlBase(url);
          }
          scope.manager.itemStart(url);
          var _onError = function(e2) {
            if (onError) {
              onError(e2);
            } else {
              console.error(e2);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          };
          var loader = new FileLoader(scope.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          if (scope.crossOrigin === "use-credentials") {
            loader.setWithCredentials(true);
          }
          loader.load(url, function(data) {
            try {
              scope.parse(data, resourcePath, function(gltf) {
                onLoad(gltf);
                scope.manager.itemEnd(url);
              }, _onError);
            } catch (e2) {
              _onError(e2);
            }
          }, onProgress, _onError);
        },
        setDRACOLoader: function(dracoLoader) {
          this.dracoLoader = dracoLoader;
          return this;
        },
        setDDSLoader: function(ddsLoader) {
          this.ddsLoader = ddsLoader;
          return this;
        },
        setKTX2Loader: function(ktx2Loader) {
          this.ktx2Loader = ktx2Loader;
          return this;
        },
        register: function(callback) {
          if (this.pluginCallbacks.indexOf(callback) === -1) {
            this.pluginCallbacks.push(callback);
          }
          return this;
        },
        unregister: function(callback) {
          if (this.pluginCallbacks.indexOf(callback) !== -1) {
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
          }
          return this;
        },
        parse: function(data, path, onLoad, onError) {
          var content;
          var extensions = {};
          var plugins = {};
          if (typeof data === "string") {
            content = data;
          } else {
            var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
              try {
                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
              } catch (error2) {
                if (onError)
                  onError(error2);
                return;
              }
              content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
            } else {
              content = LoaderUtils.decodeText(new Uint8Array(data));
            }
          }
          var json = JSON.parse(content);
          if (json.asset === void 0 || json.asset.version[0] < 2) {
            if (onError)
              onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          var parser = new GLTFParser(json, {
            path: path || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader
          });
          parser.fileLoader.setRequestHeader(this.requestHeader);
          for (var i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
            var plugin = this.pluginCallbacks[i2](parser);
            plugins[plugin.name] = plugin;
            extensions[plugin.name] = true;
          }
          if (json.extensionsUsed) {
            for (var i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
              var extensionName = json.extensionsUsed[i2];
              var extensionsRequired = json.extensionsRequired || [];
              switch (extensionName) {
                case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
                  extensions[extensionName] = new GLTFLightsExtension(json);
                  break;
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                  extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                  break;
                case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                  break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                  extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                  break;
                case EXTENSIONS.MSFT_TEXTURE_DDS:
                  extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
                  break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                  extensions[extensionName] = new GLTFTextureTransformExtension();
                  break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                  extensions[extensionName] = new GLTFMeshQuantizationExtension();
                  break;
                default:
                  if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                    console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                  }
              }
            }
          }
          parser.setExtensions(extensions);
          parser.setPlugins(plugins);
          parser.parse(onLoad, onError);
        }
      });
      function GLTFRegistry() {
        var objects = {};
        return {
          get: function(key) {
            return objects[key];
          },
          add: function(key, object) {
            objects[key] = object;
          },
          remove: function(key) {
            delete objects[key];
          },
          removeAll: function() {
            objects = {};
          }
        };
      }
      var EXTENSIONS = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        MSFT_TEXTURE_DDS: "MSFT_texture_dds"
      };
      function GLTFTextureDDSExtension(ddsLoader) {
        if (!ddsLoader) {
          throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
        }
        this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
        this.ddsLoader = ddsLoader;
      }
      function GLTFLightsExtension(json) {
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
        var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
        this.lightDefs = extension.lights || [];
      }
      GLTFLightsExtension.prototype.loadLight = function(lightIndex) {
        var lightDef = this.lightDefs[lightIndex];
        var lightNode;
        var color = new Color(16777215);
        if (lightDef.color !== void 0)
          color.fromArray(lightDef.color);
        var range = lightDef.range !== void 0 ? lightDef.range : 0;
        switch (lightDef.type) {
          case "directional":
            lightNode = new DirectionalLight(color);
            lightNode.target.position.set(0, 0, -1);
            lightNode.add(lightNode.target);
            break;
          case "point":
            lightNode = new PointLight(color);
            lightNode.distance = range;
            break;
          case "spot":
            lightNode = new SpotLight(color);
            lightNode.distance = range;
            lightDef.spot = lightDef.spot || {};
            lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
            lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
            lightNode.angle = lightDef.spot.outerConeAngle;
            lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
            lightNode.target.position.set(0, 0, -1);
            lightNode.add(lightNode.target);
            break;
          default:
            throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
        }
        lightNode.position.set(0, 0, 0);
        lightNode.decay = 2;
        if (lightDef.intensity !== void 0)
          lightNode.intensity = lightDef.intensity;
        lightNode.name = lightDef.name || "light_" + lightIndex;
        return Promise.resolve(lightNode);
      };
      function GLTFMaterialsUnlitExtension() {
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
      }
      GLTFMaterialsUnlitExtension.prototype.getMaterialType = function() {
        return MeshBasicMaterial;
      };
      GLTFMaterialsUnlitExtension.prototype.extendParams = function(materialParams, materialDef, parser) {
        var pending = [];
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        var metallicRoughness = materialDef.pbrMetallicRoughness;
        if (metallicRoughness) {
          if (Array.isArray(metallicRoughness.baseColorFactor)) {
            var array = metallicRoughness.baseColorFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (metallicRoughness.baseColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
          }
        }
        return Promise.all(pending);
      };
      function GLTFMaterialsClearcoatExtension(parser) {
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
      }
      GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function() {
        return MeshPhysicalMaterial;
      };
      GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        if (extension.clearcoatFactor !== void 0) {
          materialParams.clearcoat = extension.clearcoatFactor;
        }
        if (extension.clearcoatTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
        }
        if (extension.clearcoatRoughnessFactor !== void 0) {
          materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
        }
        if (extension.clearcoatRoughnessTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
        }
        if (extension.clearcoatNormalTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
          if (extension.clearcoatNormalTexture.scale !== void 0) {
            var scale = extension.clearcoatNormalTexture.scale;
            materialParams.clearcoatNormalScale = new Vector2(scale, scale);
          }
        }
        return Promise.all(pending);
      };
      function GLTFMaterialsTransmissionExtension(parser) {
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
      }
      GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function() {
        return MeshPhysicalMaterial;
      };
      GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        if (extension.transmissionFactor !== void 0) {
          materialParams.transmission = extension.transmissionFactor;
        }
        if (extension.transmissionTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
        }
        return Promise.all(pending);
      };
      function GLTFTextureBasisUExtension(parser) {
        this.parser = parser;
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
      }
      GLTFTextureBasisUExtension.prototype.loadTexture = function(textureIndex) {
        var parser = this.parser;
        var json = parser.json;
        var textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[this.name]) {
          return null;
        }
        var extension = textureDef.extensions[this.name];
        var source = json.images[extension.source];
        var loader = parser.options.ktx2Loader;
        if (!loader) {
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        }
        return parser.loadTextureImage(textureIndex, source, loader);
      };
      var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
      var BINARY_EXTENSION_HEADER_LENGTH = 12;
      var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
      function GLTFBinaryExtension(data) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;
        var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
        this.header = {
          magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
          version: headerView.getUint32(4, true),
          length: headerView.getUint32(8, true)
        };
        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
          throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        } else if (this.header.version < 2) {
          throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        }
        var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        var chunkIndex = 0;
        while (chunkIndex < chunkView.byteLength) {
          var chunkLength = chunkView.getUint32(chunkIndex, true);
          chunkIndex += 4;
          var chunkType = chunkView.getUint32(chunkIndex, true);
          chunkIndex += 4;
          if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
            var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
            this.content = LoaderUtils.decodeText(contentArray);
          } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
            var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
            this.body = data.slice(byteOffset, byteOffset + chunkLength);
          }
          chunkIndex += chunkLength;
        }
        if (this.content === null) {
          throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
        if (!dracoLoader) {
          throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        }
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        this.dracoLoader.preload();
      }
      GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(primitive, parser) {
        var json = this.json;
        var dracoLoader = this.dracoLoader;
        var bufferViewIndex = primitive.extensions[this.name].bufferView;
        var gltfAttributeMap = primitive.extensions[this.name].attributes;
        var threeAttributeMap = {};
        var attributeNormalizedMap = {};
        var attributeTypeMap = {};
        for (var attributeName in gltfAttributeMap) {
          var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
          threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
        }
        for (attributeName in primitive.attributes) {
          var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
          if (gltfAttributeMap[attributeName] !== void 0) {
            var accessorDef = json.accessors[primitive.attributes[attributeName]];
            var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            attributeTypeMap[threeAttributeName] = componentType;
            attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
          }
        }
        return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
          return new Promise(function(resolve2) {
            dracoLoader.decodeDracoFile(bufferView, function(geometry) {
              for (var attributeName2 in geometry.attributes) {
                var attribute = geometry.attributes[attributeName2];
                var normalized = attributeNormalizedMap[attributeName2];
                if (normalized !== void 0)
                  attribute.normalized = normalized;
              }
              resolve2(geometry);
            }, threeAttributeMap, attributeTypeMap);
          });
        });
      };
      function GLTFTextureTransformExtension() {
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
      }
      GLTFTextureTransformExtension.prototype.extendTexture = function(texture, transform) {
        texture = texture.clone();
        if (transform.offset !== void 0) {
          texture.offset.fromArray(transform.offset);
        }
        if (transform.rotation !== void 0) {
          texture.rotation = transform.rotation;
        }
        if (transform.scale !== void 0) {
          texture.repeat.fromArray(transform.scale);
        }
        if (transform.texCoord !== void 0) {
          console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
        }
        texture.needsUpdate = true;
        return texture;
      };
      function GLTFMeshStandardSGMaterial(params) {
        MeshStandardMaterial.call(this);
        this.isGLTFSpecularGlossinessMaterial = true;
        var specularMapParsFragmentChunk = [
          "#ifdef USE_SPECULARMAP",
          "	uniform sampler2D specularMap;",
          "#endif"
        ].join("\n");
        var glossinessMapParsFragmentChunk = [
          "#ifdef USE_GLOSSINESSMAP",
          "	uniform sampler2D glossinessMap;",
          "#endif"
        ].join("\n");
        var specularMapFragmentChunk = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "	vec4 texelSpecular = texture2D( specularMap, vUv );",
          "	texelSpecular = sRGBToLinear( texelSpecular );",
          "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "	specularFactor *= texelSpecular.rgb;",
          "#endif"
        ].join("\n");
        var glossinessMapFragmentChunk = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "	glossinessFactor *= texelGlossiness.a;",
          "#endif"
        ].join("\n");
        var lightPhysicalFragmentChunk = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb;",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.specularRoughness += geometryRoughness;",
          "material.specularRoughness = min( material.specularRoughness, 1.0 );",
          "material.specularColor = specularFactor.rgb;"
        ].join("\n");
        var uniforms = {
          specular: { value: new Color().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null }
        };
        this._extraUniforms = uniforms;
        this.onBeforeCompile = function(shader) {
          for (var uniformName in uniforms) {
            shader.uniforms[uniformName] = uniforms[uniformName];
          }
          shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;");
          shader.fragmentShader = shader.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;");
          shader.fragmentShader = shader.fragmentShader.replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk);
          shader.fragmentShader = shader.fragmentShader.replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk);
          shader.fragmentShader = shader.fragmentShader.replace("#include <roughnessmap_fragment>", specularMapFragmentChunk);
          shader.fragmentShader = shader.fragmentShader.replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk);
          shader.fragmentShader = shader.fragmentShader.replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
        };
        Object.defineProperties(this, {
          specular: {
            get: function() {
              return uniforms.specular.value;
            },
            set: function(v) {
              uniforms.specular.value = v;
            }
          },
          specularMap: {
            get: function() {
              return uniforms.specularMap.value;
            },
            set: function(v) {
              uniforms.specularMap.value = v;
            }
          },
          glossiness: {
            get: function() {
              return uniforms.glossiness.value;
            },
            set: function(v) {
              uniforms.glossiness.value = v;
            }
          },
          glossinessMap: {
            get: function() {
              return uniforms.glossinessMap.value;
            },
            set: function(v) {
              uniforms.glossinessMap.value = v;
              if (v) {
                this.defines.USE_GLOSSINESSMAP = "";
                this.defines.USE_ROUGHNESSMAP = "";
              } else {
                delete this.defines.USE_ROUGHNESSMAP;
                delete this.defines.USE_GLOSSINESSMAP;
              }
            }
          }
        });
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        this.setValues(params);
      }
      GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
      GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;
      GLTFMeshStandardSGMaterial.prototype.copy = function(source) {
        MeshStandardMaterial.prototype.copy.call(this, source);
        this.specularMap = source.specularMap;
        this.specular.copy(source.specular);
        this.glossinessMap = source.glossinessMap;
        this.glossiness = source.glossiness;
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        return this;
      };
      function GLTFMaterialsPbrSpecularGlossinessExtension() {
        return {
          name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
          specularGlossinessParams: [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity",
            "refractionRatio"
          ],
          getMaterialType: function() {
            return GLTFMeshStandardSGMaterial;
          },
          extendParams: function(materialParams, materialDef, parser) {
            var pbrSpecularGlossiness = materialDef.extensions[this.name];
            materialParams.color = new Color(1, 1, 1);
            materialParams.opacity = 1;
            var pending = [];
            if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
              var array = pbrSpecularGlossiness.diffuseFactor;
              materialParams.color.fromArray(array);
              materialParams.opacity = array[3];
            }
            if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
            }
            materialParams.emissive = new Color(0, 0, 0);
            materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
            materialParams.specular = new Color(1, 1, 1);
            if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
              materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
            }
            if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
              var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
              pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
              pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
            }
            return Promise.all(pending);
          },
          createMaterial: function(materialParams) {
            var material = new GLTFMeshStandardSGMaterial(materialParams);
            material.fog = true;
            material.color = materialParams.color;
            material.map = materialParams.map === void 0 ? null : materialParams.map;
            material.lightMap = null;
            material.lightMapIntensity = 1;
            material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
            material.aoMapIntensity = 1;
            material.emissive = materialParams.emissive;
            material.emissiveIntensity = 1;
            material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
            material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
            material.bumpScale = 1;
            material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
            material.normalMapType = TangentSpaceNormalMap;
            if (materialParams.normalScale)
              material.normalScale = materialParams.normalScale;
            material.displacementMap = null;
            material.displacementScale = 1;
            material.displacementBias = 0;
            material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
            material.specular = materialParams.specular;
            material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
            material.glossiness = materialParams.glossiness;
            material.alphaMap = null;
            material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
            material.envMapIntensity = 1;
            material.refractionRatio = 0.98;
            return material;
          }
        };
      }
      function GLTFMeshQuantizationExtension() {
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
      }
      function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
      GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;
      GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(index) {
        var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
        for (var i2 = 0; i2 !== valueSize; i2++) {
          result[i2] = values[offset + i2];
        }
        return result;
      };
      GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t2, t1) {
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var stride2 = stride * 2;
        var stride3 = stride * 3;
        var td = t1 - t0;
        var p = (t2 - t0) / td;
        var pp = p * p;
        var ppp = pp * p;
        var offset1 = i1 * stride3;
        var offset0 = offset1 - stride3;
        var s22 = -2 * ppp + 3 * pp;
        var s3 = ppp - pp;
        var s0 = 1 - s22;
        var s1 = s3 - pp + p;
        for (var i2 = 0; i2 !== stride; i2++) {
          var p0 = values[offset0 + i2 + stride];
          var m0 = values[offset0 + i2 + stride2] * td;
          var p1 = values[offset1 + i2 + stride];
          var m1 = values[offset1 + i2] * td;
          result[i2] = s0 * p0 + s1 * m0 + s22 * p1 + s3 * m1;
        }
        return result;
      };
      var WEBGL_CONSTANTS = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
      };
      var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      };
      var WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
      };
      var WEBGL_WRAPPINGS = {
        33071: ClampToEdgeWrapping,
        33648: MirroredRepeatWrapping,
        10497: RepeatWrapping
      };
      var WEBGL_TYPE_SIZES = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
      };
      var ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      };
      var PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      };
      var INTERPOLATION = {
        CUBICSPLINE: void 0,
        LINEAR: InterpolateLinear,
        STEP: InterpolateDiscrete
      };
      var ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      var MIME_TYPE_FORMATS = {
        "image/png": RGBAFormat,
        "image/jpeg": RGBFormat
      };
      function resolveURL(url, path) {
        if (typeof url !== "string" || url === "")
          return "";
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        }
        if (/^(https?:)?\/\//i.test(url))
          return url;
        if (/^data:.*,.*$/i.test(url))
          return url;
        if (/^blob:.*$/i.test(url))
          return url;
        return path + url;
      }
      function createDefaultMaterial(cache) {
        if (cache["DefaultMaterial"] === void 0) {
          cache["DefaultMaterial"] = new MeshStandardMaterial({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: false,
            depthTest: true,
            side: FrontSide
          });
        }
        return cache["DefaultMaterial"];
      }
      function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
        for (var name in objectDef.extensions) {
          if (knownExtensions[name] === void 0) {
            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
            object.userData.gltfExtensions[name] = objectDef.extensions[name];
          }
        }
      }
      function assignExtrasToUserData(object, gltfDef) {
        if (gltfDef.extras !== void 0) {
          if (typeof gltfDef.extras === "object") {
            Object.assign(object.userData, gltfDef.extras);
          } else {
            console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
          }
        }
      }
      function addMorphTargets(geometry, targets, parser) {
        var hasMorphPosition = false;
        var hasMorphNormal = false;
        for (var i2 = 0, il = targets.length; i2 < il; i2++) {
          var target = targets[i2];
          if (target.POSITION !== void 0)
            hasMorphPosition = true;
          if (target.NORMAL !== void 0)
            hasMorphNormal = true;
          if (hasMorphPosition && hasMorphNormal)
            break;
        }
        if (!hasMorphPosition && !hasMorphNormal)
          return Promise.resolve(geometry);
        var pendingPositionAccessors = [];
        var pendingNormalAccessors = [];
        for (var i2 = 0, il = targets.length; i2 < il; i2++) {
          var target = targets[i2];
          if (hasMorphPosition) {
            var pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
            pendingPositionAccessors.push(pendingAccessor);
          }
          if (hasMorphNormal) {
            var pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
            pendingNormalAccessors.push(pendingAccessor);
          }
        }
        return Promise.all([
          Promise.all(pendingPositionAccessors),
          Promise.all(pendingNormalAccessors)
        ]).then(function(accessors) {
          var morphPositions = accessors[0];
          var morphNormals = accessors[1];
          if (hasMorphPosition)
            geometry.morphAttributes.position = morphPositions;
          if (hasMorphNormal)
            geometry.morphAttributes.normal = morphNormals;
          geometry.morphTargetsRelative = true;
          return geometry;
        });
      }
      function updateMorphTargets(mesh, meshDef) {
        mesh.updateMorphTargets();
        if (meshDef.weights !== void 0) {
          for (var i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
            mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
          }
        }
        if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
          var targetNames = meshDef.extras.targetNames;
          if (mesh.morphTargetInfluences.length === targetNames.length) {
            mesh.morphTargetDictionary = {};
            for (var i2 = 0, il = targetNames.length; i2 < il; i2++) {
              mesh.morphTargetDictionary[targetNames[i2]] = i2;
            }
          } else {
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
          }
        }
      }
      function createPrimitiveKey(primitiveDef) {
        var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
        var geometryKey;
        if (dracoExtension) {
          geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
        } else {
          geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
        }
        return geometryKey;
      }
      function createAttributesKey(attributes) {
        var attributesKey = "";
        var keys = Object.keys(attributes).sort();
        for (var i2 = 0, il = keys.length; i2 < il; i2++) {
          attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
        }
        return attributesKey;
      }
      function GLTFParser(json, options2) {
        this.json = json || {};
        this.extensions = {};
        this.plugins = {};
        this.options = options2 || {};
        this.cache = new GLTFRegistry();
        this.associations = new Map();
        this.primitiveCache = {};
        this.meshCache = { refs: {}, uses: {} };
        this.cameraCache = { refs: {}, uses: {} };
        this.lightCache = { refs: {}, uses: {} };
        if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
          this.textureLoader = new ImageBitmapLoader(this.options.manager);
        } else {
          this.textureLoader = new TextureLoader(this.options.manager);
        }
        this.textureLoader.setCrossOrigin(this.options.crossOrigin);
        this.fileLoader = new FileLoader(this.options.manager);
        this.fileLoader.setResponseType("arraybuffer");
        if (this.options.crossOrigin === "use-credentials") {
          this.fileLoader.setWithCredentials(true);
        }
      }
      GLTFParser.prototype.setExtensions = function(extensions) {
        this.extensions = extensions;
      };
      GLTFParser.prototype.setPlugins = function(plugins) {
        this.plugins = plugins;
      };
      GLTFParser.prototype.parse = function(onLoad, onError) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        this.cache.removeAll();
        this._markDefs();
        Promise.all([
          this.getDependencies("scene"),
          this.getDependencies("animation"),
          this.getDependencies("camera")
        ]).then(function(dependencies) {
          var result = {
            scene: dependencies[0][json.scene || 0],
            scenes: dependencies[0],
            animations: dependencies[1],
            cameras: dependencies[2],
            asset: json.asset,
            parser,
            userData: {}
          };
          addUnknownExtensionsToUserData(extensions, result, json);
          assignExtrasToUserData(result, json);
          onLoad(result);
        }).catch(onError);
      };
      GLTFParser.prototype._markDefs = function() {
        var nodeDefs = this.json.nodes || [];
        var skinDefs = this.json.skins || [];
        var meshDefs = this.json.meshes || [];
        for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
          var joints = skinDefs[skinIndex].joints;
          for (var i2 = 0, il = joints.length; i2 < il; i2++) {
            nodeDefs[joints[i2]].isBone = true;
          }
        }
        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
          var nodeDef = nodeDefs[nodeIndex];
          if (nodeDef.mesh !== void 0) {
            this._addNodeRef(this.meshCache, nodeDef.mesh);
            if (nodeDef.skin !== void 0) {
              meshDefs[nodeDef.mesh].isSkinnedMesh = true;
            }
          }
          if (nodeDef.camera !== void 0) {
            this._addNodeRef(this.cameraCache, nodeDef.camera);
          }
          if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== void 0) {
            this._addNodeRef(this.lightCache, nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);
          }
        }
      };
      GLTFParser.prototype._addNodeRef = function(cache, index) {
        if (index === void 0)
          return;
        if (cache.refs[index] === void 0) {
          cache.refs[index] = cache.uses[index] = 0;
        }
        cache.refs[index]++;
      };
      GLTFParser.prototype._getNodeRef = function(cache, index, object) {
        if (cache.refs[index] <= 1)
          return object;
        var ref = object.clone();
        ref.name += "_instance_" + cache.uses[index]++;
        return ref;
      };
      GLTFParser.prototype._invokeOne = function(func) {
        var extensions = Object.values(this.plugins);
        extensions.push(this);
        for (var i2 = 0; i2 < extensions.length; i2++) {
          var result = func(extensions[i2]);
          if (result)
            return result;
        }
      };
      GLTFParser.prototype._invokeAll = function(func) {
        var extensions = Object.values(this.plugins);
        extensions.unshift(this);
        var pending = [];
        for (var i2 = 0; i2 < extensions.length; i2++) {
          pending.push(func(extensions[i2]));
        }
        return Promise.all(pending);
      };
      GLTFParser.prototype.getDependency = function(type, index) {
        var cacheKey = type + ":" + index;
        var dependency = this.cache.get(cacheKey);
        if (!dependency) {
          switch (type) {
            case "scene":
              dependency = this.loadScene(index);
              break;
            case "node":
              dependency = this.loadNode(index);
              break;
            case "mesh":
              dependency = this._invokeOne(function(ext) {
                return ext.loadMesh && ext.loadMesh(index);
              });
              break;
            case "accessor":
              dependency = this.loadAccessor(index);
              break;
            case "bufferView":
              dependency = this._invokeOne(function(ext) {
                return ext.loadBufferView && ext.loadBufferView(index);
              });
              break;
            case "buffer":
              dependency = this.loadBuffer(index);
              break;
            case "material":
              dependency = this._invokeOne(function(ext) {
                return ext.loadMaterial && ext.loadMaterial(index);
              });
              break;
            case "texture":
              dependency = this._invokeOne(function(ext) {
                return ext.loadTexture && ext.loadTexture(index);
              });
              break;
            case "skin":
              dependency = this.loadSkin(index);
              break;
            case "animation":
              dependency = this.loadAnimation(index);
              break;
            case "camera":
              dependency = this.loadCamera(index);
              break;
            case "light":
              dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
              break;
            default:
              throw new Error("Unknown type: " + type);
          }
          this.cache.add(cacheKey, dependency);
        }
        return dependency;
      };
      GLTFParser.prototype.getDependencies = function(type) {
        var dependencies = this.cache.get(type);
        if (!dependencies) {
          var parser = this;
          var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
          dependencies = Promise.all(defs.map(function(def, index) {
            return parser.getDependency(type, index);
          }));
          this.cache.add(type, dependencies);
        }
        return dependencies;
      };
      GLTFParser.prototype.loadBuffer = function(bufferIndex) {
        var bufferDef = this.json.buffers[bufferIndex];
        var loader = this.fileLoader;
        if (bufferDef.type && bufferDef.type !== "arraybuffer") {
          throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
        }
        if (bufferDef.uri === void 0 && bufferIndex === 0) {
          return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        }
        var options2 = this.options;
        return new Promise(function(resolve2, reject) {
          loader.load(resolveURL(bufferDef.uri, options2.path), resolve2, void 0, function() {
            reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
          });
        });
      };
      GLTFParser.prototype.loadBufferView = function(bufferViewIndex) {
        var bufferViewDef = this.json.bufferViews[bufferViewIndex];
        return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
          var byteLength = bufferViewDef.byteLength || 0;
          var byteOffset = bufferViewDef.byteOffset || 0;
          return buffer.slice(byteOffset, byteOffset + byteLength);
        });
      };
      GLTFParser.prototype.loadAccessor = function(accessorIndex) {
        var parser = this;
        var json = this.json;
        var accessorDef = this.json.accessors[accessorIndex];
        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
          return Promise.resolve(null);
        }
        var pendingBufferViews = [];
        if (accessorDef.bufferView !== void 0) {
          pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
        } else {
          pendingBufferViews.push(null);
        }
        if (accessorDef.sparse !== void 0) {
          pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
          pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
        }
        return Promise.all(pendingBufferViews).then(function(bufferViews) {
          var bufferView = bufferViews[0];
          var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
          var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          var elementBytes = TypedArray.BYTES_PER_ELEMENT;
          var itemBytes = elementBytes * itemSize;
          var byteOffset = accessorDef.byteOffset || 0;
          var byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
          var normalized = accessorDef.normalized === true;
          var array, bufferAttribute;
          if (byteStride && byteStride !== itemBytes) {
            var ibSlice = Math.floor(byteOffset / byteStride);
            var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
            var ib = parser.cache.get(ibCacheKey);
            if (!ib) {
              array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
              ib = new InterleavedBuffer(array, byteStride / elementBytes);
              parser.cache.add(ibCacheKey, ib);
            }
            bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
          } else {
            if (bufferView === null) {
              array = new TypedArray(accessorDef.count * itemSize);
            } else {
              array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
            }
            bufferAttribute = new BufferAttribute(array, itemSize, normalized);
          }
          if (accessorDef.sparse !== void 0) {
            var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
            var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
            var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
            var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
            var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
            var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
            if (bufferView !== null) {
              bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
            }
            for (var i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
              var index = sparseIndices[i2];
              bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
              if (itemSize >= 2)
                bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
              if (itemSize >= 3)
                bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
              if (itemSize >= 4)
                bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
              if (itemSize >= 5)
                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
            }
          }
          return bufferAttribute;
        });
      };
      GLTFParser.prototype.loadTexture = function(textureIndex) {
        var parser = this;
        var json = this.json;
        var options2 = this.options;
        var textureDef = json.textures[textureIndex];
        var textureExtensions = textureDef.extensions || {};
        var source;
        if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
          source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
        } else {
          source = json.images[textureDef.source];
        }
        var loader;
        if (source.uri) {
          loader = options2.manager.getHandler(source.uri);
        }
        if (!loader) {
          loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader;
        }
        return this.loadTextureImage(textureIndex, source, loader);
      };
      GLTFParser.prototype.loadTextureImage = function(textureIndex, source, loader) {
        var parser = this;
        var json = this.json;
        var options2 = this.options;
        var textureDef = json.textures[textureIndex];
        var URL2 = self.URL || self.webkitURL;
        var sourceURI = source.uri;
        var isObjectURL = false;
        if (source.bufferView !== void 0) {
          sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
            isObjectURL = true;
            var blob = new Blob([bufferView], { type: source.mimeType });
            sourceURI = URL2.createObjectURL(blob);
            return sourceURI;
          });
        }
        return Promise.resolve(sourceURI).then(function(sourceURI2) {
          return new Promise(function(resolve2, reject) {
            var onLoad = resolve2;
            if (loader.isImageBitmapLoader === true) {
              onLoad = function(imageBitmap) {
                resolve2(new CanvasTexture(imageBitmap));
              };
            }
            loader.load(resolveURL(sourceURI2, options2.path), onLoad, void 0, reject);
          });
        }).then(function(texture) {
          if (isObjectURL === true) {
            URL2.revokeObjectURL(sourceURI);
          }
          texture.flipY = false;
          if (textureDef.name)
            texture.name = textureDef.name;
          if (source.mimeType in MIME_TYPE_FORMATS) {
            texture.format = MIME_TYPE_FORMATS[source.mimeType];
          }
          var samplers = json.samplers || {};
          var sampler = samplers[textureDef.sampler] || {};
          texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
          texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
          texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
          texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
          parser.associations.set(texture, {
            type: "textures",
            index: textureIndex
          });
          return texture;
        });
      };
      GLTFParser.prototype.assignTexture = function(materialParams, mapName, mapDef) {
        var parser = this;
        return this.getDependency("texture", mapDef.index).then(function(texture) {
          if (!texture.isCompressedTexture) {
            switch (mapName) {
              case "aoMap":
              case "emissiveMap":
              case "metalnessMap":
              case "normalMap":
              case "roughnessMap":
                texture.format = RGBFormat;
                break;
            }
          }
          if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
            console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
          }
          if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
            var transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
            if (transform) {
              var gltfReference = parser.associations.get(texture);
              texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
              parser.associations.set(texture, gltfReference);
            }
          }
          materialParams[mapName] = texture;
        });
      };
      GLTFParser.prototype.assignFinalMaterial = function(mesh) {
        var geometry = mesh.geometry;
        var material = mesh.material;
        var useVertexTangents = geometry.attributes.tangent !== void 0;
        var useVertexColors = geometry.attributes.color !== void 0;
        var useFlatShading = geometry.attributes.normal === void 0;
        var useSkinning = mesh.isSkinnedMesh === true;
        var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
        var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== void 0;
        if (mesh.isPoints) {
          var cacheKey = "PointsMaterial:" + material.uuid;
          var pointsMaterial = this.cache.get(cacheKey);
          if (!pointsMaterial) {
            pointsMaterial = new PointsMaterial();
            Material.prototype.copy.call(pointsMaterial, material);
            pointsMaterial.color.copy(material.color);
            pointsMaterial.map = material.map;
            pointsMaterial.sizeAttenuation = false;
            this.cache.add(cacheKey, pointsMaterial);
          }
          material = pointsMaterial;
        } else if (mesh.isLine) {
          var cacheKey = "LineBasicMaterial:" + material.uuid;
          var lineMaterial = this.cache.get(cacheKey);
          if (!lineMaterial) {
            lineMaterial = new LineBasicMaterial();
            Material.prototype.copy.call(lineMaterial, material);
            lineMaterial.color.copy(material.color);
            this.cache.add(cacheKey, lineMaterial);
          }
          material = lineMaterial;
        }
        if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
          var cacheKey = "ClonedMaterial:" + material.uuid + ":";
          if (material.isGLTFSpecularGlossinessMaterial)
            cacheKey += "specular-glossiness:";
          if (useSkinning)
            cacheKey += "skinning:";
          if (useVertexTangents)
            cacheKey += "vertex-tangents:";
          if (useVertexColors)
            cacheKey += "vertex-colors:";
          if (useFlatShading)
            cacheKey += "flat-shading:";
          if (useMorphTargets)
            cacheKey += "morph-targets:";
          if (useMorphNormals)
            cacheKey += "morph-normals:";
          var cachedMaterial = this.cache.get(cacheKey);
          if (!cachedMaterial) {
            cachedMaterial = material.clone();
            if (useSkinning)
              cachedMaterial.skinning = true;
            if (useVertexTangents)
              cachedMaterial.vertexTangents = true;
            if (useVertexColors)
              cachedMaterial.vertexColors = true;
            if (useFlatShading)
              cachedMaterial.flatShading = true;
            if (useMorphTargets)
              cachedMaterial.morphTargets = true;
            if (useMorphNormals)
              cachedMaterial.morphNormals = true;
            this.cache.add(cacheKey, cachedMaterial);
            this.associations.set(cachedMaterial, this.associations.get(material));
          }
          material = cachedMaterial;
        }
        if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
          geometry.setAttribute("uv2", geometry.attributes.uv);
        }
        if (material.normalScale && !useVertexTangents) {
          material.normalScale.y = -material.normalScale.y;
        }
        if (material.clearcoatNormalScale && !useVertexTangents) {
          material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;
        }
        mesh.material = material;
      };
      GLTFParser.prototype.getMaterialType = function() {
        return MeshStandardMaterial;
      };
      GLTFParser.prototype.loadMaterial = function(materialIndex) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var materialDef = json.materials[materialIndex];
        var materialType;
        var materialParams = {};
        var materialExtensions = materialDef.extensions || {};
        var pending = [];
        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          materialType = sgExtension.getMaterialType();
          pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
        } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
          var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
          materialType = kmuExtension.getMaterialType();
          pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
        } else {
          var metallicRoughness = materialDef.pbrMetallicRoughness || {};
          materialParams.color = new Color(1, 1, 1);
          materialParams.opacity = 1;
          if (Array.isArray(metallicRoughness.baseColorFactor)) {
            var array = metallicRoughness.baseColorFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (metallicRoughness.baseColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
          }
          materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
          materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
          if (metallicRoughness.metallicRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
            pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
          }
          materialType = this._invokeOne(function(ext) {
            return ext.getMaterialType && ext.getMaterialType(materialIndex);
          });
          pending.push(this._invokeAll(function(ext) {
            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
          }));
        }
        if (materialDef.doubleSided === true) {
          materialParams.side = DoubleSide;
        }
        var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
        if (alphaMode === ALPHA_MODES.BLEND) {
          materialParams.transparent = true;
          materialParams.depthWrite = false;
        } else {
          materialParams.transparent = false;
          if (alphaMode === ALPHA_MODES.MASK) {
            materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
          }
        }
        if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
          pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
          materialParams.normalScale = new Vector2(1, 1);
          if (materialDef.normalTexture.scale !== void 0) {
            materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
          }
        }
        if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
          pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
          if (materialDef.occlusionTexture.strength !== void 0) {
            materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
          }
        }
        if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
          materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
        }
        if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
          pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
        }
        return Promise.all(pending).then(function() {
          var material;
          if (materialType === GLTFMeshStandardSGMaterial) {
            material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
          } else {
            material = new materialType(materialParams);
          }
          if (materialDef.name)
            material.name = materialDef.name;
          if (material.map)
            material.map.encoding = sRGBEncoding;
          if (material.emissiveMap)
            material.emissiveMap.encoding = sRGBEncoding;
          assignExtrasToUserData(material, materialDef);
          parser.associations.set(material, { type: "materials", index: materialIndex });
          if (materialDef.extensions)
            addUnknownExtensionsToUserData(extensions, material, materialDef);
          return material;
        });
      };
      function computeBounds(geometry, primitiveDef, parser) {
        var attributes = primitiveDef.attributes;
        var box = new Box3();
        if (attributes.POSITION !== void 0) {
          var accessor = parser.json.accessors[attributes.POSITION];
          var min = accessor.min;
          var max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else {
          return;
        }
        var targets = primitiveDef.targets;
        if (targets !== void 0) {
          var maxDisplacement = new Vector3();
          var vector = new Vector3();
          for (var i2 = 0, il = targets.length; i2 < il; i2++) {
            var target = targets[i2];
            if (target.POSITION !== void 0) {
              var accessor = parser.json.accessors[target.POSITION];
              var min = accessor.min;
              var max = accessor.max;
              if (min !== void 0 && max !== void 0) {
                vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
                maxDisplacement.max(vector);
              } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
              }
            }
          }
          box.expandByVector(maxDisplacement);
        }
        geometry.boundingBox = box;
        var sphere = new Sphere();
        box.getCenter(sphere.center);
        sphere.radius = box.min.distanceTo(box.max) / 2;
        geometry.boundingSphere = sphere;
      }
      function addPrimitiveAttributes(geometry, primitiveDef, parser) {
        var attributes = primitiveDef.attributes;
        var pending = [];
        function assignAttributeAccessor(accessorIndex, attributeName) {
          return parser.getDependency("accessor", accessorIndex).then(function(accessor2) {
            geometry.setAttribute(attributeName, accessor2);
          });
        }
        for (var gltfAttributeName in attributes) {
          var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
          if (threeAttributeName in geometry.attributes)
            continue;
          pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
        }
        if (primitiveDef.indices !== void 0 && !geometry.index) {
          var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
            geometry.setIndex(accessor2);
          });
          pending.push(accessor);
        }
        assignExtrasToUserData(geometry, primitiveDef);
        computeBounds(geometry, primitiveDef, parser);
        return Promise.all(pending).then(function() {
          return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
        });
      }
      function toTrianglesDrawMode(geometry, drawMode) {
        var index = geometry.getIndex();
        if (index === null) {
          var indices = [];
          var position = geometry.getAttribute("position");
          if (position !== void 0) {
            for (var i2 = 0; i2 < position.count; i2++) {
              indices.push(i2);
            }
            geometry.setIndex(indices);
            index = geometry.getIndex();
          } else {
            console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
            return geometry;
          }
        }
        var numberOfTriangles = index.count - 2;
        var newIndices = [];
        if (drawMode === TriangleFanDrawMode) {
          for (var i2 = 1; i2 <= numberOfTriangles; i2++) {
            newIndices.push(index.getX(0));
            newIndices.push(index.getX(i2));
            newIndices.push(index.getX(i2 + 1));
          }
        } else {
          for (var i2 = 0; i2 < numberOfTriangles; i2++) {
            if (i2 % 2 === 0) {
              newIndices.push(index.getX(i2));
              newIndices.push(index.getX(i2 + 1));
              newIndices.push(index.getX(i2 + 2));
            } else {
              newIndices.push(index.getX(i2 + 2));
              newIndices.push(index.getX(i2 + 1));
              newIndices.push(index.getX(i2));
            }
          }
        }
        if (newIndices.length / 3 !== numberOfTriangles) {
          console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        }
        var newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        return newGeometry;
      }
      GLTFParser.prototype.loadGeometries = function(primitives) {
        var parser = this;
        var extensions = this.extensions;
        var cache = this.primitiveCache;
        function createDracoPrimitive(primitive2) {
          return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive2, parser).then(function(geometry) {
            return addPrimitiveAttributes(geometry, primitive2, parser);
          });
        }
        var pending = [];
        for (var i2 = 0, il = primitives.length; i2 < il; i2++) {
          var primitive = primitives[i2];
          var cacheKey = createPrimitiveKey(primitive);
          var cached = cache[cacheKey];
          if (cached) {
            pending.push(cached.promise);
          } else {
            var geometryPromise;
            if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
              geometryPromise = createDracoPrimitive(primitive);
            } else {
              geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
            }
            cache[cacheKey] = { primitive, promise: geometryPromise };
            pending.push(geometryPromise);
          }
        }
        return Promise.all(pending);
      };
      GLTFParser.prototype.loadMesh = function(meshIndex) {
        var parser = this;
        var json = this.json;
        var meshDef = json.meshes[meshIndex];
        var primitives = meshDef.primitives;
        var pending = [];
        for (var i2 = 0, il = primitives.length; i2 < il; i2++) {
          var material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
          pending.push(material);
        }
        pending.push(parser.loadGeometries(primitives));
        return Promise.all(pending).then(function(results) {
          var materials = results.slice(0, results.length - 1);
          var geometries = results[results.length - 1];
          var meshes = [];
          for (var i22 = 0, il2 = geometries.length; i22 < il2; i22++) {
            var geometry = geometries[i22];
            var primitive = primitives[i22];
            var mesh;
            var material2 = materials[i22];
            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
              mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material2) : new Mesh(geometry, material2);
              if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
                mesh.normalizeSkinWeights();
              }
              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
              } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
              }
            } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
              mesh = new LineSegments(geometry, material2);
            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
              mesh = new Line(geometry, material2);
            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
              mesh = new LineLoop(geometry, material2);
            } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
              mesh = new Points(geometry, material2);
            } else {
              throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
            }
            if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
              updateMorphTargets(mesh, meshDef);
            }
            mesh.name = meshDef.name || "mesh_" + meshIndex;
            if (geometries.length > 1)
              mesh.name += "_" + i22;
            assignExtrasToUserData(mesh, meshDef);
            parser.assignFinalMaterial(mesh);
            meshes.push(mesh);
          }
          if (meshes.length === 1) {
            return meshes[0];
          }
          var group = new Group();
          for (var i22 = 0, il2 = meshes.length; i22 < il2; i22++) {
            group.add(meshes[i22]);
          }
          return group;
        });
      };
      GLTFParser.prototype.loadCamera = function(cameraIndex) {
        var camera;
        var cameraDef = this.json.cameras[cameraIndex];
        var params = cameraDef[cameraDef.type];
        if (!params) {
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
          return;
        }
        if (cameraDef.type === "perspective") {
          camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
        } else if (cameraDef.type === "orthographic") {
          camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
        }
        if (cameraDef.name)
          camera.name = cameraDef.name;
        assignExtrasToUserData(camera, cameraDef);
        return Promise.resolve(camera);
      };
      GLTFParser.prototype.loadSkin = function(skinIndex) {
        var skinDef = this.json.skins[skinIndex];
        var skinEntry = { joints: skinDef.joints };
        if (skinDef.inverseBindMatrices === void 0) {
          return Promise.resolve(skinEntry);
        }
        return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
          skinEntry.inverseBindMatrices = accessor;
          return skinEntry;
        });
      };
      GLTFParser.prototype.loadAnimation = function(animationIndex) {
        var json = this.json;
        var animationDef = json.animations[animationIndex];
        var pendingNodes = [];
        var pendingInputAccessors = [];
        var pendingOutputAccessors = [];
        var pendingSamplers = [];
        var pendingTargets = [];
        for (var i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
          var channel = animationDef.channels[i2];
          var sampler = animationDef.samplers[channel.sampler];
          var target = channel.target;
          var name = target.node !== void 0 ? target.node : target.id;
          var input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
          var output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
          pendingNodes.push(this.getDependency("node", name));
          pendingInputAccessors.push(this.getDependency("accessor", input));
          pendingOutputAccessors.push(this.getDependency("accessor", output));
          pendingSamplers.push(sampler);
          pendingTargets.push(target);
        }
        return Promise.all([
          Promise.all(pendingNodes),
          Promise.all(pendingInputAccessors),
          Promise.all(pendingOutputAccessors),
          Promise.all(pendingSamplers),
          Promise.all(pendingTargets)
        ]).then(function(dependencies) {
          var nodes = dependencies[0];
          var inputAccessors = dependencies[1];
          var outputAccessors = dependencies[2];
          var samplers = dependencies[3];
          var targets = dependencies[4];
          var tracks = [];
          for (var i22 = 0, il2 = nodes.length; i22 < il2; i22++) {
            var node = nodes[i22];
            var inputAccessor = inputAccessors[i22];
            var outputAccessor = outputAccessors[i22];
            var sampler2 = samplers[i22];
            var target2 = targets[i22];
            if (node === void 0)
              continue;
            node.updateMatrix();
            node.matrixAutoUpdate = true;
            var TypedKeyframeTrack;
            switch (PATH_PROPERTIES[target2.path]) {
              case PATH_PROPERTIES.weights:
                TypedKeyframeTrack = NumberKeyframeTrack;
                break;
              case PATH_PROPERTIES.rotation:
                TypedKeyframeTrack = QuaternionKeyframeTrack;
                break;
              case PATH_PROPERTIES.position:
              case PATH_PROPERTIES.scale:
              default:
                TypedKeyframeTrack = VectorKeyframeTrack;
                break;
            }
            var targetName = node.name ? node.name : node.uuid;
            var interpolation = sampler2.interpolation !== void 0 ? INTERPOLATION[sampler2.interpolation] : InterpolateLinear;
            var targetNames = [];
            if (PATH_PROPERTIES[target2.path] === PATH_PROPERTIES.weights) {
              node.traverse(function(object) {
                if (object.isMesh === true && object.morphTargetInfluences) {
                  targetNames.push(object.name ? object.name : object.uuid);
                }
              });
            } else {
              targetNames.push(targetName);
            }
            var outputArray = outputAccessor.array;
            if (outputAccessor.normalized) {
              var scale;
              if (outputArray.constructor === Int8Array) {
                scale = 1 / 127;
              } else if (outputArray.constructor === Uint8Array) {
                scale = 1 / 255;
              } else if (outputArray.constructor == Int16Array) {
                scale = 1 / 32767;
              } else if (outputArray.constructor === Uint16Array) {
                scale = 1 / 65535;
              } else {
                throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
              }
              var scaled = new Float32Array(outputArray.length);
              for (var j = 0, jl = outputArray.length; j < jl; j++) {
                scaled[j] = outputArray[j] * scale;
              }
              outputArray = scaled;
            }
            for (var j = 0, jl = targetNames.length; j < jl; j++) {
              var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target2.path], inputAccessor.array, outputArray, interpolation);
              if (sampler2.interpolation === "CUBICSPLINE") {
                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                  return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
                };
                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
              }
              tracks.push(track);
            }
          }
          var name2 = animationDef.name ? animationDef.name : "animation_" + animationIndex;
          return new AnimationClip(name2, void 0, tracks);
        });
      };
      GLTFParser.prototype.loadNode = function(nodeIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var parser = this;
        var nodeDef = json.nodes[nodeIndex];
        return function() {
          var pending = [];
          if (nodeDef.mesh !== void 0) {
            pending.push(parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
              var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
              if (nodeDef.weights !== void 0) {
                node.traverse(function(o) {
                  if (!o.isMesh)
                    return;
                  for (var i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
                    o.morphTargetInfluences[i2] = nodeDef.weights[i2];
                  }
                });
              }
              return node;
            }));
          }
          if (nodeDef.camera !== void 0) {
            pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
              return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
            }));
          }
          if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== void 0) {
            var lightIndex = nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light;
            pending.push(parser.getDependency("light", lightIndex).then(function(light) {
              return parser._getNodeRef(parser.lightCache, lightIndex, light);
            }));
          }
          return Promise.all(pending);
        }().then(function(objects) {
          var node;
          if (nodeDef.isBone === true) {
            node = new Bone();
          } else if (objects.length > 1) {
            node = new Group();
          } else if (objects.length === 1) {
            node = objects[0];
          } else {
            node = new Object3D();
          }
          if (node !== objects[0]) {
            for (var i2 = 0, il = objects.length; i2 < il; i2++) {
              node.add(objects[i2]);
            }
          }
          if (nodeDef.name) {
            node.userData.name = nodeDef.name;
            node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);
          }
          assignExtrasToUserData(node, nodeDef);
          if (nodeDef.extensions)
            addUnknownExtensionsToUserData(extensions, node, nodeDef);
          if (nodeDef.matrix !== void 0) {
            var matrix = new Matrix4();
            matrix.fromArray(nodeDef.matrix);
            node.applyMatrix4(matrix);
          } else {
            if (nodeDef.translation !== void 0) {
              node.position.fromArray(nodeDef.translation);
            }
            if (nodeDef.rotation !== void 0) {
              node.quaternion.fromArray(nodeDef.rotation);
            }
            if (nodeDef.scale !== void 0) {
              node.scale.fromArray(nodeDef.scale);
            }
          }
          parser.associations.set(node, { type: "nodes", index: nodeIndex });
          return node;
        });
      };
      GLTFParser.prototype.loadScene = function() {
        function buildNodeHierachy(nodeId, parentObject, json, parser) {
          var nodeDef = json.nodes[nodeId];
          return parser.getDependency("node", nodeId).then(function(node) {
            if (nodeDef.skin === void 0)
              return node;
            var skinEntry;
            return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
              skinEntry = skin;
              var pendingJoints = [];
              for (var i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
                pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
              }
              return Promise.all(pendingJoints);
            }).then(function(jointNodes) {
              node.traverse(function(mesh) {
                if (!mesh.isMesh)
                  return;
                var bones = [];
                var boneInverses = [];
                for (var j = 0, jl = jointNodes.length; j < jl; j++) {
                  var jointNode = jointNodes[j];
                  if (jointNode) {
                    bones.push(jointNode);
                    var mat = new Matrix4();
                    if (skinEntry.inverseBindMatrices !== void 0) {
                      mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                    }
                    boneInverses.push(mat);
                  } else {
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                  }
                }
                mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
              });
              return node;
            });
          }).then(function(node) {
            parentObject.add(node);
            var pending = [];
            if (nodeDef.children) {
              var children = nodeDef.children;
              for (var i2 = 0, il = children.length; i2 < il; i2++) {
                var child = children[i2];
                pending.push(buildNodeHierachy(child, node, json, parser));
              }
            }
            return Promise.all(pending);
          });
        }
        return function loadScene(sceneIndex) {
          var json = this.json;
          var extensions = this.extensions;
          var sceneDef = this.json.scenes[sceneIndex];
          var parser = this;
          var scene = new Group();
          if (sceneDef.name)
            scene.name = sceneDef.name;
          assignExtrasToUserData(scene, sceneDef);
          if (sceneDef.extensions)
            addUnknownExtensionsToUserData(extensions, scene, sceneDef);
          var nodeIds = sceneDef.nodes || [];
          var pending = [];
          for (var i2 = 0, il = nodeIds.length; i2 < il; i2++) {
            pending.push(buildNodeHierachy(nodeIds[i2], scene, json, parser));
          }
          return Promise.all(pending).then(function() {
            return scene;
          });
        };
      }();
      return GLTFLoader;
    })();
    DRACOLoader = function(manager) {
      Loader.call(this, manager);
      this.decoderPath = "";
      this.decoderConfig = {};
      this.decoderBinary = null;
      this.decoderPending = null;
      this.workerLimit = 4;
      this.workerPool = [];
      this.workerNextTaskID = 1;
      this.workerSourceURL = "";
      this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD"
      };
      this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array"
      };
    };
    DRACOLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: DRACOLoader,
      setDecoderPath: function(path) {
        this.decoderPath = path;
        return this;
      },
      setDecoderConfig: function(config) {
        this.decoderConfig = config;
        return this;
      },
      setWorkerLimit: function(workerLimit) {
        this.workerLimit = workerLimit;
        return this;
      },
      setVerbosity: function() {
        console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.");
      },
      setDrawMode: function() {
        console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.");
      },
      setSkipDequantization: function() {
        console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.");
      },
      load: function(url, onLoad, onProgress, onError) {
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        if (this.crossOrigin === "use-credentials") {
          loader.setWithCredentials(true);
        }
        loader.load(url, (buffer) => {
          var taskConfig = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: false
          };
          this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);
        }, onProgress, onError);
      },
      decodeDracoFile: function(buffer, callback, attributeIDs, attributeTypes) {
        var taskConfig = {
          attributeIDs: attributeIDs || this.defaultAttributeIDs,
          attributeTypes: attributeTypes || this.defaultAttributeTypes,
          useUniqueIDs: !!attributeIDs
        };
        this.decodeGeometry(buffer, taskConfig).then(callback);
      },
      decodeGeometry: function(buffer, taskConfig) {
        for (var attribute in taskConfig.attributeTypes) {
          var type = taskConfig.attributeTypes[attribute];
          if (type.BYTES_PER_ELEMENT !== void 0) {
            taskConfig.attributeTypes[attribute] = type.name;
          }
        }
        var taskKey = JSON.stringify(taskConfig);
        if (DRACOLoader.taskCache.has(buffer)) {
          var cachedTask = DRACOLoader.taskCache.get(buffer);
          if (cachedTask.key === taskKey) {
            return cachedTask.promise;
          } else if (buffer.byteLength === 0) {
            throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
          }
        }
        var worker;
        var taskID = this.workerNextTaskID++;
        var taskCost = buffer.byteLength;
        var geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
          worker = _worker;
          return new Promise((resolve2, reject) => {
            worker._callbacks[taskID] = { resolve: resolve2, reject };
            worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
          });
        }).then((message) => this._createGeometry(message.geometry));
        geometryPending.catch(() => true).then(() => {
          if (worker && taskID) {
            this._releaseTask(worker, taskID);
          }
        });
        DRACOLoader.taskCache.set(buffer, {
          key: taskKey,
          promise: geometryPending
        });
        return geometryPending;
      },
      _createGeometry: function(geometryData) {
        var geometry = new BufferGeometry();
        if (geometryData.index) {
          geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
        }
        for (var i2 = 0; i2 < geometryData.attributes.length; i2++) {
          var attribute = geometryData.attributes[i2];
          var name = attribute.name;
          var array = attribute.array;
          var itemSize = attribute.itemSize;
          geometry.setAttribute(name, new BufferAttribute(array, itemSize));
        }
        return geometry;
      },
      _loadLibrary: function(url, responseType) {
        var loader = new FileLoader(this.manager);
        loader.setPath(this.decoderPath);
        loader.setResponseType(responseType);
        return new Promise((resolve2, reject) => {
          loader.load(url, resolve2, void 0, reject);
        });
      },
      preload: function() {
        this._initDecoder();
        return this;
      },
      _initDecoder: function() {
        if (this.decoderPending)
          return this.decoderPending;
        var useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
        var librariesPending = [];
        if (useJS) {
          librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
        } else {
          librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
          librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
        }
        this.decoderPending = Promise.all(librariesPending).then((libraries) => {
          var jsContent = libraries[0];
          if (!useJS) {
            this.decoderConfig.wasmBinary = libraries[1];
          }
          var fn = DRACOLoader.DRACOWorker.toString();
          var body = [
            "/* draco decoder */",
            jsContent,
            "",
            "/* worker */",
            fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
          ].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        });
        return this.decoderPending;
      },
      _getWorker: function(taskID, taskCost) {
        return this._initDecoder().then(() => {
          if (this.workerPool.length < this.workerLimit) {
            var worker = new Worker(this.workerSourceURL);
            worker._callbacks = {};
            worker._taskCosts = {};
            worker._taskLoad = 0;
            worker.postMessage({ type: "init", decoderConfig: this.decoderConfig });
            worker.onmessage = function(e2) {
              var message = e2.data;
              switch (message.type) {
                case "decode":
                  worker._callbacks[message.id].resolve(message);
                  break;
                case "error":
                  worker._callbacks[message.id].reject(message);
                  break;
                default:
                  console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
              }
            };
            this.workerPool.push(worker);
          } else {
            this.workerPool.sort(function(a, b) {
              return a._taskLoad > b._taskLoad ? -1 : 1;
            });
          }
          var worker = this.workerPool[this.workerPool.length - 1];
          worker._taskCosts[taskID] = taskCost;
          worker._taskLoad += taskCost;
          return worker;
        });
      },
      _releaseTask: function(worker, taskID) {
        worker._taskLoad -= worker._taskCosts[taskID];
        delete worker._callbacks[taskID];
        delete worker._taskCosts[taskID];
      },
      debug: function() {
        console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
      },
      dispose: function() {
        for (var i2 = 0; i2 < this.workerPool.length; ++i2) {
          this.workerPool[i2].terminate();
        }
        this.workerPool.length = 0;
        return this;
      }
    });
    DRACOLoader.DRACOWorker = function() {
      var decoderConfig;
      var decoderPending;
      onmessage = function(e2) {
        var message = e2.data;
        switch (message.type) {
          case "init":
            decoderConfig = message.decoderConfig;
            decoderPending = new Promise(function(resolve2) {
              decoderConfig.onModuleLoaded = function(draco) {
                resolve2({ draco });
              };
              DracoDecoderModule(decoderConfig);
            });
            break;
          case "decode":
            var buffer = message.buffer;
            var taskConfig = message.taskConfig;
            decoderPending.then((module2) => {
              var draco = module2.draco;
              var decoder = new draco.Decoder();
              var decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
              try {
                var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                var buffers = geometry.attributes.map((attr) => attr.array.buffer);
                if (geometry.index)
                  buffers.push(geometry.index.array.buffer);
                self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
              } catch (error2) {
                console.error(error2);
                self.postMessage({ type: "error", id: message.id, error: error2.message });
              } finally {
                draco.destroy(decoderBuffer);
                draco.destroy(decoder);
              }
            });
            break;
        }
      };
      function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
        var attributeIDs = taskConfig.attributeIDs;
        var attributeTypes = taskConfig.attributeTypes;
        var dracoGeometry;
        var decodingStatus;
        var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
        if (geometryType === draco.TRIANGULAR_MESH) {
          dracoGeometry = new draco.Mesh();
          decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
        } else if (geometryType === draco.POINT_CLOUD) {
          dracoGeometry = new draco.PointCloud();
          decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
        } else {
          throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        }
        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
          throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
        }
        var geometry = { index: null, attributes: [] };
        for (var attributeName in attributeIDs) {
          var attributeType = self[attributeTypes[attributeName]];
          var attribute;
          var attributeID;
          if (taskConfig.useUniqueIDs) {
            attributeID = attributeIDs[attributeName];
            attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
          } else {
            attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
            if (attributeID === -1)
              continue;
            attribute = decoder.GetAttribute(dracoGeometry, attributeID);
          }
          geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
        }
        if (geometryType === draco.TRIANGULAR_MESH) {
          var numFaces = dracoGeometry.num_faces();
          var numIndices = numFaces * 3;
          var index = new Uint32Array(numIndices);
          var indexArray = new draco.DracoInt32Array();
          for (var i2 = 0; i2 < numFaces; ++i2) {
            decoder.GetFaceFromMesh(dracoGeometry, i2, indexArray);
            for (var j = 0; j < 3; ++j) {
              index[i2 * 3 + j] = indexArray.GetValue(j);
            }
          }
          geometry.index = { array: index, itemSize: 1 };
          draco.destroy(indexArray);
        }
        draco.destroy(dracoGeometry);
        return geometry;
      }
      function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
        var numComponents = attribute.num_components();
        var numPoints = dracoGeometry.num_points();
        var numValues = numPoints * numComponents;
        var dracoArray;
        var array;
        switch (attributeType) {
          case Float32Array:
            dracoArray = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Float32Array(numValues);
            break;
          case Int8Array:
            dracoArray = new draco.DracoInt8Array();
            decoder.GetAttributeInt8ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int8Array(numValues);
            break;
          case Int16Array:
            dracoArray = new draco.DracoInt16Array();
            decoder.GetAttributeInt16ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int16Array(numValues);
            break;
          case Int32Array:
            dracoArray = new draco.DracoInt32Array();
            decoder.GetAttributeInt32ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int32Array(numValues);
            break;
          case Uint8Array:
            dracoArray = new draco.DracoUInt8Array();
            decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint8Array(numValues);
            break;
          case Uint16Array:
            dracoArray = new draco.DracoUInt16Array();
            decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint16Array(numValues);
            break;
          case Uint32Array:
            dracoArray = new draco.DracoUInt32Array();
            decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint32Array(numValues);
            break;
          default:
            throw new Error("THREE.DRACOLoader: Unexpected attribute type.");
        }
        for (var i2 = 0; i2 < numValues; i2++) {
          array[i2] = dracoArray.GetValue(i2);
        }
        draco.destroy(dracoArray);
        return {
          name: attributeName,
          array,
          itemSize: numComponents
        };
      }
    };
    DRACOLoader.taskCache = new WeakMap();
    DRACOLoader.setDecoderPath = function() {
      console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.");
    };
    DRACOLoader.setDecoderConfig = function() {
      console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.");
    };
    DRACOLoader.releaseDecoderModule = function() {
      console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.");
    };
    DRACOLoader.getDecoderModule = function() {
      console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.");
    };
    OrbitControls = function(object, domElement) {
      if (domElement === void 0)
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
      if (domElement === document)
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      this.object = object;
      this.domElement = domElement;
      this.enabled = true;
      this.target = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = true;
      this.keyPanSpeed = 7;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.enableKeys = true;
      this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
      this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
      this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);
        scope.update();
        state = STATE.NONE;
      };
      this.update = function() {
        var offset = new Vector3();
        var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        var quatInverse = quat.clone().inverse();
        var lastPosition = new Vector3();
        var lastQuaternion = new Quaternion();
        var twoPI = 2 * Math.PI;
        return function update() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          var min = scope.minAzimuthAngle;
          var max = scope.maxAzimuthAngle;
          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI)
              min += twoPI;
            else if (min > Math.PI)
              min -= twoPI;
            if (max < -Math.PI)
              max += twoPI;
            else if (max > Math.PI)
              max -= twoPI;
            if (min < max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, false);
        scope.domElement.removeEventListener("mousedown", onMouseDown, false);
        scope.domElement.removeEventListener("wheel", onMouseWheel, false);
        scope.domElement.removeEventListener("touchstart", onTouchStart, false);
        scope.domElement.removeEventListener("touchend", onTouchEnd, false);
        scope.domElement.removeEventListener("touchmove", onTouchMove, false);
        scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove, false);
        scope.domElement.ownerDocument.removeEventListener("mouseup", onMouseUp, false);
        scope.domElement.removeEventListener("keydown", onKeyDown, false);
      };
      var scope = this;
      var changeEvent = { type: "change" };
      var startEvent = { type: "start" };
      var endEvent = { type: "end" };
      var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      var state = STATE.NONE;
      var EPS = 1e-6;
      var spherical = new Spherical();
      var sphericalDelta = new Spherical();
      var scale = 1;
      var panOffset = new Vector3();
      var zoomChanged = false;
      var rotateStart = new Vector2();
      var rotateEnd = new Vector2();
      var rotateDelta = new Vector2();
      var panStart = new Vector2();
      var panEnd = new Vector2();
      var panDelta = new Vector2();
      var dollyStart = new Vector2();
      var dollyEnd = new Vector2();
      var dollyDelta = new Vector2();
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      var panLeft = function() {
        var v = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.multiplyScalar(-distance);
          panOffset.add(v);
        };
      }();
      var panUp = function() {
        var v = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.crossVectors(scope.object.up, v);
          }
          v.multiplyScalar(distance);
          panOffset.add(v);
        };
      }();
      var pan = function() {
        var offset = new Vector3();
        return function pan2(deltaX, deltaY) {
          var element = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            var targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
      }
      function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale());
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseWheel(event) {
        if (event.deltaY < 0) {
          dollyIn(getZoomScale());
        } else if (event.deltaY > 0) {
          dollyOut(getZoomScale());
        }
        scope.update();
      }
      function handleKeyDown(event) {
        var needsUpdate = false;
        switch (event.keyCode) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate(event) {
        if (event.touches.length == 1) {
          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        } else {
          var x2 = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
          var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
          rotateStart.set(x2, y);
        }
      }
      function handleTouchStartPan(event) {
        if (event.touches.length == 1) {
          panStart.set(event.touches[0].pageX, event.touches[0].pageY);
        } else {
          var x2 = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
          var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
          panStart.set(x2, y);
        }
      }
      function handleTouchStartDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan(event) {
        if (scope.enableZoom)
          handleTouchStartDolly(event);
        if (scope.enablePan)
          handleTouchStartPan(event);
      }
      function handleTouchStartDollyRotate(event) {
        if (scope.enableZoom)
          handleTouchStartDolly(event);
        if (scope.enableRotate)
          handleTouchStartRotate(event);
      }
      function handleTouchMoveRotate(event) {
        if (event.touches.length == 1) {
          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        } else {
          var x2 = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
          var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
          rotateEnd.set(x2, y);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event) {
        if (event.touches.length == 1) {
          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        } else {
          var x2 = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
          var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
          panEnd.set(x2, y);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }
      function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enablePan)
          handleTouchMovePan(event);
      }
      function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enableRotate)
          handleTouchMoveRotate(event);
      }
      function onMouseDown(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
        scope.domElement.focus ? scope.domElement.focus() : window.focus();
        var mouseAction;
        switch (event.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;
          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;
          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;
          default:
            mouseAction = -1;
        }
        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseDownDolly(event);
            state = STATE.DOLLY;
            break;
          case MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            }
            break;
          case MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove, false);
          scope.domElement.ownerDocument.addEventListener("mouseup", onMouseUp, false);
          scope.dispatchEvent(startEvent);
        }
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleMouseMoveRotate(event);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseMoveDolly(event);
            break;
          case STATE.PAN:
            if (scope.enablePan === false)
              return;
            handleMouseMovePan(event);
            break;
        }
      }
      function onMouseUp(event) {
        if (scope.enabled === false)
          return;
        scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove, false);
        scope.domElement.ownerDocument.removeEventListener("mouseup", onMouseUp, false);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
          return;
        event.preventDefault();
        event.stopPropagation();
        scope.dispatchEvent(startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false)
          return;
        handleKeyDown(event);
      }
      function onTouchStart(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
        switch (event.touches.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchStartRotate(event);
                state = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchStartPan(event);
                state = STATE.TOUCH_PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchStartDollyPan(event);
                state = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchStartDollyRotate(event);
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(startEvent);
        }
      }
      function onTouchMove(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchMoveRotate(event);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false)
              return;
            handleTouchMovePan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchMoveDollyPan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchMoveDollyRotate(event);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function onTouchEnd(event) {
        if (scope.enabled === false)
          return;
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onContextMenu(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu, false);
      scope.domElement.addEventListener("mousedown", onMouseDown, false);
      scope.domElement.addEventListener("wheel", onMouseWheel, false);
      scope.domElement.addEventListener("touchstart", onTouchStart, false);
      scope.domElement.addEventListener("touchend", onTouchEnd, false);
      scope.domElement.addEventListener("touchmove", onTouchMove, false);
      scope.domElement.addEventListener("keydown", onKeyDown, false);
      if (scope.domElement.tabIndex === -1) {
        scope.domElement.tabIndex = 0;
      }
      this.update();
    };
    OrbitControls.prototype = Object.create(EventDispatcher.prototype);
    OrbitControls.prototype.constructor = OrbitControls;
    MapControls = function(object, domElement) {
      OrbitControls.call(this, object, domElement);
      this.screenSpacePanning = false;
      this.mouseButtons.LEFT = MOUSE.PAN;
      this.mouseButtons.RIGHT = MOUSE.ROTATE;
      this.touches.ONE = TOUCH.PAN;
      this.touches.TWO = TOUCH.DOLLY_ROTATE;
    };
    MapControls.prototype = Object.create(EventDispatcher.prototype);
    MapControls.prototype.constructor = MapControls;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
        revision: REVISION
      } }));
    }
    UniversalPropIterator = class {
      constructor(obj) {
        this.obj = obj;
        obj["type"] ? this.objTypeStr = obj["type"] : (this.objTypeStr = "", console.info("SVELTHREE TODO > UniversalPropIterator > constructor : obj has no 'type' property, probably of type 'Material[]' or WebGLRenderer", obj));
        this.dlTarget = void 0;
      }
      setFromVector3OrArray(p) {
        this.props[p].constructor === Vector3 ? this.obj[p].copy(this.props[p]) : Array.isArray(this.props[p]) ? this.obj[p].set(this.props[p][0], this.props[p][1], this.props[p][2]) : null;
      }
      checkSetColor(p) {
        if (isArray(this.props[p])) {
          if (isValidArray3Prop(this.props[p])) {
            this.obj[p] = new Color(this.props[p][0], this.props[p][1], this.props[p][2]);
          } else {
            console.error("SVELTHREE > UniversalPropIterator > checkSetColor : Prop should be an Array of three (3) values!", p);
          }
        } else {
          this.obj[p] = new Color(this.props[p]);
        }
      }
      checkSetDlTarget(p) {
        this.props[p] === void 0 ? null : this.obj[p] = this.props[p].getEmpty();
      }
      tryPropsUpdate(props) {
        this.props = props;
        if (this.obj) {
          for (let p in this.props) {
            if (this.obj.hasOwnProperty(p)) {
              p === "scale" || p === "position" || p === "rotation" ? this.setFromVector3OrArray(p) : p === "color" ? this.checkSetColor(p) : p === "target" && this.objTypeStr === "DirectionalLight" ? this.checkSetDlTarget(p) : this.obj[p] = this.props[p];
            } else if (this.obj[p.toString()]) {
              p === "lookAt" && this.obj["lookAt"] ? this.props[p].constructor === Vector3 ? this.obj["lookAt"](this.props[p]) : Array.isArray(this.props[p]) ? this.obj["lookAt"](this.props[p][0], this.props[p][1], this.props[p][2]) : null : null;
            } else {
              console.error("SVELTHREE > " + this.objTypeStr + " : No such property in " + this.objTypeStr + "! : " + p.toString());
            }
          }
        }
        if (this.objTypeStr.includes("Material")) {
          this.obj["needsUpdate"] = true;
        }
      }
    };
    Object3DUtils = class {
      constructor(obj) {
        this.obj = obj;
      }
      tryPosUpdate(p) {
        this.obj ? p.constructor === Vector3 ? this.obj["position"].copy(p) : Array.isArray(p) && p.length === 3 ? this.obj["position"].set(p[0], p[1], p[2]) : console.error("SVELTHREE > Object3DUtils > prop " + p.toString() + " has to be an Array(3) or valid THREE.Vector3!", { obj: this.obj, p }) : null;
      }
      tryRotUpdate(p) {
        this.obj ? p.constructor === Euler ? this.obj["rotation"].copy(p) : Array.isArray(p) && p.length === 3 ? this.obj["rotation"].set(p[0], p[1], p[2]) : Array.isArray(p) && p.length === 4 ? this.obj["rotation"].set(p[0], p[1], p[2], p[3]) : console.error("SVELTHREE > Object3DUtils > prop " + p.toString() + " has to be Array(3 || 4) or valid THREE.Euler!", { obj: this.obj, p }) : null;
      }
      tryScaleUpdate(p) {
        this.obj ? p.constructor === Vector3 ? this.obj["scale"].copy(p) : Array.isArray(p) ? this.obj["scale"].set(p[0], p[1], p[2]) : console.error("SVELTHREE > Object3DUtils > prop " + p.toString() + " has to be an Array(3) or valid THREE.Vector3!", { obj: this.obj, p }) : null;
      }
      tryLookAtUpdate(p) {
        this.obj.lookAt ? p.constructor === Vector3 ? this.obj.lookAt(p) : Array.isArray(p) && p.length === 3 ? this.obj.lookAt(p[0], p[1], p[2]) : console.error("SVELTHREE > Object3DUtils > prop " + p.toString() + " has to be an Array(3) or valid THREE.Vector3!", { obj: this.obj, p }) : null;
      }
    };
    subscriber_queue2 = [];
    svelthreeStores = writable2([]);
    AnimationProp = class {
      constructor(fn) {
        this.fn = fn;
      }
      initiate(obj, ...args) {
        let initiatedFn;
        try {
          initiatedFn = this.fn(obj, args);
          if (!initiatedFn.hasOwnProperty("onStart")) {
            console.warn("SVELTHREE > Provided animation is missing 'onStart' function!", { animation: initiatedFn });
            throw new Error("SVELTHREE Exception (see warning above)");
          }
          if (!initiatedFn.hasOwnProperty("onDestroy")) {
            console.warn("SVELTHREE > Provided animation has no 'onDestroy' function!", { animation: initiatedFn });
            throw new Error("SVELTHREE Exception (see warning above)");
          }
        } catch (e2) {
          throw new Error("SVELTHREE Exception (see warning above), " + e2);
        }
        return initiatedFn;
      }
    };
    SvelthreeAnimationManager = class {
      constructor(animation, aniauto, obj, scene) {
        this.animation = animation;
        this.aniauto = aniauto;
        this.obj = obj;
        this.scene = scene;
      }
      handleCurrentSceneStatus(currentSceneActive) {
        currentSceneActive ? this.aniauto ? this.handleSceneActive() : null : this.handleSceneInActive();
      }
      handleSceneActive() {
        if (this.animationInitiated() === true) {
          this.tryOnSceneReactivated();
        } else {
          this.initiateAnimation();
        }
      }
      initiateAnimation() {
        !this.scene.userData.isActive ? console.warn("SVELTHREE > SvelthreeAnimationManager : initiateAnimation : You're about to initiate an animation in an inactive Scene!") : null;
        this.animation = this.animation.initiate(this.obj, ...arguments);
        console.info("SVELTHREE > SvelthreeAnimationManager > initiateAnimation : after initialization: this.animation:", this.animation);
        try {
          this.animation.onStart();
        } catch (e2) {
          throw new Error("SVELTHREE Exception, " + e2);
        }
      }
      tryOnSceneReactivated() {
        this.animation.onSceneReactivated ? this.animation.onSceneReactivated() : console.warn("SVELTHREE > SvelthreeAnimationManager > tryOnSceneReactivated : Animation couldn't be started, missing 'onSceneReactivated' method!");
      }
      handleSceneInActive() {
        if (this.animationInitiated() === true)
          ;
      }
      tryOnSceneDeactivated() {
        this.animation.onSceneDeactivated ? this.animation.onSceneDeactivated() : console.warn("SVELTHREE > SvelthreeAnimationManager > tryOnSceneDeactivated : Animation couldn't be stopped, missing 'onSceneDeactivated' method!");
      }
      startAni() {
        if (this.animationInitiated() === false) {
          this.initiateAnimation();
        } else {
          console.warn("SVELTHREE > SvelthreeAnimationManager > startAni : animation has already been initiated! 'animation': ", this.animation);
        }
      }
      destroyAnimation() {
        if (this.animation.hasOwnProperty("onDestroy")) {
          this.animation.onDestroy();
        } else {
          console.warn("SVELTHREE > SvelthreeAnimationManager > Unable to find 'onDestroy' method in 'animation': This may be a BUG in REPL and may be safe to ignore. Please check if your animation is running as intended and consider checking it in another environment. Contributions on this issue are welcome! : this.animation", this.animation);
        }
      }
      animationInitiated() {
        if (this.animationIsAnimationProp()) {
          return false;
        } else if (this.animationIsObject()) {
          return true;
        } else {
          console.warn("SVELTHREE > SvelthreeAnimationManager > animationInitiated? : 'animation': ", this.animation);
          throw new Error("SVELTHREE > SvelthreeAnimationManager > animationInitiated? : 'animation' prop is of unsupported type!");
        }
      }
      animationIsAnimationProp() {
        if (this.animation) {
          if (this.animation instanceof AnimationProp) {
            return true;
          }
        }
        return false;
      }
      animationIsObject() {
        if (this.animation) {
          if (typeof this.animation === "object") {
            return true;
          }
        }
        return false;
      }
      getAnimation() {
        return this.animation;
      }
    };
    SvelthreeAnimation = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { animationEnabled = void 0 } = $$props;
      let { animation = void 0 } = $$props;
      let { aniauto = void 0 } = $$props;
      let { obj = void 0 } = $$props;
      let { scene = void 0 } = $$props;
      let aniManager;
      function createAnimationManager() {
        if (!aniManager) {
          animation = new AnimationProp(animation);
          aniManager = new SvelthreeAnimationManager(animation, aniauto, obj, scene);
        }
      }
      let { currentSceneActive } = $$props;
      function getAnimation() {
        if (aniManager) {
          return aniManager.getAnimation();
        } else {
          console.error("SVELTHREE > SvelthreeAnimation > destroyAnimation : missing SvelthreeAnimationManager!", { aniManager });
          return void 0;
        }
      }
      function destroyAnimation() {
        if (aniManager) {
          aniManager.destroyAnimation();
        } else {
          if (animation && animationEnabled) {
            console.error("SVELTHREE > SvelthreeAnimation > destroyAnimation : missing SvelthreeAnimationManager!", { aniManager });
          }
        }
      }
      function startAni() {
        if (aniManager) {
          aniManager.startAni();
        } else {
          console.error("SVELTHREE > SvelthreeAnimation > destroyAnimation : missing SvelthreeAnimationManager!", { aniManager });
        }
      }
      if ($$props.animationEnabled === void 0 && $$bindings.animationEnabled && animationEnabled !== void 0)
        $$bindings.animationEnabled(animationEnabled);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.obj === void 0 && $$bindings.obj && obj !== void 0)
        $$bindings.obj(obj);
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.currentSceneActive === void 0 && $$bindings.currentSceneActive && currentSceneActive !== void 0)
        $$bindings.currentSceneActive(currentSceneActive);
      if ($$props.getAnimation === void 0 && $$bindings.getAnimation && getAnimation !== void 0)
        $$bindings.getAnimation(getAnimation);
      if ($$props.destroyAnimation === void 0 && $$bindings.destroyAnimation && destroyAnimation !== void 0)
        $$bindings.destroyAnimation(destroyAnimation);
      if ($$props.startAni === void 0 && $$bindings.startAni && startAni !== void 0)
        $$bindings.startAni(startAni);
      {
        animation && animationEnabled ? createAnimationManager() : null;
      }
      {
        if (currentSceneActive) {
          aniManager ? aniManager.handleCurrentSceneStatus(currentSceneActive) : null;
        }
      }
      return ``;
    });
    Camera = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let ani;
      let { scene } = $$props;
      let sti;
      if (scene) {
        if (scene.type === "Scene") {
          setSTI();
        } else {
          console.warn("SVELTHREE > Camera : You have to provide a valid 'scene' prop of type 'Scene'!", { scene });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      } else {
        console.warn("SVELTHREE > Camera : You have to provide a {scene} prop!", { scene });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      let { animation = void 0 } = $$props;
      let { aniauto = void 0 } = $$props;
      let { id = void 0 } = $$props;
      let { cam } = $$props;
      let object3DUtils;
      let camPropIterator;
      if (cam) {
        object3DUtils = new Object3DUtils(cam);
        camPropIterator = new UniversalPropIterator(cam);
      } else {
        console.warn("SVELTHREE > Camera : camera was not provided by parent component!", { cam });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      scene.add(cam);
      console.info("SVELTHREE > Camera : " + cam.type + " was added to scene!", { cam, scene, total: scene.children.length });
      cam.userData.id = id;
      cam.userData.isActive = false;
      cam.userData.indexInCameras = $svelthreeStores[sti].cameras.length;
      $svelthreeStores[sti].cameras.push({ camera: cam, id, isActive: false });
      let { pos = [0, 0, 2] } = $$props;
      let { rot = [0, 0, 0] } = $$props;
      let { lookAt = [0, 0, 0] } = $$props;
      let { matrix = void 0 } = $$props;
      let { props = void 0 } = $$props;
      let { fnOnMount = void 0 } = $$props;
      function setSTI() {
        if (scene.userData.sti >= 0) {
          sti = scene.userData.sti;
        } else {
          console.warn("SVELTHREE > Camera : Failed to set 'sti' from 'scene.userData.sti', 'sti' has to be >= 0!", {
            scene,
            userData: scene.userData,
            sti: scene.userData.sti
          });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      }
      function tryControlsUpdate() {
        $svelthreeStores["orbitcontrols"] ? $svelthreeStores["orbitcontrols"].update() : null;
      }
      let currentSceneActive = false;
      let animationEnabled = false;
      function removeCameraFromParent() {
        cam.parent.remove(cam);
      }
      function getCamera() {
        return $svelthreeStores[sti].cameras[cam.userData.indexInCameras].camera;
      }
      function getIndexInCameras() {
        return $svelthreeStores[sti].cameras[cam.userData.indexInCameras].camera.userData.indexInCameras;
      }
      function getSTI() {
        return sti;
      }
      function getScene() {
        return scene;
      }
      function getAnimation() {
        return ani.getAnimation();
      }
      function startAni() {
        ani.startAni();
      }
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.id === void 0 && $$bindings.id && id !== void 0)
        $$bindings.id(id);
      if ($$props.cam === void 0 && $$bindings.cam && cam !== void 0)
        $$bindings.cam(cam);
      if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
        $$bindings.pos(pos);
      if ($$props.rot === void 0 && $$bindings.rot && rot !== void 0)
        $$bindings.rot(rot);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.matrix === void 0 && $$bindings.matrix && matrix !== void 0)
        $$bindings.matrix(matrix);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.fnOnMount === void 0 && $$bindings.fnOnMount && fnOnMount !== void 0)
        $$bindings.fnOnMount(fnOnMount);
      if ($$props.removeCameraFromParent === void 0 && $$bindings.removeCameraFromParent && removeCameraFromParent !== void 0)
        $$bindings.removeCameraFromParent(removeCameraFromParent);
      if ($$props.getCamera === void 0 && $$bindings.getCamera && getCamera !== void 0)
        $$bindings.getCamera(getCamera);
      if ($$props.getIndexInCameras === void 0 && $$bindings.getIndexInCameras && getIndexInCameras !== void 0)
        $$bindings.getIndexInCameras(getIndexInCameras);
      if ($$props.getSTI === void 0 && $$bindings.getSTI && getSTI !== void 0)
        $$bindings.getSTI(getSTI);
      if ($$props.getScene === void 0 && $$bindings.getScene && getScene !== void 0)
        $$bindings.getScene(getScene);
      if ($$props.getAnimation === void 0 && $$bindings.getAnimation && getAnimation !== void 0)
        $$bindings.getAnimation(getAnimation);
      if ($$props.startAni === void 0 && $$bindings.startAni && startAni !== void 0)
        $$bindings.startAni(startAni);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          !matrix ? (object3DUtils.tryPosUpdate(pos), tryControlsUpdate()) : null;
        }
        {
          !matrix ? object3DUtils.tryRotUpdate(rot) : null;
        }
        {
          !matrix ? object3DUtils.tryLookAtUpdate(lookAt) : null;
        }
        {
          isValidMatrix4(matrix) ? (console.warn("SVELTHREE > Camera : Matrix provided, will ignore 'pos' or 'rot' props if any provided!"), tryMatrixUpdate$1()) : null;
        }
        {
          props ? Object.keys(props).length > 0 ? camPropIterator ? camPropIterator.tryPropsUpdate(props) : null : null : null;
        }
        currentSceneActive = $svelthreeStores[sti].scenes[scene.userData.indexInScenes].isActive;
        {
          animation ? animationEnabled = true : null;
        }
        $$rendered = `${validate_component(SvelthreeAnimation, "SvelthreeAnimation").$$render($$result, {
          animationEnabled,
          animation,
          aniauto,
          obj: cam,
          scene,
          this: ani,
          currentSceneActive
        }, {
          this: ($$value) => {
            ani = $$value;
            $$settled = false;
          },
          currentSceneActive: ($$value) => {
            currentSceneActive = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      $$unsubscribe_svelthreeStores();
      return $$rendered;
    });
    PerspectiveCamera_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { scene } = $$props;
      let { id = void 0 } = $$props;
      if (!id) {
        console.warn("SVELTHREE > PerspectiveCamera : you have to provide an 'id' prop (not empty String) for Cameras in order to assign them to a 'WebGLRenderer' component!", { id });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      let { animation = void 0 } = $$props;
      let { aniauto = false } = $$props;
      let { pos = void 0 } = $$props;
      let { rot = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { matrix = void 0 } = $$props;
      let { config = void 0 } = $$props;
      let { props = void 0 } = $$props;
      let cam;
      config && config.length > 0 ? cam = new PerspectiveCamera(...config) : cam = new PerspectiveCamera();
      let { helper = false } = $$props;
      let camHelper = void 0;
      function createHelper() {
        camHelper = new CameraHelper(cam);
        scene.add(camHelper);
        camHelper.visible = false;
        console.info("SVELTHREE > " + cam.type + " : HELPER added!", {
          camHelper,
          scene,
          total: scene.children.length
        });
      }
      function getHelper() {
        return camHelper;
      }
      function getId() {
        return id;
      }
      let camera;
      function getCamera() {
        return camera.getCamera();
      }
      function getIndexInCameras() {
        return camera.getIndexInCameras();
      }
      function getSTI() {
        return camera.getSTI();
      }
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.id === void 0 && $$bindings.id && id !== void 0)
        $$bindings.id(id);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
        $$bindings.pos(pos);
      if ($$props.rot === void 0 && $$bindings.rot && rot !== void 0)
        $$bindings.rot(rot);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.matrix === void 0 && $$bindings.matrix && matrix !== void 0)
        $$bindings.matrix(matrix);
      if ($$props.config === void 0 && $$bindings.config && config !== void 0)
        $$bindings.config(config);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.helper === void 0 && $$bindings.helper && helper !== void 0)
        $$bindings.helper(helper);
      if ($$props.getHelper === void 0 && $$bindings.getHelper && getHelper !== void 0)
        $$bindings.getHelper(getHelper);
      if ($$props.getId === void 0 && $$bindings.getId && getId !== void 0)
        $$bindings.getId(getId);
      if ($$props.getCamera === void 0 && $$bindings.getCamera && getCamera !== void 0)
        $$bindings.getCamera(getCamera);
      if ($$props.getIndexInCameras === void 0 && $$bindings.getIndexInCameras && getIndexInCameras !== void 0)
        $$bindings.getIndexInCameras(getIndexInCameras);
      if ($$props.getSTI === void 0 && $$bindings.getSTI && getSTI !== void 0)
        $$bindings.getSTI(getSTI);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          !camHelper && cam && helper ? createHelper() : null;
        }
        $$rendered = `${validate_component(Camera, "Camera").$$render($$result, {
          scene,
          cam,
          id,
          pos,
          rot,
          lookAt,
          matrix,
          props,
          animation,
          aniauto,
          this: camera
        }, {
          this: ($$value) => {
            camera = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      return $$rendered;
    });
    SvelthreeInteraction = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let { interactionEnabled } = $$props;
      let { parent } = $$props;
      let { sti } = $$props;
      let { obj } = $$props;
      let raycaster;
      let { dispatch } = $$props;
      let c;
      let lastPointerMoveEvent;
      function addListeners() {
        c.addEventListener("click", tryDispatch, false);
        c.addEventListener("pointerup", tryDispatch, false);
        c.addEventListener("pointerdown", tryDispatch, false);
      }
      function removeListeners() {
        c.removeEventListener("click", tryDispatch);
        c.removeEventListener("pointerup", tryDispatch);
        c.removeEventListener("pointerdown", tryDispatch);
      }
      let checks = {
        click: { check: dispatchOnIntersect },
        pointerup: { check: dispatchOnIntersect },
        pointerdown: { check: dispatchOnIntersect },
        pointermove: { check: dispatchAlways }
      };
      function tryDispatch(e2) {
        if (checks.hasOwnProperty(e2.type)) {
          checks[e2.type].check(e2);
        }
      }
      let isOverDispatched = false;
      let isOutDispatched = true;
      let raycasterData;
      function checkOverOut(e2) {
        if (intersects2()) {
          if (!isOverDispatched) {
            let pointerData = getPointerData(e2);
            mDispatch("pointerenter", {
              type: "pointerenter",
              target: obj,
              pointerData,
              raycasterData
            }, !!parent.onPointerEnter);
            mDispatch("pointerover", {
              type: "pointerover",
              target: obj,
              pointerData,
              raycasterData
            }, !!parent.onPointerOver);
            isOverDispatched = true;
            isOutDispatched = false;
          }
        } else {
          if (!isOutDispatched) {
            let pointerData = getPointerData(e2);
            mDispatch("pointerout", {
              type: "pointerout",
              target: obj,
              pointerData,
              raycasterData
            }, !!parent.onPointerOut);
            mDispatch("pointerleave", {
              type: "pointerleave",
              target: obj,
              pointerData,
              raycasterData
            }, !!parent.onPointerLeave);
            isOutDispatched = true;
            isOverDispatched = false;
          }
        }
      }
      function dispatchAlways(e2) {
        Object.keys(parent.$$.callbacks).includes("pointermove") ? dispatch(e2.type, {
          event: e2,
          target: obj,
          unprojected: $svelthreeStores[sti].pointer.unprojected
        }) : null;
        parent.onPointerMove ? onPointerMoveAction(new CustomEvent(e2.type, {
          detail: {
            event: e2,
            target: obj,
            unprojected: $svelthreeStores[sti].pointer.unprojected
          }
        })) : null;
      }
      function dispatchOnIntersect(e2) {
        if (intersects2()) {
          e2.type === "click" ? doDispatch(e2, !!parent.onClick) : null;
          e2.type === "pointerup" ? doDispatch(e2, !!parent.onPointerUp) : null;
          e2.type === "pointerdown" ? doDispatch(e2, !!parent.onPointerDown) : null;
        }
      }
      function doDispatch(e2, fireInternal) {
        let pointerData = getPointerData(e2);
        mDispatch(e2.type, {
          type: e2.type,
          target: obj,
          pointerData,
          raycasterData
        }, fireInternal);
      }
      function mDispatch(message, details, fireInternal) {
        dispatch(message, details);
        if (fireInternal) {
          let event = new CustomEvent(message, { detail: details });
          switch (message) {
            case "click":
              parent.onClick ? onClickAction(event) : null;
              break;
            case "pointerup":
              parent.onPointerUp ? onPointerUpAction(event) : null;
              break;
            case "pointerdown":
              parent.onPointerDown ? onPointerDownAction(event) : null;
              break;
            case "pointerover":
              parent.onPointerOver ? onPointerOverAction(event) : null;
              break;
            case "pointerout":
              parent.onPointerOut ? onPointerOutAction(event) : null;
              break;
            case "pointerenter":
              parent.onPointerOut ? onPointerEnterAction(event) : null;
              break;
            case "pointerleave":
              parent.onPointerLeave ? onPointerLeaveAction(event) : null;
              break;
          }
        }
      }
      function intersects2() {
        if ($svelthreeStores[sti].allIntersections) {
          if ($svelthreeStores[sti].allIntersections.length > 0 && $svelthreeStores[sti].allIntersections[0].object === obj) {
            let intersects3 = raycaster.intersectObject(obj);
            raycasterData = {
              intersections: intersects3,
              ray: raycaster.ray,
              camera: raycaster.camera,
              unprojectedPoint: new Vector3($svelthreeStores[sti].pointer.pos.x, $svelthreeStores[sti].pointer.pos.y, 0).unproject(raycaster.camera)
            };
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      function onClickAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction :internal onClickAction!");
        typeof parent.onClick === "function" ? parent.onClick(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onClick' object is not a valid function!");
      }
      function onPointerUpAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerUpAction!");
        typeof parent.onPointerUp === "function" ? parent.onPointerUp(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerUp' object is not a function!");
      }
      function onPointerDownAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerDownAction!");
        typeof parent.onPointerDown === "function" ? parent.onPointerDown(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerDown' object is not a function!");
      }
      function onPointerOverAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerOverAction!", e2);
        typeof parent.onPointerOver === "function" ? parent.onPointerOver(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerOver' object is not a function!");
      }
      function onPointerOutAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerOutAction!", e2);
        typeof parent.onPointerOut === "function" ? parent.onPointerOut(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerOut' object is not a function!");
      }
      function onPointerEnterAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerEnterAction!", e2);
        typeof parent.onPointerEnter === "function" ? parent.onPointerEnter(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerEnter' object is not a function!");
      }
      function onPointerLeaveAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerLeaveAction!", e2);
        typeof parent.onPointerLeave === "function" ? parent.onPointerLeave(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerLeave' object is not a function!");
      }
      function onPointerMoveAction(e2) {
        console.info("SVELTHREE > SvelthreeInteraction : internal onPointerMoveAction!");
        typeof parent.onPointerMove === "function" ? parent.onPointerMove(e2) : console.error("SVELTHREE > SvelthreeInteraction : provided 'onPointerMove' object is not a function!");
      }
      if ($$props.interactionEnabled === void 0 && $$bindings.interactionEnabled && interactionEnabled !== void 0)
        $$bindings.interactionEnabled(interactionEnabled);
      if ($$props.parent === void 0 && $$bindings.parent && parent !== void 0)
        $$bindings.parent(parent);
      if ($$props.sti === void 0 && $$bindings.sti && sti !== void 0)
        $$bindings.sti(sti);
      if ($$props.obj === void 0 && $$bindings.obj && obj !== void 0)
        $$bindings.obj(obj);
      if ($$props.dispatch === void 0 && $$bindings.dispatch && dispatch !== void 0)
        $$bindings.dispatch(dispatch);
      {
        $svelthreeStores[sti].raycaster ? raycaster = $svelthreeStores[sti].raycaster : null;
      }
      {
        $svelthreeStores[sti].canvas.dom ? c = $svelthreeStores[sti].canvas.dom : null;
      }
      {
        if (c) {
          if (interactionEnabled && obj && !obj.userData.interact) {
            addListeners();
            obj.userData.interact = true;
          } else if (!interactionEnabled && obj && obj.userData.interact) {
            removeListeners();
            obj.userData.interact = false;
          }
        }
      }
      {
        if (interactionEnabled) {
          if (obj && raycaster) {
            if ($svelthreeStores[sti].pointer.event !== lastPointerMoveEvent) {
              lastPointerMoveEvent = $svelthreeStores[sti].pointer.event;
              checkOverOut(lastPointerMoveEvent);
              tryDispatch(lastPointerMoveEvent);
            }
          }
        } else if (obj && obj.userData.interact) {
          obj.userData.interact = false;
          removeListeners();
        }
      }
      $$unsubscribe_svelthreeStores();
      return ``;
    });
    Mesh_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let ani;
      let self2 = get_current_component();
      let dispatch = createEventDispatcher();
      let { name = void 0 } = $$props;
      let { parent = void 0 } = $$props;
      let { parentForSlot = void 0 } = $$props;
      let { parentForUs = void 0 } = $$props;
      let { scene } = $$props;
      let { aniauto = void 0 } = $$props;
      let { interact = void 0 } = $$props;
      let sti;
      if (scene) {
        if (scene.type === "Scene") {
          setSTI();
        } else {
          console.warn("SVELTHREE > Mesh : You have to provide a valid 'scene' prop of type 'Scene'!", { scene });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      } else {
        console.warn("SVELTHREE > Mesh : You have to provide a {scene} prop!", { scene });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      let interactive = void 0;
      let generate = false;
      let { mesh = void 0 } = $$props;
      let object3DUtils;
      let meshPropIterator;
      let matPropIterator;
      let { material = void 0 } = $$props;
      let { geometry = void 0 } = $$props;
      mesh ? (generate = false, onMeshProvided()) : generate = true;
      function onMeshProvided() {
        if (mesh.type === "Mesh") {
          mesh.geometry ? geometry = mesh.geometry : null;
          mesh.material ? material = mesh.material : console.warn("SVELTHREE > Mesh : Mesh provided, but has no material!", { mesh });
          console.info("SVELTHREE > Mesh : Saved geometry:", { geometry });
          console.info("SVELTHREE > Mesh : Saved material:", { material });
          mesh.userData.initScale = mesh.scale.x, object3DUtils = new Object3DUtils(mesh);
          meshPropIterator = new UniversalPropIterator(mesh);
          material ? matPropIterator = new UniversalPropIterator(material) : null;
        }
      }
      if (!generate) {
        if (!parent) {
          parentForSlot = mesh;
        } else {
          if (parent !== mesh) {
            parentForUs = parent;
            parentForSlot = mesh;
          }
        }
      }
      function checkParentSlot() {
        if (generate) {
          if (mesh && !parent) {
            parentForSlot = mesh;
          } else {
            if (!mesh) {
              console.error("SVELTHREE > Mesh : 'parent' check : no mesh provided yet!");
            } else if (parent) {
              if (parent !== mesh) {
                parentForUs = parent;
                parentForSlot = mesh;
              }
            }
          }
        }
      }
      let { userData = void 0 } = $$props;
      function tryApplyUserData() {
        if (mesh) {
          mesh.userData = Object.assign(Object.assign({}, mesh.userData), userData);
        }
      }
      let { animation = void 0 } = $$props;
      let { mat = void 0 } = $$props;
      let { pos = void 0 } = $$props;
      let { rot = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { matrix = void 0 } = $$props;
      let { props = void 0 } = $$props;
      let currentSceneActive = false;
      let animationEnabled = false;
      let interactionEnabled = void 0;
      let { fnOnMount = void 0 } = $$props;
      function setSTI() {
        if (scene.userData.sti >= 0) {
          sti = scene.userData.sti;
        } else {
          console.warn("SVELTHREE > Mesh : Failed to set 'sti' from 'scene.userData.sti', 'sti' has to be >= 0!", {
            scene,
            userData: scene.userData,
            sti: scene.userData.sti
          });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      }
      function tryAddingMesh() {
        if (!parentForUs) {
          if (mesh.parent !== scene) {
            scene.add(mesh);
            console.info("SVELTHREE > Mesh : " + geometry.type + " was added to scene!", {
              mesh,
              scene,
              total: scene.children.length
            });
          }
        } else {
          if (mesh.parent !== parentForUs) {
            parentForUs.add(mesh);
            console.info("SVELTHREE > Mesh : " + geometry.type + " was added to parent!", {
              mesh,
              parent: parentForUs,
              scene,
              total: scene.children.length
            });
          }
        }
      }
      function tryMaterialUpdate() {
        mesh ? (mesh.material = material, console.info("SVELTHREE > Mesh : Material updated!"), matPropIterator ? matPropIterator.tryPropsUpdate(mat) : null) : null;
      }
      function tryGeometryUpdate() {
        mesh ? (mesh.geometry = geometry, console.info("SVELTHREE > Mesh : Geometry updated!")) : null;
      }
      function tryCastShadowUpdate() {
        mesh ? mesh.castShadow = castShadow : null;
      }
      function tryReceiveShadowUpdate() {
        mesh ? mesh.receiveShadow = receiveShadow : null;
      }
      function removeMeshFromParent() {
        mesh.parent.remove(mesh);
      }
      function getMesh() {
        return mesh;
      }
      function getName2() {
        return name;
      }
      function getScene() {
        return scene;
      }
      function getAnimation() {
        return ani.getAnimation();
      }
      function startAni() {
        ani.startAni();
      }
      let { onClick = void 0 } = $$props;
      let { onPointerUp = void 0 } = $$props;
      let { onPointerDown = void 0 } = $$props;
      let { onPointerOver = void 0 } = $$props;
      let { onPointerOut = void 0 } = $$props;
      let { onPointerEnter = void 0 } = $$props;
      let { onPointerLeave = void 0 } = $$props;
      let { onPointerMove = void 0 } = $$props;
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.parent === void 0 && $$bindings.parent && parent !== void 0)
        $$bindings.parent(parent);
      if ($$props.parentForSlot === void 0 && $$bindings.parentForSlot && parentForSlot !== void 0)
        $$bindings.parentForSlot(parentForSlot);
      if ($$props.parentForUs === void 0 && $$bindings.parentForUs && parentForUs !== void 0)
        $$bindings.parentForUs(parentForUs);
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.interact === void 0 && $$bindings.interact && interact !== void 0)
        $$bindings.interact(interact);
      if ($$props.mesh === void 0 && $$bindings.mesh && mesh !== void 0)
        $$bindings.mesh(mesh);
      if ($$props.material === void 0 && $$bindings.material && material !== void 0)
        $$bindings.material(material);
      if ($$props.geometry === void 0 && $$bindings.geometry && geometry !== void 0)
        $$bindings.geometry(geometry);
      if ($$props.userData === void 0 && $$bindings.userData && userData !== void 0)
        $$bindings.userData(userData);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.mat === void 0 && $$bindings.mat && mat !== void 0)
        $$bindings.mat(mat);
      if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
        $$bindings.pos(pos);
      if ($$props.rot === void 0 && $$bindings.rot && rot !== void 0)
        $$bindings.rot(rot);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.matrix === void 0 && $$bindings.matrix && matrix !== void 0)
        $$bindings.matrix(matrix);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.fnOnMount === void 0 && $$bindings.fnOnMount && fnOnMount !== void 0)
        $$bindings.fnOnMount(fnOnMount);
      if ($$props.removeMeshFromParent === void 0 && $$bindings.removeMeshFromParent && removeMeshFromParent !== void 0)
        $$bindings.removeMeshFromParent(removeMeshFromParent);
      if ($$props.getMesh === void 0 && $$bindings.getMesh && getMesh !== void 0)
        $$bindings.getMesh(getMesh);
      if ($$props.getName === void 0 && $$bindings.getName && getName2 !== void 0)
        $$bindings.getName(getName2);
      if ($$props.getScene === void 0 && $$bindings.getScene && getScene !== void 0)
        $$bindings.getScene(getScene);
      if ($$props.getAnimation === void 0 && $$bindings.getAnimation && getAnimation !== void 0)
        $$bindings.getAnimation(getAnimation);
      if ($$props.startAni === void 0 && $$bindings.startAni && startAni !== void 0)
        $$bindings.startAni(startAni);
      if ($$props.onClick === void 0 && $$bindings.onClick && onClick !== void 0)
        $$bindings.onClick(onClick);
      if ($$props.onPointerUp === void 0 && $$bindings.onPointerUp && onPointerUp !== void 0)
        $$bindings.onPointerUp(onPointerUp);
      if ($$props.onPointerDown === void 0 && $$bindings.onPointerDown && onPointerDown !== void 0)
        $$bindings.onPointerDown(onPointerDown);
      if ($$props.onPointerOver === void 0 && $$bindings.onPointerOver && onPointerOver !== void 0)
        $$bindings.onPointerOver(onPointerOver);
      if ($$props.onPointerOut === void 0 && $$bindings.onPointerOut && onPointerOut !== void 0)
        $$bindings.onPointerOut(onPointerOut);
      if ($$props.onPointerEnter === void 0 && $$bindings.onPointerEnter && onPointerEnter !== void 0)
        $$bindings.onPointerEnter(onPointerEnter);
      if ($$props.onPointerLeave === void 0 && $$bindings.onPointerLeave && onPointerLeave !== void 0)
        $$bindings.onPointerLeave(onPointerLeave);
      if ($$props.onPointerMove === void 0 && $$bindings.onPointerMove && onPointerMove !== void 0)
        $$bindings.onPointerMove(onPointerMove);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        interactive = $svelthreeStores[sti].canvas.interactive;
        {
          geometry && material && !mesh && generate ? (mesh = new Mesh(geometry, material), mesh.name = name, mesh.userData.initScale = mesh.scale.x, console.info("SVELTHREE > Mesh : " + geometry.type + " created!", { mesh }), console.info("SVELTHREE > Mesh : saved 'geometry' (generated):", geometry), console.info("SVELTHREE > Mesh : saved 'material' (generated):", material), object3DUtils = new Object3DUtils(mesh), meshPropIterator = new UniversalPropIterator(mesh)) : null;
        }
        {
          !matrix ? scale ? isValidArray3Prop(scale) ? (object3DUtils.tryScaleUpdate(scale), mesh.userData.initScale = mesh.scale.x) : null : null : null;
        }
        {
          mesh ? checkParentSlot() : null;
        }
        {
          geometry && generate ? (console.info("SVELTHREE > Mesh : Geometry provided!"), tryGeometryUpdate()) : null;
        }
        {
          material && generate ? (console.info("SVELTHREE > Mesh : Material provided!"), matPropIterator = new UniversalPropIterator(material), tryMaterialUpdate()) : null;
        }
        {
          geometry && !generate ? geometry !== mesh.geometry ? tryGeometryUpdate() : null : null;
        }
        {
          material && !generate ? material !== mesh.material ? tryMaterialUpdate() : null : null;
        }
        {
          mesh ? tryAddingMesh() : console.error("SVELTHREE > Mesh : mesh was not created!");
        }
        {
          userData ? tryApplyUserData() : null;
        }
        {
          !matrix ? pos ? isValidArray3Prop(pos) ? object3DUtils.tryPosUpdate(pos) : null : null : null;
        }
        {
          !matrix ? rot ? isValidArray3Prop(rot) ? object3DUtils.tryRotUpdate(rot) : null : null : null;
        }
        {
          isValidMatrix4(matrix) ? (console.warn("SVELTHREE > Mesh : Matrix provided, will ignore 'pos', 'rot' or 'scale' props if any provided!"), tryMatrixUpdate()) : null;
        }
        {
          castShadow ? tryCastShadowUpdate() : null;
        }
        {
          receiveShadow ? tryReceiveShadowUpdate() : null;
        }
        {
          props ? Object.keys(props).length > 0 ? meshPropIterator ? meshPropIterator.tryPropsUpdate(props) : null : null : null;
        }
        {
          mat ? Object.keys(mat).length > 0 ? matPropIterator ? (console.info("SVELTHREE > Mesh : matPropIterator is true: ", mat), matPropIterator.tryPropsUpdate(mat)) : null : null : null;
        }
        currentSceneActive = $svelthreeStores[sti].scenes[scene.userData.indexInScenes].isActive;
        {
          animation ? animationEnabled = true : null;
        }
        {
          interactive && interact ? interactionEnabled = true : interactionEnabled = false;
        }
        $$rendered = `


${slots.default ? slots.default({ scene, parent: parentForSlot }) : ``}

${validate_component(SvelthreeAnimation, "SvelthreeAnimation").$$render($$result, {
          animationEnabled,
          animation,
          aniauto,
          obj: mesh,
          scene,
          this: ani,
          currentSceneActive
        }, {
          this: ($$value) => {
            ani = $$value;
            $$settled = false;
          },
          currentSceneActive: ($$value) => {
            currentSceneActive = $$value;
            $$settled = false;
          }
        }, {})}
    

${validate_component(SvelthreeInteraction, "SvelthreeInteraction").$$render($$result, {
          sti,
          dispatch,
          obj: mesh,
          parent: self2,
          interactionEnabled
        }, {}, {})}`;
      } while (!$$settled);
      $$unsubscribe_svelthreeStores();
      return $$rendered;
    });
    Canvas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let { w } = $$props;
      let { h: h2 } = $$props;
      let { style = void 0 } = $$props;
      let { class: clazz = void 0 } = $$props;
      const svelthreeStoreBody = {
        id: void 0,
        canvas: {
          dom: void 0,
          dim: { w: void 0, h: void 0 },
          interactive: false
        },
        scenes: [],
        cameras: [],
        activeCamera: void 0,
        renderer: void 0,
        raycaster: void 0,
        allIntersections: void 0,
        pointer: {
          pos: new Vector2(-1, -1),
          event: void 0,
          isOverCanvas: false,
          unprojected: new Vector3()
        },
        orbitcontrols: void 0
      };
      svelthreeStoreBody.canvas.dim.w = w;
      svelthreeStoreBody.canvas.dim.h = h2;
      let sti;
      set_store_value(svelthreeStores, $svelthreeStores = [...$svelthreeStores, svelthreeStoreBody], $svelthreeStores);
      sti = $svelthreeStores.length - 1;
      let c;
      let { interactive = false } = $$props;
      function getCanvas() {
        return $svelthreeStores[sti].canvas.dom;
      }
      function getDimensions() {
        return {
          w: $svelthreeStores[sti].canvas.dom.width,
          h: $svelthreeStores[sti].canvas.dom.height
        };
      }
      function doResize(w2, h22) {
        set_store_value(svelthreeStores, $svelthreeStores[sti].canvas.dim = { w: w2, h: h22 }, $svelthreeStores);
      }
      if ($$props.w === void 0 && $$bindings.w && w !== void 0)
        $$bindings.w(w);
      if ($$props.h === void 0 && $$bindings.h && h2 !== void 0)
        $$bindings.h(h2);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.class === void 0 && $$bindings.class && clazz !== void 0)
        $$bindings.class(clazz);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.getCanvas === void 0 && $$bindings.getCanvas && getCanvas !== void 0)
        $$bindings.getCanvas(getCanvas);
      if ($$props.getDimensions === void 0 && $$bindings.getDimensions && getDimensions !== void 0)
        $$bindings.getDimensions(getDimensions);
      if ($$props.doResize === void 0 && $$bindings.doResize && doResize !== void 0)
        $$bindings.doResize(doResize);
      $$unsubscribe_svelthreeStores();
      return `<canvas${add_attribute("width", w, 0)}${add_attribute("height", h2, 0)}${add_attribute("style", style, 0)}${add_attribute("class", clazz, 0)}${add_attribute("this", c, 0)}>${slots.default ? slots.default({ sti }) : ``}</canvas>`;
    });
    LightUtils = class {
      constructor(light) {
        this.light = light;
      }
      tryIntensityUpdate(intensity) {
        console.info("SVELTHREE > LightUtils > tryIntensityUpdate ", intensity);
        this.light ? this.light.intensity = intensity : null;
      }
      tryColorUpdate(color) {
        console.info("color", color);
        this.light ? isArray(color) ? isValidArray3Prop(color) ? this.light.color = new Color(color[0], color[1], color[2]) : null : this.light.color = new Color(color) : null;
      }
      tryShadowMapSizeUpdate(shadowMapSize) {
        console.info("SVELTHREE > LightUtils > tryShadowMapSizeUpdate", shadowMapSize);
        this.light ? (this.light.shadow.mapSize.width = shadowMapSize, this.light.shadow.mapSize.height = shadowMapSize) : null;
      }
      tryShadowBiasUpdate(shadowBiasSize) {
        console.info("SVELTHREE > LightUtils > tryShadowBiasUpdate", shadowBiasSize);
        this.light ? (this.light.shadow.bias = shadowBiasSize, this.light.shadow.bias = shadowBiasSize) : null;
      }
      tryCastShadowUpdate(castShadow) {
        console.info("SVELTHREE > LightUtils > tryCastShadowUpdate", castShadow);
        this.light ? this.light.castShadow = castShadow : null;
      }
    };
    Light = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let ani;
      let { scene } = $$props;
      let sti;
      if (scene) {
        if (scene.type === "Scene") {
          setSTI();
        } else {
          console.warn("SVELTHREE > Light : You have to provide a valid 'scene' prop of type 'Scene'!", { scene });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      } else {
        console.warn("SVELTHREE > Light : You have to provide a {scene} prop!", { scene });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      function setSTI() {
        if (scene.userData.sti >= 0) {
          sti = scene.userData.sti;
        } else {
          console.warn("SVELTHREE > Light : Failed to set 'sti' from 'scene.userData.sti', 'sti' has to be >= 0!", {
            scene,
            userData: scene.userData,
            sti: scene.userData.sti
          });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      }
      let { animation = void 0 } = $$props;
      let { aniauto = void 0 } = $$props;
      let { parent = void 0 } = $$props;
      let { parentForUs = void 0 } = $$props;
      let { light = void 0 } = $$props;
      let lightUtils;
      let object3DUtils;
      let uniPropIterator;
      if (light) {
        object3DUtils = new Object3DUtils(light);
        uniPropIterator = new UniversalPropIterator(light);
        lightUtils = new LightUtils(light);
      } else {
        console.warn("SVELTHREE > Light : light was not provided by parent component!", { light });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      if (parent) {
        if (parent !== light) {
          parentForUs = parent;
        }
      }
      tryAddingLight();
      function tryAddingLight() {
        if (!parentForUs) {
          if (light.parent !== scene) {
            scene.add(light);
            console.info("SVELTHREE > Light : " + light.type + " was added to scene!", {
              light,
              scene,
              total: scene.children.length
            });
          }
        } else {
          if (light.parent !== parentForUs) {
            parentForUs.add(light);
            console.info("SVELTHREE > Light : " + light.type + " was added to parent!", {
              light,
              parent: parentForUs,
              scene,
              total: scene.children.length
            });
          }
        }
      }
      let { pos = [0, 1, 0] } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = 0 } = $$props;
      let { shadowMapSize = void 0 } = $$props;
      let { shadowBias = void 0 } = $$props;
      let { castShadow = void 0 } = $$props;
      let { props = void 0 } = $$props;
      let currentSceneActive = false;
      let animationEnabled = false;
      let { fnOnMount = void 0 } = $$props;
      function removeLightFromParent() {
        light.parent.remove(light);
      }
      function getAnimation() {
        return ani.getAnimation();
      }
      function startAni() {
        ani.startAni();
      }
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.parent === void 0 && $$bindings.parent && parent !== void 0)
        $$bindings.parent(parent);
      if ($$props.parentForUs === void 0 && $$bindings.parentForUs && parentForUs !== void 0)
        $$bindings.parentForUs(parentForUs);
      if ($$props.light === void 0 && $$bindings.light && light !== void 0)
        $$bindings.light(light);
      if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
        $$bindings.pos(pos);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      if ($$props.shadowMapSize === void 0 && $$bindings.shadowMapSize && shadowMapSize !== void 0)
        $$bindings.shadowMapSize(shadowMapSize);
      if ($$props.shadowBias === void 0 && $$bindings.shadowBias && shadowBias !== void 0)
        $$bindings.shadowBias(shadowBias);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.fnOnMount === void 0 && $$bindings.fnOnMount && fnOnMount !== void 0)
        $$bindings.fnOnMount(fnOnMount);
      if ($$props.removeLightFromParent === void 0 && $$bindings.removeLightFromParent && removeLightFromParent !== void 0)
        $$bindings.removeLightFromParent(removeLightFromParent);
      if ($$props.getAnimation === void 0 && $$bindings.getAnimation && getAnimation !== void 0)
        $$bindings.getAnimation(getAnimation);
      if ($$props.startAni === void 0 && $$bindings.startAni && startAni !== void 0)
        $$bindings.startAni(startAni);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          pos && pos.length > 0 ? object3DUtils.tryPosUpdate(pos) : null;
        }
        {
          intensity ? lightUtils.tryIntensityUpdate(intensity) : null;
        }
        {
          color ? lightUtils.tryColorUpdate(color) : null;
        }
        {
          shadowMapSize ? lightUtils.tryShadowMapSizeUpdate(shadowMapSize) : null;
        }
        {
          shadowBias ? lightUtils.tryShadowBiasUpdate(shadowBias) : null;
        }
        {
          castShadow ? lightUtils.tryCastShadowUpdate(castShadow) : null;
        }
        {
          props ? Object.keys(props).length > 0 ? uniPropIterator.tryPropsUpdate(props) : null : null;
        }
        currentSceneActive = $svelthreeStores[sti].scenes[scene.userData.indexInScenes].isActive;
        {
          animation ? animationEnabled = true : null;
        }
        $$rendered = `${validate_component(SvelthreeAnimation, "SvelthreeAnimation").$$render($$result, {
          animationEnabled,
          animation,
          aniauto,
          obj: light,
          scene,
          this: ani,
          currentSceneActive
        }, {
          this: ($$value) => {
            ani = $$value;
            $$settled = false;
          },
          currentSceneActive: ($$value) => {
            currentSceneActive = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      $$unsubscribe_svelthreeStores();
      return $$rendered;
    });
    AmbientLight_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { props = void 0 } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = void 0 } = $$props;
      let { scene } = $$props;
      let light = new AmbientLight();
      function getLight() {
        return light;
      }
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.getLight === void 0 && $$bindings.getLight && getLight !== void 0)
        $$bindings.getLight(getLight);
      return `

${validate_component(Light, "Light").$$render($$result, { scene, light, props, color, intensity }, {}, {})}`;
    });
    PointLight_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { props = void 0 } = $$props;
      let { parent = void 0 } = $$props;
      let { name = void 0 } = $$props;
      let { animation = void 0 } = $$props;
      let { aniauto = void 0 } = $$props;
      let { pos = void 0 } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = void 0 } = $$props;
      let { shadowMapSize = void 0 } = $$props;
      let { shadowBias = void 0 } = $$props;
      let { castShadow = false } = $$props;
      let { scene } = $$props;
      let light = new PointLight();
      light.name = name;
      let { helper = false } = $$props;
      let lightHelper;
      function createHelper() {
        lightHelper = new PointLightHelper(light, 0.1, "aqua");
        scene.add(lightHelper);
        lightHelper.visible = true;
        console.info("SVELTHREE > " + light.type + " : HELPER added!", {
          lightHelper,
          scene,
          total: scene.children.length
        });
      }
      function getLight() {
        return light;
      }
      function getHelper() {
        return lightHelper;
      }
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.parent === void 0 && $$bindings.parent && parent !== void 0)
        $$bindings.parent(parent);
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.animation === void 0 && $$bindings.animation && animation !== void 0)
        $$bindings.animation(animation);
      if ($$props.aniauto === void 0 && $$bindings.aniauto && aniauto !== void 0)
        $$bindings.aniauto(aniauto);
      if ($$props.pos === void 0 && $$bindings.pos && pos !== void 0)
        $$bindings.pos(pos);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      if ($$props.shadowMapSize === void 0 && $$bindings.shadowMapSize && shadowMapSize !== void 0)
        $$bindings.shadowMapSize(shadowMapSize);
      if ($$props.shadowBias === void 0 && $$bindings.shadowBias && shadowBias !== void 0)
        $$bindings.shadowBias(shadowBias);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.helper === void 0 && $$bindings.helper && helper !== void 0)
        $$bindings.helper(helper);
      if ($$props.getLight === void 0 && $$bindings.getLight && getLight !== void 0)
        $$bindings.getLight(getLight);
      if ($$props.getHelper === void 0 && $$bindings.getHelper && getHelper !== void 0)
        $$bindings.getHelper(getHelper);
      {
        !lightHelper && light && helper ? createHelper() : null;
      }
      return `

${validate_component(Light, "Light").$$render($$result, {
        scene,
        parent,
        light,
        props,
        pos,
        color,
        intensity,
        shadowMapSize,
        shadowBias,
        castShadow,
        animation,
        aniauto
      }, {}, {})}`;
    });
    Scene_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let { id = void 0 } = $$props;
      if (!id) {
        console.warn("SVELTHREE > Scene : You have to provide an 'id' prop (not empty String) for Scenes in order to assign them to a 'WebGLRenderer' component!", { id });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      let { props = void 0 } = $$props;
      let { sti } = $$props;
      if (sti === void 0) {
        console.warn("SVELTHREE > Scene : You have to provide a {sti} prop for the Scene!", { sti });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      const svelthreeStore = $svelthreeStores[sti];
      let scene = new Scene();
      scene.userData.isActive = false;
      scene.userData.id = id;
      scene.userData.sti = sti;
      scene.userData.animations = [];
      scene.userData.indexInScenes = svelthreeStore.scenes.length;
      svelthreeStore.scenes.push({ scene, id, isActive: false });
      function getScene() {
        return scene;
      }
      function getId() {
        return id;
      }
      if ($$props.id === void 0 && $$bindings.id && id !== void 0)
        $$bindings.id(id);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.sti === void 0 && $$bindings.sti && sti !== void 0)
        $$bindings.sti(sti);
      if ($$props.getScene === void 0 && $$bindings.getScene && getScene !== void 0)
        $$bindings.getScene(getScene);
      if ($$props.getId === void 0 && $$bindings.getId && getId !== void 0)
        $$bindings.getId(getId);
      $$unsubscribe_svelthreeStores();
      return `${slots.default ? slots.default({ scene }) : ``}`;
    });
    WebGLRenderer_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $svelthreeStores, $$unsubscribe_svelthreeStores;
      $$unsubscribe_svelthreeStores = subscribe(svelthreeStores, (value) => $svelthreeStores = value);
      let renderer;
      let rendererPropIterator;
      let { config = void 0 } = $$props;
      let { props = void 0 } = $$props;
      let { enableShadowMap = false } = $$props;
      let { shadowMapType = PCFSoftShadowMap } = $$props;
      let { sceneId: sceneToRenderId } = $$props;
      let { camId: camToRenderId } = $$props;
      let currentScene = void 0;
      let currentCam = void 0;
      let currentSceneId = "";
      let currentCamId = "";
      let canvas = void 0;
      let { sti } = $$props;
      if (sti === void 0) {
        console.warn("SVELTHREE > Scene : You have to provide a {sti} prop for the WebGLRenderer component!", { sti });
        throw new Error("SVELTHREE Exception (see warning above)");
      }
      let storeCanvasDimW;
      let storeCanvasDimH;
      function setCurrentCamActive() {
        console.info("SVELTHREE > WebGLRenderer : setCurrentCamActive", {
          currentCam: currentCam.type,
          uuid: currentCam.uuid,
          isActive: currentCam.userData.isActive
        });
        currentCam.userData.isActive = true;
        set_store_value(svelthreeStores, $svelthreeStores[sti].cameras[currentCam.userData.indexInCameras].isActive = true, $svelthreeStores);
        set_store_value(svelthreeStores, $svelthreeStores[sti].activeCamera = currentCam, $svelthreeStores);
        console.info("SVELTHREE > WebGLRenderer : setCurrentCamActive", {
          currentCam: currentCam.type,
          uuid: currentCam.uuid,
          isActive: currentCam.userData.isActive
        }, "done!");
      }
      function setCurrentCamInactive() {
        console.info("SVELTHREE > WebGLRenderer : setCurrentCamInactive", {
          currentCam: currentCam.type,
          uuid: currentCam.uuid,
          isActive: currentCam.userData.isActive
        });
        currentCam.userData.isActive = false;
        set_store_value(svelthreeStores, $svelthreeStores[sti].cameras[currentCam.userData.indexInCameras].isActive = false, $svelthreeStores);
        console.info("SVELTHREE > WebGLRenderer : setCurrentCamInactive", {
          currentCam: currentCam.type,
          uuid: currentCam.uuid,
          isActive: currentCam.userData.isActive
        }, "done!");
      }
      function resizeRenderer(tW, tH) {
        console.info("SVELTHREE > WebGLRenderer : resizeRenderer!");
        renderer ? renderer.setSize(tW, tH, false) : null;
      }
      function updateCameraAspect(tW, tH) {
        console.info("SVELTHREE > WebGLRenderer : updateCameraAspect!");
        currentCam ? (currentCam.type === "PerspectiveCamera" ? currentCam.aspect = tW / tH : null, currentCam.updateProjectionMatrix()) : null;
      }
      function getSceneToRender() {
        console.info("SVELTHREE > WebGLRenderer : getSceneToRender!");
        if ($svelthreeStores[sti].scenes.length > 0) {
          if (sceneToRenderId === void 0) {
            console.warn("SVELTHREE > WebGLRenderer : You have to provide the 'sceneId' prop!", { sceneId: sceneToRenderId });
            throw new Error("SVELTHREE Exception (see warning above)");
          } else {
            for (let i2 = 0; i2 < $svelthreeStores[sti].scenes.length; i2++) {
              let item = $svelthreeStores[sti].scenes[i2];
              if (item.id === sceneToRenderId) {
                currentSceneId = sceneToRenderId;
                return item.scene;
              }
            }
            console.warn("SVELTHREE > WebGLRenderer : Scene with id '" + sceneToRenderId + "' not found!", { scenes: $svelthreeStores[sti].scenes });
            throw new Error("SVELTHREE Exception (see warning above)");
          }
        } else {
          console.warn("SVELTHREE > WebGLRenderer : getSceneToRender: No Scenes available!", { scenes: $svelthreeStores[sti].scenes });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      }
      function getCamToRender() {
        console.info("SVELTHREE > WebGLRenderer : getCamToRender!");
        if ($svelthreeStores[sti].cameras.length > 0) {
          if (camToRenderId === void 0) {
            console.warn("SVELTHREE > WebGLRenderer : You have to provide the 'camId' prop!", { camId: camToRenderId });
            throw new Error("SVELTHREE Exception (see warning above)");
          } else {
            for (let i2 = 0; i2 < $svelthreeStores[sti].cameras.length; i2++) {
              let item = $svelthreeStores[sti].cameras[i2];
              if (item.id === camToRenderId) {
                currentCamId = camToRenderId;
                return item.camera;
              }
            }
            console.warn("SVELTHREE > WebGLRenderer : Camera with id '" + camToRenderId + "' not found!", { cameras: $svelthreeStores[sti].cameras });
            throw new Error("SVELTHREE Exception (see warning above)");
          }
        } else {
          console.warn("SVELTHREE > WebGLRenderer : getCamToRender: No Cameras available! $svelthreeStores[sti].cameras:", { cameras: $svelthreeStores[sti].cameras });
          throw new Error("SVELTHREE Exception (see warning above)");
        }
      }
      function deactivateCurrentScene() {
        if (currentScene.userData.isActive === true) {
          currentScene.userData.isActive = false;
          set_store_value(svelthreeStores, $svelthreeStores[sti].scenes[currentScene.userData.indexInScenes].isActive = false, $svelthreeStores);
        }
      }
      function activateCurrentScene() {
        if (currentScene.userData.isActive === false) {
          currentScene.userData.isActive = true;
          set_store_value(svelthreeStores, $svelthreeStores[sti].scenes[currentScene.userData.indexInScenes].isActive = true, $svelthreeStores);
        } else if (currentScene.userData.isActive === void 0) {
          console.info(currentScene);
          currentScene.userData.isActive = true;
          set_store_value(svelthreeStores, $svelthreeStores[sti].scenes[currentScene.userData.indexInScenes].isActive = true, $svelthreeStores);
        }
      }
      let rAF = void 0;
      function stopAnimating() {
        cancelAnimationFrame(rAF);
      }
      function getRenderer() {
        return renderer;
      }
      function getCurrentCamera() {
        return currentCam;
      }
      function setRender(parameters = { sceneId: "", camId: "" }) {
        sceneToRenderId = parameters.sceneId;
        camToRenderId = parameters.camId;
      }
      if ($$props.config === void 0 && $$bindings.config && config !== void 0)
        $$bindings.config(config);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      if ($$props.enableShadowMap === void 0 && $$bindings.enableShadowMap && enableShadowMap !== void 0)
        $$bindings.enableShadowMap(enableShadowMap);
      if ($$props.shadowMapType === void 0 && $$bindings.shadowMapType && shadowMapType !== void 0)
        $$bindings.shadowMapType(shadowMapType);
      if ($$props.sceneId === void 0 && $$bindings.sceneId && sceneToRenderId !== void 0)
        $$bindings.sceneId(sceneToRenderId);
      if ($$props.camId === void 0 && $$bindings.camId && camToRenderId !== void 0)
        $$bindings.camId(camToRenderId);
      if ($$props.sti === void 0 && $$bindings.sti && sti !== void 0)
        $$bindings.sti(sti);
      if ($$props.stopAnimating === void 0 && $$bindings.stopAnimating && stopAnimating !== void 0)
        $$bindings.stopAnimating(stopAnimating);
      if ($$props.getRenderer === void 0 && $$bindings.getRenderer && getRenderer !== void 0)
        $$bindings.getRenderer(getRenderer);
      if ($$props.getCurrentCamera === void 0 && $$bindings.getCurrentCamera && getCurrentCamera !== void 0)
        $$bindings.getCurrentCamera(getCurrentCamera);
      if ($$props.setRender === void 0 && $$bindings.setRender && setRender !== void 0)
        $$bindings.setRender(setRender);
      {
        !renderer ? $svelthreeStores[sti].canvas.dom ? (renderer = new WebGLRenderer(Object.assign({ canvas: $svelthreeStores[sti].canvas.dom }, config)), canvas = $svelthreeStores[sti].canvas.dom, rendererPropIterator = new UniversalPropIterator(renderer), set_store_value(svelthreeStores, $svelthreeStores[sti].renderer = renderer, $svelthreeStores)) : null : null;
      }
      {
        renderer ? enableShadowMap ? renderer.shadowMap.enabled = true : renderer.shadowMap.enabled = false : null;
      }
      {
        renderer ? renderer.shadowMap.enabled ? renderer.shadowMap.type = shadowMapType : null : null;
      }
      {
        renderer ? props ? Object.keys(props).length > 0 ? rendererPropIterator ? rendererPropIterator.tryPropsUpdate(props) : null : null : null : null;
      }
      {
        !currentScene && sceneToRenderId ? (currentScene = getSceneToRender(), activateCurrentScene()) : null;
      }
      {
        !currentCam && currentSceneId ? (currentCam = getCamToRender(), setCurrentCamActive()) : null;
      }
      {
        {
          if (sceneToRenderId !== currentSceneId) {
            if (currentScene) {
              deactivateCurrentScene();
              currentScene = getSceneToRender();
              activateCurrentScene();
            }
          }
          if (camToRenderId !== currentCamId) {
            if (currentCam) {
              currentCam ? (setCurrentCamInactive(), currentCam = getCamToRender(), setCurrentCamActive()) : null;
            }
          }
        }
      }
      storeCanvasDimW = $svelthreeStores[sti].canvas.dim.w;
      storeCanvasDimH = $svelthreeStores[sti].canvas.dim.h;
      {
        (storeCanvasDimW || storeCanvasDimH) && canvas ? (console.info("SVELTHREE > WebGLRenderer : before resize renderer 1"), resizeRenderer(storeCanvasDimW, storeCanvasDimH), updateCameraAspect(storeCanvasDimW, storeCanvasDimH)) : null;
      }
      {
        $svelthreeStores[sti].canvas.interactive ? ($svelthreeStores[sti].raycaster, true) : null;
      }
      {
        !$svelthreeStores[sti].canvas.interactive ? null : null;
      }
      $$unsubscribe_svelthreeStores();
      return ``;
    });
    FPS = 60;
    Book = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const dispatch = createEventDispatcher();
      let { index } = $$props;
      let { dir } = $$props;
      let { scene } = $$props;
      let { dimensions } = $$props;
      let { height } = $$props;
      const unselect = () => {
        if (toggled)
          handleClick(obj);
      };
      const paperColor = new Color("#ffffee");
      const loader = new TextureLoader();
      let urls = ["", "side.jpg", "", "", "front.jpg", "back.jpg"];
      let material = urls.map((url) => {
        return url == "" ? new MeshStandardMaterial({ color: paperColor }) : new MeshStandardMaterial({ map: loader.load(`${dir}/${url}`) });
      });
      let geometry = new BoxBufferGeometry(...dimensions);
      let weight = dimensions[0] * dimensions[1] * dimensions[2];
      let toggled = false;
      let tweening = false;
      const random = (min, max) => Math.random() * (max - min) + min;
      let rot = [-90, 0, random(80, 100)];
      let pos = [6, height, 0];
      let rotNormalized = rot.map((deg) => Math.PI * (deg / 180));
      let obj;
      async function handleClick(e2) {
        if (tweening)
          return;
        obj = e2.detail.target;
        toggled = !toggled;
        tweening = true;
        dispatch("toggle", { toggled, index });
        let args1 = [obj, "rotation", [-10, 0, -6], 1, "sineInOut"];
        let args = [obj, "position", [11, 9, 14.5], 1, "sineInOut"];
        let args3 = [obj, "rotation", rot, 1, "sineInOut"];
        let args2 = [obj, "position", pos, 1, "sineInOut"];
        if (toggled) {
          tween(...args);
          await tween(...args1);
          tweening = false;
        } else {
          tween(...args2);
          await tween(...args3);
          tweening = false;
        }
      }
      function handler2(e2) {
        if (toggled && obj) {
          obj.rotation.y += 3 / weight * (e2.deltaY > 0 ? 1 : -1);
        }
      }
      function addEvent() {
        window.addEventListener("wheel", handler2);
      }
      function removeEvent() {
        window.removeEventListener("wheel", handler2);
      }
      if ($$props.index === void 0 && $$bindings.index && index !== void 0)
        $$bindings.index(index);
      if ($$props.dir === void 0 && $$bindings.dir && dir !== void 0)
        $$bindings.dir(dir);
      if ($$props.scene === void 0 && $$bindings.scene && scene !== void 0)
        $$bindings.scene(scene);
      if ($$props.dimensions === void 0 && $$bindings.dimensions && dimensions !== void 0)
        $$bindings.dimensions(dimensions);
      if ($$props.height === void 0 && $$bindings.height && height !== void 0)
        $$bindings.height(height);
      if ($$props.unselect === void 0 && $$bindings.unselect && unselect !== void 0)
        $$bindings.unselect(unselect);
      return `${validate_component(Mesh_1, "Mesh").$$render($$result, {
        onPointerOver: addEvent,
        onPointerLeave: removeEvent,
        scene,
        material,
        geometry,
        rot: rotNormalized,
        pos,
        interact: true,
        onClick: handleClick
      }, {}, {})}`;
    });
    books = [
      {
        title: "Your Brain On Porn",
        author: "Gary Wilson",
        dir: "your_brain_on_porn",
        dimensions: [
          5.06,
          7.81,
          0.47
        ],
        excerpts: [
          {
            header: "The Big Tobacco of Our Day",
            content: "Big Tobacco's campaign to cast doubt on the link between smoking and disease is now a classic case study in a science called agnotology: <i>the study of the cultural production of ignorance.</i> Agnotology investigates the deliberate sowing of public misinformation and doubt in a scientific area. As Brian McDougal, the author of <i>Porned Out</i>, put it: <br><br><i>It's hard to imagine that a whole generation chain-smoked cigarettes without having any idea how harmful they are, but the same thing is happening today with online pornography</i>"
          }
        ]
      },
      {
        title: "Ottoman Vampires - Rumors, Interactions, Reactions",
        author: "Salim Fikret K\u0131rgi",
        dir: "ottoman_vampires",
        dimensions: [
          5.2,
          7.8,
          0.4
        ],
        excerpts: [
          {
            header: "Hindered Demon",
            content: `One day I saw an innumerable amout of swords stemmed over a grave. Since this practice was taken so seriously, [they] would stick swords three or four times a day. An Albanian who happened to be in Mykonos Island, with an authorative tone, deemed the practice unbelievably laughable and scolded "Don't you understand, are you blind?! Can't you see the cross shaped hilts hindering the demon from leaving the body? Why aren't you using Turkish swords?"<br><br><i>A Mediterranean Voyage, Tournefort, 1718</i>`
          }
        ]
      },
      {
        title: "Performance Addiction",
        author: "Arthur Ciaramicoli",
        dir: "performance_addiction",
        dimensions: [
          6.14,
          9.21,
          0.57
        ],
        excerpts: [
          {
            header: "Being Human",
            content: `About the time of my father's death, I was given a book by Hugh Prather called <i>Notes to Myself.</i> I remember only one line: "We can either be perfect or we can be human." To me this phrase summarizes the problem with perfectionism. As we get closer and closer to the state of perfection, we must go to ever greater lengths to hide our mistakes, flaws, and shortcomings - that is, all that makes us most appealingly human.`
          },
          {
            header: "Acceleration",
            content: 'If you are tring to win everything you want by increasing your level of activity, you are involved in a dizzying acceleration. In <i>Faster: The Acceleration of Just about Everything</i>, author James Gleick summarizes the characteristics ofa high-paced society that is fueled by stress and stoked ambition. "If one quality defines our modern, technological age, it is acceleration" writes Gleick. "We are making haste. Our computers, our movies, our sex lives, our prayers - they all run faster now than before. And the more we fill our lives with time-saving devices and time-saving strategies, the more rushed we feel.'
          }
        ]
      },
      {
        title: "FLOW: The Psychology of Optimal Experience",
        author: "Mihalyi Csikszentmihalyi",
        dir: "flow",
        dimensions: [
          5.3,
          7.9,
          0.9
        ],
        excerpts: [
          {
            header: "Leisure Industry",
            content: "The tremendous leisure industry that has arisen in the last few generations has been designed to help fill free time with enjoyable experiences. Nevertheless, instead of using our physical and mental resources to experience flow, most of us spend many hours each week watching celebrated athletes playing in enormous stadiums. Instead of making music, we listen to platinum records cut by millionaire musicians. Instead of making art, we go to admire paintings that brought in the highest bids at the latest auction. We do not run risks acting on our beliefs, but occupy hours each day watching actors who pretend to have adventures, engaged in mock-meaningful action. This vicarious participation is able to mask, at least temporarily, the underlying emptiness of wasted time. But it is a very pale substitute for attention invested in real challenges. The flow experience that results from the use of skills leads to growth; passive entertainment leads nowhere. Collectively we are wasting each year the equivalent of millions of years of human consciousness. The energy that could be used to focus on complex goals, to provide for enjoyable growth, is squandered on patterns of stimulation that only mimic reality. Mass leisure, mass culture, and even high culture when only attended to passively and for extrinsic reasons\u2014such as the wish to flaunt one's status\u2014are parasites of the mind. They absorb psychic energy without providing substantive strength in return. They leave us more exhausted, more disheartened than we were before."
          },
          {
            header: "Marriage and Friendship",
            content: `The ideal of a modern marriage is to have one's spouse as a friend. In previous times, when marriages were arranged for the mutual convenience of families, this was considered an impossibility. But now that there are fewer extrinsic pressures to get married, many people claim that their best friend is their spouse. Friendship is not enjoyable unless we take up its expressive challenges. If a person surrounds himself with "friends" who simply reaffirm his public persona, who never question his dreams and desires, who never force him to try out new ways of being, he misses out on the opportunities friendship presents. A true friend is someone we can occasionally be crazy with, someone who does not expect us to be always true to form. It is someone who shares our goal of self-realization, and therefore is willing to share the risks that any increase in complexity entails.`
          },
          {
            header: "Marcus Aurelius the Chad",
            content: "And the great emperor Marcus Aurelius wrote: <br><br><p><i>If you are pained by external things, it is not they that disturb you, but your own judgment of them. And it is in your power to wipe out that judgment now.</i></p>"
          },
          {
            header: "Is that all there is?",
            content: `After a while, however, it becomes obvious that these piecemeal solutions won't work either. No matter how much energy we devote to its care, the body will eventually give out. If we are learning to be more assertive, we might inadvertently alienate our friends. And if we devote too much time to cultivating new friends, we might threaten relationships with our spouse and family. There are just so many dams about to burst and so little time to tend to them all. <p>Daunted by the futility of trying to keep up with all the demands they cannot possibly meet, some will just surrender and retire gracefully into relative oblivion. Following Candide's advice, they will give up on the world and cultivate their little gardens. They might dabble in genteel forms of escape such as developing a harmless hobby or accumulating a collection of abstract paintings or porcelain figurines. Or they might lose themselves in alcohol or the dreamworld of drugs. While exotic pleasures and expensive recreations temporarily take the mind off the basic question "Is this all there is?" few claim to have ever found an answer that way. </p>`
          }
        ]
      },
      {
        title: "Do Nothing",
        author: "Celeste Headlee",
        dir: "do_nothing",
        dimensions: [
          5.78,
          8.54,
          0.99
        ],
        excerpts: [
          {
            header: "Infinite Growth in a Finite Planet",
            content: `An economy built around constant growth, though, may not be sustainable in the long run, and many economists have started to question economic policies that are based on a belief in unending increases. This issue has actually become a bone of contention among many who watch financial markets. Journalist and author Christopher Ketcham calls the dream of constant growth the "unifying faith of industrial civilization." <br><br> While there's no reason why incomes shouldn't continue to grow and, therefore, why the amount people are willing to pay for products would not also increase, the number of resources available to make those products is finite. I'm certainly not going to settle this issue in these pages, as economics is not an exact science and there may be no definitive answers. As the old joke goes, if you put ten economists into a room, you'll end up with eleven opinions. I'm only interested in this debate because of the impact it has on our working lives. Graeme Maxton, secretary general of the Club of Rome and author of The End of Progress, tells me, "We have this 'common sense' belief that we need economic growth to create jobs and reduce inequality, that economic growth is the key to everything."`
          },
          {
            header: "Workaholism",
            content: `So why don't Americans take a break? Because we've been brainwashed to believe that hard work, on its own, is the key to success. In an op-ed that protests against the unhealthy work ethic of Silicon Valley, Daniel Heinemeier Hansson points out that Charles Darwin worked only four hours a day and Kobe Bryant put in only six hours a day during the off-season. Hansson, the founder of Basecamp and the bestselling author of Rework, says, "Don't tell me that there's something uniquely demanding about building yet another fucking startup that dwarfs the accomplishments of The Origin of Species or winning five championship rings. It's bullshit. Extractive, counterproductive bullshit peddled by people who either need a narrative to explain their personal sacrifices and regrets or who are in a position to treat the lives and well-being of others like cannon fodder." Lest you think this is all hot air, Hansson has put his money where his philosophy is. Hansson's employees work forty hours a week for most of the year and only thirty two hours during the summer months. In a 2017 op-ed, he wrote, "Workaholism is a disease. We need treatment and coping advice for those afflicted, not cheerleaders for their misery."`
          },
          {
            header: "Peak Misery",
            content: `In 2016, the self-help industry was worth nearly $10 billion in the United States alone. By 2022, it's expected to be worth more than $13 billion. Many people believe their lives, minds, and bodies can be hacked, tinkered with, and improved in a never-ending search for peak productivity. Why just make a cake when you can search through Pinterest and find the best cake recipe with the cutest decoration ideas? Almost no one searches for a "good workout routine," instead looking for the "ultimate workout." We want the fastest, most efficient method for reaching our goals, hopefully guaranteed by as many five-star reviews as possible.`
          },
          {
            header: "The Pen Is Mightier Than The Keyboard",
            content: `...also found that even when the computer is used only to take notes, it's still inferior to writing in longhand when it comes to com-prehension and retention. The report was titled "The Pen Is Mightier Than the Keyboard." Students who used their laptops did poorly when asked conceptual questions, despite recording more of what was said. When students write in longhand, they process the information they hear and record it in their own words. Those who use a laptop might be able to transcribe a lecture verbatim, but they simply don't learn as much. <br><br> Professor Susan Dynarski of the University of Michigan wrote an op-ed in the New York Times in 2017 explaining why she bans all electronics from her classrooms. She admits this policy may seem extreme but says, "The research is unequivocal: Laptops distract from learning, both for users and for those around them. It's not much of a leap to expect that electronics also undermine learning in high school classrooms or that they hurt productivity in meetings in all kinds of workplaces."`
          },
          {
            header: "Our Ultimate Goal",
            content: `"We adopt the illusion," Andrew Taggart says, "that personal productivity is itself the end of suffering, or is itself happiness, when in actuality, the aim of personal productivity is to enable the work-society to continue....The truth is that we are its tools." In other words, we use laptops because we think recording 80 percent of what's said is inherently better than getting only 50 percent. We strive to achieve peak productivity but forget that it's taking us further from our ultimate goal\u2014learning.`
          },
          {
            header: "Edward Barneys",
            content: `Edward Bernays would later say he learned an invaluable lesson while at the CPI office: The tactics he'd used during war "could be applied with equal facility to peacetime pursuits. In other words, what could be done for a nation at war could be done for organizations and people in a nation at peace." This slight man with his dark, sunken eyes, high forehead, and generous mustache is probably not familiar to most people today, but he changed our lives irrevocably. <br><br>Bernays is now known as the "Father of Spin." He helped make it fashionable for women to smoke in the late twenties by re-branding cigarettes as "Torches of Freedom" and symbols of feminist strength. His 1928 book, Propaganda, was hugely influential and put into practice by many men in power. "Those who manipulate this unseen mechanism of society constitute an invisible government which is the true ruling power of our country," Bernays wrote. "In almost every act of our daily lives, whether in the sphere of politics or business, in our social conduct or our ethical thinking, we are dominated by the relatively small number of persons...who understand the mental processes and social patterns of the masses."          `
          },
          {
            header: "Walking R\xE9sum\xE9s",
            content: `The writer Maria Popova told the BBC: "The most pernicious thing [is] this tendency we have to apply productivity to realms of life that should, by their very nature, be devoid of that criterion." <br><br>Popova reports that she used to enjoy taking a camera with her everywhere and taking photos of what she saw. Now that she feels pressured to leverage her photos on social media, the camera "has become its own burden." I understand her dilemma. I love to walk but sometimes when the sole purpose of my jaunt is to meet my step goal, I dread leaving the house. What was a joy sometimes feels like drudgery because I've turned a pleasure into work. <br><br>Again, it should go without saying that it is natural to want to improve. We are biologically programmed to quickly become impatient with the status quo and to push for better things. But we've pushed it too far. What's more, we've lost sight of the fact that productivity is a means to an end, not a goal in and of itself. One time-use expert told Juliet Schor, "We have become walking r\xE9sum\xE9s. If you're not doing something, you're not creating and defining who you are."`
          },
          {
            header: "Death of Boredom",
            content: `low ourselves a significant amount of leisure time. It makes sense, too, when you think back to times in your life when you worked a considerable amount of overtime. Do you think you were in the right frame of mind then to think creatively or carefully? I think the weight of scientific opinion shows that a certain amount of idleness is required in order for the human brain to function best. Although we think of great men and women as hard workers, many of them were as rigorous about scheduling leisure as they were about getting things done. As Alex Soojung-Kim Pang, author of Rest: Why You Get More Done When You Work Less, writes: "Darwin and Lubbock, and many other creative and productive figures, weren't accomplished despite their leisure; they were accomplished because of it."<br><br> One of the tragic consequences of rising smartphone usage is the death of boredom. In our hours of leisure, we used to experience some measure of ennui from time to time, but we are rarely bored these days, and the younger generation almost doesn't know the meaning of the word. This is not a good development because boredom is an inherently fertile state of mind.`
          },
          {
            header: "Default Network",
            content: `"Once you start daydreaming and allow your mind to wander," says the psychologist Sandi Mann, author of The Upside of Downtime: Why Boredom Is Good, "you start thinking beyond the conscious and into the subconscious." <br><br> When our minds are allowed to relax and rest, they return to what's called the "default network." This is the part of the brain that sorts through all the new information we've received recently and tries to put it into con-text with what we already know. The default network is integral to learning, insight, and imagination. If our minds never come to rest, there is never an opportunity to wander into new directions. <br><br> Again, don't mistake rest for inactivity. When the mind is at rest, it is still active. In fact, it uses only 5 percent less energy than it does when it's focused on a task. Focus is required for directed work, but idleness is necessary for reflection.`
          },
          {
            header: "How to break out of productivity hell?",
            content: "So here is the complete list of solutions, all designed to break your addiction to efficiency without purpose and productivity with production. <br><br>1. Increase time perception.<br> 2. Create your ideal schedule. <br>3. Stop comparing at a distance. <br>4. Work fewer hours. <br>5. Schedule leisure. <br>6. Schedule social time. <br>7. Work in teams. <br>8. Commit small, selfless acts. <br>9. Focus on ends, not means. <br><br>This list may represent small tweaks to your current habits, or it could be that following these guidelines will require a massive over-haul. Regardless, learn from my experience and start with one at a time. Most things are good for you only up to the point where they become oppressive and overwhelming. I certainly don't recommend that you turn this list into another productivity hack that causes further stress."
          }
        ]
      },
      {
        title: "Capitalist Realism",
        author: "Mark Fisher",
        dir: "capitalist_realism",
        dimensions: [
          5.71,
          8.6,
          0.32
        ],
        excerpts: [
          {
            header: "Mental Illness Under Capitalism",
            content: "The current ruling ontology denies any possibility of a social causation of mental illness. The chemico-biologization of mental illness is of course strictly commensurate with its de-politicization. Considering mental illness an individual chemico-biological problem has enormous benefits for capitalism. First, it reinforces Capital's drive towards atomistic individualization (you are sick because of your brain chemistry). Second, it provides an enormously lucrative market in which multinational pharmaceutical companies can peddle their pharmaceuticals (we can cure you with our SSRIs). It goes without saying that all mental illnesses are neurologically instantiated, but this says nothing about their causation. If it is true, for instance, that depression is constituted by low serotonin levels, what still needs to be explained is why particular individuals have low levels of serotonin. This requires a social and political explanation; and the task of repoliticizing mental illness is an urgent one if the left wants to challenge capitalist realism."
          },
          {
            header: "Entrepreneurial Fantasy Society",
            content: "(Quoting from The Selfish Capitalist by Oliver James). In the entrepreneurial fantasy society, the delusion is fostered that anyone can be Alan Sugar or Bill Gates, never mind that the actual likelihood of this occurring has diminished since the 1970s - a person born in 1958 was more likely than one born in 1970 to achieve upward mobility through education, for example. The Selfish Capitalist toxins that are most poisonous to well-being are the systematic encouragement of the ideas that material affluence is they key to fulfillment, that only the affluent are winners and that access to the top is open to anyone willing to work hard enough, regardless of their familial, ethnic or social background - if you do not succeed, there is only one person to blame."
          },
          {
            header: "Final Note",
            content: "The long, dark night of the end of the history has to be grasped as an enormous opportunity. The very opressive pervasiveness of capitalist realism means that even glimmers of alternative political and economic possibilities can have a disproportionately great effect. The tiniest event can tear a hole in the grey curtain of reaction which has marked the horizons of possibility under capitalist realism. From a situation in which nothing can happen, suddenly anything is possible again."
          }
        ]
      },
      {
        title: "Bullshit Jobs",
        author: "David Graeber",
        dir: "bullshit_jobs",
        dimensions: [
          6,
          9,
          1.2
        ],
        excerpts: [
          {
            header: "Two Boilings of an Egg",
            content: `Priests or monks might organize their lives around celestial time, but life on earth was typically assumed to be messier. Below the heavens, there is no absolute yardstick to apply. To give an obvious example: if there are twelve hours from dawn to dusk, there's little point saying a place is three hours' walk away when you don't know the season when someone is traveling, since winter hours will be half the length of summer ones. When I lived in Madagascar, I found that rural people - who had little use for clocks - still often described distance the old fashioned way and said that to walk to another village would take two cookings of a pot of rice. In medieval Europe, people spoke similarly of something as taking "three paternosters" or two boilings of an egg. This sort of thing is extremely common. In places without clocks, time is measured by actions rather than action being measured by time.`
          },
          {
            header: "Idle Fingers Knit Sweaters for the Devil",
            content: `Insofar as women in patriarchal societies were supervised, they were supervised by other women. Now, this did often involve a notion that women, unlike men, should keep themselves busy all the time. "Idle fingers knit sweaters for the devil" my great-grandmother used to warn her daughter back in Poland. But this kind of traditional moralizing is actually quite different from the modern "If you have time to lean, you have time to clean" because its underling messages is not that you <i>should</i> be working but that you <i>shouldn't</i> be doing anything else. Essentially, my great-grandmother was saying that anything a teenage girl in a Polish shtetl might be getting up to when she wasn't knitting was likely to cause trouble. Similarly, one can find occasional warnings by nineteenth-century plantation owners in the American South or the Caribbean that it's better to keep slaves busy even at made-up tasks than to allow them to idle about in the off-season; the reason given always being that if slaves were left with time on their hands, they were likely to start plotting to flee or revolt.`
          },
          {
            header: "Made Up Work",
            content: `Groos' theory of "the pleasure at being the cause" led him to devise a theory of play as make-believe: humans invent games and diversions, he proposed, for the exact same reason the infant takes delight in his ability to move a pencil. We wish to exercise our powers as an end in themselves. The fact that the situation is made up doesn't detract from this; in fact, it adds another level of contrivance. This, Groos suggested - and here he was falling back on the ideas of Romantic German philosopher Friedrich Schiller - is really all that freedom is. (Schiller argued that the desire to create art is simply a manifestation of the urge to play as the exercise of freedom for its own sake as well.) Freedom is our ability to make things up just for the sake of being able to do so. <br> Yet at the same time, it is precisely the make-believe aspect of their work that student workers like Patrick and Brendan find the most infuriating - indeed, that just about anyone who's ever had a wage-labor job that was closely supervised invariably finds the most maddening aspect of her job. Working serves a purpose, or is meant to do so. Being forced to pretend to work just for the sake of working is an indignity, since the demand is perceived - rightly - as the pure exercise of power for its own sake. If make-believe play is the purest expression of human freedom, make believe-work imposed by others is thepurest expression of lack of freedom. It's not entirely surprising then, that the first historical evidence we have for the notion that certain categories of people really ought to be working at all times, even if there's nothing to do, and that work needs to be made up to fill their time, even if there's nothing that really needs doing, refers to people who are not free: prisoners and slaves, two categories that historically have largely overlapped.`
          },
          {
            header: "Shit Mindfully",
            content: `Irene: "On top of the metrics, there were the cruel, patronizing flexibility and mindfulness seminars. No you can't work fewer hours. No, you can't get paid more. No, you can't choose which bullshit projects to decline. But you can sit through this seminar, where the bank tells you how much it values flexibility. <br> The mindfullness seminars were even worse. They attempted to reduce the unfathomable beauty and stupefying sadness of the human experience into the raw physicality of breating, eating and shitting. Breathe mindfully. Eat mindfully. Shit mindfully, and you can be successful in business." <br><br> All of this, presumably, to remind the employee that if one reduced life to pure physicality, the fact that some abstractions were more "real" than others, and that some office tasks seemed to serve a legal and moral or even economic purpose and others did not, was not really all that important. It's as if they first forbid you to acknowledge you are engaging in empty ritual, then force you to attend seminars where hired gurus tell you, "In the final analysis, isn't everything we do just empty ritual?"`
          },
          {
            header: "You Have It Better",
            content: "The burden of rights-scoling falls above all on the younger generations. In most wealthy countries, the current crop of people in their twenties represents the first generation in more than a century that can, on the whole, expect opportunities and living standards substantially worse than those enjoyed by their parents. Yet at the same time, they are lectured relentlessly from both left and right on their sense of entitlement for feeling they might deserve anything else. This makes it especially difficulty for younger people to complain about meaningless employment."
          },
          {
            header: "Not Very Shocking Statistics",
            content: `Very few economists have actually attempted to measure the overall social value of different professions; most would probably take the very idea as something of a fool's errand; but those who have tried tend to confirm that there is indeed an inverse relation between usefulness and pay. In a 2017 paper, US economists Benjamin B. Lockwood, Charles G. Nathanson, and E. Gkeb Weyl combed through the existing literature on the "externalities" (social costs) and "spillover effects" (social benefits) associated with a variety of highly paid professions, to see if it were possible to calculate how much each adds to or subtracts from the economy overall. They concluded that while in some cases - notably anything associated with creative industries - the values involved were just too subjective to measure, in other cases, a rough approximation was possible. Their conclusion: the most socially valuable workers whose contributions could be calculated are medical researchers, who add $9 of overall value to society for every $1 they are paid. The least valuable were those who worked in the financial sector, who, on average, subtract a net $1.80 in value from society for $1 of compensation. (And, of course, workers in the financial sector are often compensated extremely well.)`
          }
        ]
      },
      {
        title: "Burnout Society",
        author: "Byung Chul Han",
        dir: "burnout_society",
        dimensions: [
          5,
          8,
          0.17
        ],
        excerpts: [
          {
            header: "Vita Contemplativa & Vita Activa",
            content: 'In this sense, Saint Gregory the Great wrote: "One must know, if a good course of life requires that one pass from the active to the contemplative life, then it is often useful when the soul returns from the contemplative to the active life in such a way that the flame of contemplation lighted in the heart confers its entire perfection on activity. Thus, the active life must lead to contemplation, but contemplation must proceed from what we have observed within and calls us back to activity."'
          },
          {
            header: "Nietzsche on the Sovereign Man",
            content: `For Nietzsche, it is not "sovereign man" but the "last man" who exploits himselfs as his own vassal. Counter to what Ehrenberg claims, Nietzsche advanced "sovereign man" in the name of cultural criticism, as a countermodel to the exhausted achievement-subject. That is why "sovereign man" is a man of leisure. A hyperactive person would have disgusted Nietzsche: the "strong soul" keeps "calm", "moves slowly" and "has an aversion to what's too lively." <i>Thus Spoke Zarathustra</i> declares:<br><br>All of you who are in love with hectic work and whatever is fast, new, strange-you find it hard to bear yourselves, your diligence is escape and the will to forget yourself.<br>If you believed more in life, you would hurl yourself less into the moment. But you do not have enough content in yourselves for waiting-not even for laziness!`
          },
          {
            header: "Life Reduced to Survival",
            content: "The capitalist economy absolutizes survival. It is not concerned with <i>good</i> life. It is sustained by the illusion that more capital produces more life, which means a greater capacity for living. The rigid, rigorous seperation between the life and death casts a spell of ghostly stiffness over life itself. Concern about living the good life yields to the hysteria of surviving. The reduction of life to biological, vital processes makes life itself bare and strips it of all narrativity. It takes <i>livingness</i> from life, which is a much more complex than simple vitality and health. The mania for health emerges when life has become as flat as a coin and stripped of all narrative content, all value. Given the atomization of society and the erosion of the social, all that remains is the body of the ego, which is to be kept healthy at any cost.The loss of ideal values leaves, other than the exhibiton value of the ego, only health value behind. Bare life makes all telelogy vanish - every in-order-to that would give reason to remain healthy. Health becomes self-referential and voids itself into purposiveness without purpose."
          },
          {
            header: "Bare Life",
            content: "The life of <i>homo sacer</i> in achievement society is holy and bare for another reason entirely. It is bare because, stripped of all transcendent <i>value</i>, it has been reduced to the immanency of vital functions and capacities, which are to be maximized by any and all means. The inner logic of achievement society dictates its evolution into a <i>doping society</i>. Life reduced to bare, vital functioning is life to be kept healthy unconditionally. Health is the new goddess. That is why bare life is holy."
          }
        ]
      },
      {
        title: "Although Of Course You End Up Becoming Yourself",
        author: "David Lipsky",
        dir: "although",
        dimensions: [
          6.33,
          9.15,
          1.06
        ],
        excerpts: [
          {
            header: "Real Rebels",
            content: `Too sincere. Clearly repressed. Backward, quaint, na\xEFve, anachronistic. Maybe that'll be the point. Maybe that's why they'll be the next real rebels. Real rebels, as far as I can see, risk disapproval. The old postmodern insurgents risked the gasp and squeal: shock, disgust, outrage, censorship, accusations of socialism, anarchism, nihilism. Today's risks are different. The new rebels might be artists willing to risk the yawn, the rolled eyes, the cool smile, the nudged ribs, the parody of gifted ironists, the "Oh how banal." To risk accusations of sentimentality, melodrama. Of overcredulity. Of softness. Of willingness to be suckered by a world of lurkers and starers who fear gaze and ridicule above imprisonment without law.`
          },
          {
            header: "All Right",
            content: `(Talking about succeeding as a young writer) It means to me like, this is sort of what happened to me. You know, it was probably very much the same for you. You know, you're in Brown, who's gonna make it, who's not? And then you get, like, you start being able to make a living. So you get all that affirmation from the exterior, that when you're a young person you think will make everything all right. And I realize that sounds reductive and pop psych or whatever. But to realize\u2014like you say, when it happens to you, when you yourself realize, "Holy shit, this doesn't make everything all right." Um, for me, it fucked with my sort of "metaphysics of living" in an incredibly deep way.`
          },
          {
            header: "Engaging Art",
            content: "You teach the reader that he's way smarter than he thought he was. I think one of the insidious lessons about TV is the meta-lesson that you're dumb. This is all you can do. This is easy, and you're the sort of person who really just wants to sit in a chair and have it easy. When in fact there are parts of us, in a way, that are a lot more ambitious than that. And what we need, I think\u2014and I'm not saying I'm the person to do it. But I think what we need is seriously engaged art, that can teach again that we're smart. And that there's stuff that TV and movies\u2014although they're great at certain things\u2014cannot give us. But that have to create the motivations for us to want to do the extra work, you know, to get these other kinds of art. And I think you can see it in the visual arts, I think you can see it in music."
          },
          {
            header: "Virtually Dead",
            content: "In fifteen years, we're gonna have virtual reality pornography. Now, if I don't develop some machinery for being able to turn off pure unalloyed pleasure, and allow myself to go out and, you know, grocery shop and pay the rent? I don't know about you, but I'm gonna have to leave the planet. Virtual. Reality. Pornography. I'm talking, you know what I mean? The technology's gonna get better and better at doing what it does, which is seduce us into being incredibly dependent on it, so that advertisers can be more confident that we will watch their advertisements. And as a technology system, it's amoral. It doesn't have a responsibility to care about us one whit more than it does: It's got a job to do. The moral job is ours. You know, Why am I watching five hours a day of this? I mean, why am I getting 75 percent of my calories from candy? I mean, that's something that a little tiny child would do, and that would be all right. But we're postpubescent, right? Somewhere along the line, we're supposed to have grown up.<br><br><i>But if the most intelligent, promising, and educated people go into designing the candy, then it's impossible to turn down.</i><br><br>Then we're talking about Turkish delight and C. S. Lewis. If I can put it into a couple of sentences that you can quote: see, it's more like, Yeah, this is the problem. Is that, is that entertainment lies on the addictive continuum. And we're saved right now, because it's just not all that good. But if you notice that like\u2014I'll watch five or six, I'll zone out in front of the TV for five or six hours, and then I feel depressed and empty. And I wonder why. Whereas if I eat candy for five or six hours, and then I feel sick, I know why.<br><br><i>Reason I feel bad is guilt. My parents operated a very clear and effective NPR/PBS/New Yorker propaganda course: that TV is bad, it's a waste of time, you don't want to be somebody else's audience. And home is the most convenient place to be an audience.</i><br><br>It's not bad or a waste of your time. Any more than, you know, masturbation is bad or a waste of your time. It's a pleasurable way to spend ten minutes. But if you're doing it twenty times a day\u2014or if your primary sexual relationship is with your own hand\u2014then there's something wrong. I mean, it's a matter of degree.<br><br><i>Yeah\u2014whereas at least if you wank off, at least some action has been performed. That you can point to it and say: yes, I have been effective. </i><br><br>All right\u2014you could make me look like a real dick if you wanted to print this and extend the analogy. But there is a similarity. Yes, you're performing muscular movements with your hand as you're jerking off. But what you're doing is running a movie in your head, and having a fantasy relationship with somebody who isn't real, in order to stimulate a purely neurological response. I think one of the reasons that I feel empty after watching a lot of TV, and one of the things that makes TV seductive, is that it gives the illusion of relationships with people. It's a way to have people in the room talking and being entertaining, but it doesn't require anything of me. I mean, I can see them, they can't see me. And, and, they're there for me, and I can, I can receive from the TV, I can receive entertainment and stimulation. Without having to give anything back but the most tangential kind of attention. And that is very seductive. The problem is it's also very empty. Because one of the differences about having a real person there is that number one, I've gotta do some work. Like, he pays attention to me, I gotta pay attention to him. You know: I watch him, he watches me. The stress level goes up. But there's also, there's something nourishing about it, because I think like as creatures, we've all got to figure out how to be together in the same room. And so TV is like candy in that it's more pleasurable and easier than the real food. But it also doesn't have any of the nourishment of real food. And the thing, what the book is supposed to be about is, What has happened to us, that I'm now willing\u2014and I do this too\u2014that I'm willing to derive enormous amounts of my sense of community and awareness of other people, from television? But I'm not willing to undergo the stress and awkwardness and potential shit of dealing with real people. And that as the Internet grows, and as our ability to be linked up, like\u2014I mean, you and I coulda done this through e-mail, and I never woulda had to meet you, and that woulda been easier for me. Right? Like, at a certain point, we're gonna have to build some machinery, inside our guts, to help us deal with this. Because the technology is just gonna get better and better and better and better. And it's gonna get easier and easier, and more and more convenient, and more and more pleasurable, to be alone with images on a screen, given to us by people who do not love us but want our money. Which is all right. In low doses, right? But if that's the basic main staple of your diet, you're gonna die. In a meaningful way, you're going to die. (Passionate) <br><br><i>But you developed some defenses?</i><br><br>No. This is the great thing about it, is that probably each generation has different things that force the generation to grow up. Maybe for our grandparents it was World War Two. You know? For us, it's gonna be that at, at a certain point, that we're either gonna have to put away childish things and discipline ourself about how much time do I spend being passively entertained? And how much time do I spend doing stuff that actually isn't all that much fun minute by minute, but that builds certain muscles in me as a grownup and a human being? And if we don't do that, then (a) as individuals, we're gonna die, and (b) the culture's gonna grind to a halt. Because we're gonna get so interested in entertainment that we're not gonna want to do the work that generates the income that buys the products that pays for the advertising that disseminates the entertainment. [He loves the A-B, 1-2 construction.] It just seems to me like it's gonna be this very cool thing. Where the country could very well shut down and die, and it won't be anybody else doin' it to us, we will have done it to ourselves. (Laughs)"
          }
        ]
      }
    ];
    css2 = {
      code: "@import url('https://fonts.googleapis.com/css2?family=PT+Serif&display=swap');main.svelte-1ru42ev.svelte-1ru42ev{z-index:99;position:absolute;height:100%;width:35%;background-color:#000000;border-right:#d3c2be 5px solid;color:white;box-sizing:border-box;padding:0 5%}.canvas-container.svelte-1ru42ev.svelte-1ru42ev{position:absolute;background-color:black;height:100vh;width:100vw}.scrollable.svelte-1ru42ev.svelte-1ru42ev{flex:1 1 auto;border-top:1px solid #eee;border-bottom:1px solid #eee;margin:0 0 0.5rem 0;padding:0.5rem 0;height:60vh;overflow-y:auto}.excerpt-navigation.svelte-1ru42ev.svelte-1ru42ev{display:flex;flex-direction:row;justify-content:space-evenly;align-items:center}button.svelte-1ru42ev.svelte-1ru42ev{width:10%}#title.svelte-1ru42ev.svelte-1ru42ev,#author.svelte-1ru42ev.svelte-1ru42ev{text-align:center}section.svelte-1ru42ev p.svelte-1ru42ev{font-family:'PT Serif', serif}",
      map: null
    };
    Library = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let book;
      let excerpt;
      let w = innerWidth - 10;
      let h2 = innerHeight - 10;
      books.map((book2) => book2.dimensions[2]);
      let bookIndex = null;
      let excerptIndex = null;
      $$result.css.add(css2);
      book = books[bookIndex];
      excerpt = book?.excerpts[excerptIndex];
      return `<main class="${"svelte-1ru42ev"}">${!book ? `<h1 id="${"instruction"}">Click on any book to show the details.</h1>
			<h4>Hover and scroll to rotate a book.</h4>` : `<h2 id="${"title"}" class="${"svelte-1ru42ev"}">${escape3(book.title)}</h2>
			<p id="${"author"}" class="${"svelte-1ru42ev"}">${escape3(book.author)}</p>
			<h3>Excerpts (${escape3(excerptIndex + 1)} / ${escape3(book.excerpts.length)})</h3>
			<section class="${"svelte-1ru42ev"}"><h4>${escape3(excerpt.header)}</h4>
					<p class="${"scrollable svelte-1ru42ev"}"><!-- HTML_TAG_START -->${excerpt.content}<!-- HTML_TAG_END --></p></section>
			${book.excerpts.length > 1 ? `<div class="${"excerpt-navigation svelte-1ru42ev"}"><button class="${"svelte-1ru42ev"}">&lt;</button>
					<button class="${"svelte-1ru42ev"}">&gt;</button></div>` : ``}`}</main>

<div class="${"canvas-container svelte-1ru42ev"}">${validate_component(Canvas, "Canvas").$$render($$result, { w, h: h2, interactive: true }, {}, {
        default: ({ sti }) => `${validate_component(Scene_1, "Scene").$$render($$result, { sti, id: "scene1" }, {}, {
          default: ({ scene }) => `${validate_component(PerspectiveCamera_1, "PerspectiveCamera").$$render($$result, {
            scene,
            id: "cam1",
            pos: [15, 15, 25],
            lookAt: [0, 0, 0]
          }, {}, {})}
			${validate_component(AmbientLight_1, "AmbientLight").$$render($$result, { scene, intensity: 0.5 }, {}, {})}
			${validate_component(PointLight_1, "PointLight").$$render($$result, {
            scene,
            pos: [15, 15, 25],
            intensity: 0.5,
            castShadow: true
          }, {}, {})}
			${each(books, (book2, index) => `${validate_component(Book, "Book").$$render($$result, Object.assign(book2, { scene }, { index }, { height: index }), {}, {})}`)}`
        })}
		${validate_component(WebGLRenderer_1, "WebGLRenderer").$$render($$result, {
          sti,
          sceneId: "scene1",
          camId: "cam1",
          config: { antialias: true, alpha: false }
        }, {}, {})}`
      })}
</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-324d63c6.js
var index_324d63c6_exports = {};
__export(index_324d63c6_exports, {
  default: () => Essays
});
var import_cookie5, css3, Essays;
var init_index_324d63c6 = __esm({
  ".svelte-kit/output/server/chunks/index-324d63c6.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie5 = __toModule(require_cookie());
    init_dist();
    css3 = {
      code: "main.svelte-17lqjfr{display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;padding:5%;gap:2.5vh;width:75vw}a.svelte-17lqjfr{font-family:'Roboto Mono', monospace;font-weight:bold;font-size:1.5rem}",
      map: null
    };
    Essays = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let essays = [
        {
          href: "haunted_bands_of_wroclaw",
          title: "Our Disappearing Future: Haunted Bands of Wroclaw"
        }
      ];
      $$result.css.add(css3);
      return `<main class="${"svelte-17lqjfr"}"><h1>essays</h1>
	${each(essays, ({ href, title }) => `<a href="${"essays/" + escape3(href)}" class="${"svelte-17lqjfr"}">${escape3(title)}</a>`)}
</main>`;
    });
  }
});

// .svelte-kit/output/server/chunks/haunted_bands_of_wroclaw-31520356.js
var haunted_bands_of_wroclaw_31520356_exports = {};
__export(haunted_bands_of_wroclaw_31520356_exports, {
  default: () => Haunted_bands_of_wroclaw
});
var import_cookie6, css4, Haunted_bands_of_wroclaw;
var init_haunted_bands_of_wroclaw_31520356 = __esm({
  ".svelte-kit/output/server/chunks/haunted_bands_of_wroclaw-31520356.js"() {
    init_shims();
    init_app_42ebbb40();
    init_ssr();
    import_cookie6 = __toModule(require_cookie());
    init_dist();
    css4 = {
      code: "@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500&display=swap');@import url('https://fonts.googleapis.com/css2?family=Amiri&family=Outfit:wght@500&family=Work+Sans:wght@500&display=swap');main.svelte-1lvarf8.svelte-1lvarf8{font-family:'Amiri', serif;position:relative;background-color:white;width:70vw;align-self:center}p.svelte-1lvarf8.svelte-1lvarf8{font-size:1.6rem}.definition.svelte-1lvarf8 p.svelte-1lvarf8,h1.svelte-1lvarf8.svelte-1lvarf8{padding:0;margin:0}.title-container.svelte-1lvarf8.svelte-1lvarf8{font-family:'Work Sans', sans-serif;top:5%;width:100%;position:fixed;color:white}#title.svelte-1lvarf8.svelte-1lvarf8{display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:2rem}#title.svelte-1lvarf8 h1.svelte-1lvarf8{margin:1vh;font-size:8rem}#date.svelte-1lvarf8.svelte-1lvarf8{position:absolute;top:-5vh;right:0;color:white}main.svelte-1lvarf8.svelte-1lvarf8{padding:8%;margin-top:125vh;display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start}img.svelte-1lvarf8.svelte-1lvarf8{position:fixed;object-fit:cover;width:100vw;height:100vh;z-index:-100}",
      map: null
    };
    Haunted_bands_of_wroclaw = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let blur;
      let y;
      $$result.css.add(css4);
      blur = y / 100;
      {
        console.log(blur);
      }
      return `${$$result.head += `${$$result.title = `<title>OUR DISAPPEARING FUTURE: Haunted Bands of Wroclaw</title>`, ""}`, ""}

<img src="${"../tamka.jpg"}" alt="${""}" style="${"filter: blur(" + escape3(blur) + "px); transform: scale(1.1);"}" class="${"svelte-1lvarf8"}">

<div class="${"title-container svelte-1lvarf8"}" style="${"opacity: " + escape3(100 - y / 8) + "%; transform: scale(" + escape3(1 - y / 3e3) + ");"}"><div id="${"title"}" class="${"svelte-1lvarf8"}"><h1 class="${"svelte-1lvarf8"}">OUR</h1>
		<h1 class="${"svelte-1lvarf8"}">DISAPPEARING</h1>
		<h1 class="${"svelte-1lvarf8"}">FUTURE</h1>
		<p class="${"svelte-1lvarf8"}">Haunted Bands of Wroclaw</p></div></div>

<main class="${"svelte-1lvarf8"}"><h3 id="${"date"}" class="${"svelte-1lvarf8"}">24.01.2022</h3>
	

	<p class="${"svelte-1lvarf8"}">Before diving into any arguments, I think I should address the title of this essay. It&#39;s quite a
		mouthful and it begs a number of questions. Such as: How is it possible that our future, which
		is just a temporal concept, can disappear? How is it possible for a music band to be haunted?
		And how are these two seemingly unrelated things are two sides of the same coin? All of these
		questions will be addressed as we explore these concepts together.
	</p>
	<p class="${"svelte-1lvarf8"}">You might find the arguments in this essay absolute bullshit or mildly interesting. If you read
		till the end, please let me know which side you felt closer to. In either case, I think this
		essay is a humble attempt to create some bad vibes in the time of good vibes only. After all, if
		there is nothing to compliment the good vibes, the concept of good vibes loses it&#39;s meaning and
		all vibes turn into banal flatteries which tailors a monotonous cultural fabric. And this very
		monotony is going to be the focal point of this essay.
	</p>

	<div class="${"definition svelte-1lvarf8"}"><h1 id="${"monotonous"}" class="${"svelte-1lvarf8"}">monotonous</h1>
		<p class="${"svelte-1lvarf8"}">/m\u0259\u02C8n\xE4tn\u0259s/</p>
		<i style="${"font-size: 1.6rem;"}">adjective</i>
		<p class="${"svelte-1lvarf8"}">dull, tedious, and repetitious; <b>lacking in variety and interest.</b></p></div></main>

`;
    });
  }
});

// .svelte-kit/output/server/chunks/app-42ebbb40.js
function noop3() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop3;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function custom_event(type, detail, bubbles = false) {
  const e2 = document.createEvent("CustomEvent");
  e2.initCustomEvent(type, bubbles, false, detail);
  return e2;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function escape3(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css22) => css22.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape3(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-1788d6f8.js",
      css: [assets + "/_app/assets/start-61d1577b.css", assets + "/_app/assets/vendor-eaf54bf2.css"],
      js: [assets + "/_app/start-1788d6f8.js", assets + "/_app/chunks/vendor-79c1691d.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
async function load_component(file) {
  const { entry, css: css22, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css22.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var import_cookie7, identity, current_component, escaped2, missing_component, on_destroy, css5, Root, base, assets, handle, user_hooks, template, options, default_settings, empty, manifest, get_hooks, module_lookup, metadata_lookup;
var init_app_42ebbb40 = __esm({
  ".svelte-kit/output/server/chunks/app-42ebbb40.js"() {
    init_shims();
    init_ssr();
    import_cookie7 = __toModule(require_cookie());
    init_dist();
    identity = (x2) => x2;
    Promise.resolve();
    escaped2 = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
    css5 = {
      code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
      map: null
    };
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      setContext("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page !== void 0)
        $$bindings.page(page);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      $$result.css.add(css5);
      {
        stores.page.set(page);
      }
      return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
        })}` : ``}`
      })}

${``}`;
    });
    base = "";
    assets = "";
    handle = async ({ request, resolve: resolve2 }) => {
      const cookies = import_cookie7.default.parse(request.headers.cookie || "");
      request.locals.userid = cookies.userid || v4();
      if (request.query.has("_method")) {
        request.method = request.query.get("_method").toUpperCase();
      }
      const response = await resolve2(request);
      if (!cookies.userid) {
        response.headers["set-cookie"] = import_cookie7.default.serialize("userid", request.locals.userid, {
          path: "/",
          httpOnly: true
        });
      }
      return response;
    };
    user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      handle
    });
    template = ({ head, body }) => '<!DOCTYPE html>\r\n<html lang="en">\r\n	<head>\r\n		<meta charset="utf-8" />\r\n		<meta name="description" content="Svelte demo app" />\r\n		<link rel="icon" href="/favicon.png" />\r\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\r\n		' + head + '\r\n	</head>\r\n	<body>\r\n		<div id="svelte">' + body + "</div>\r\n	</body>\r\n</html>\r\n";
    options = null;
    default_settings = { paths: { "base": "", "assets": "" } };
    empty = () => ({});
    manifest = {
      assets: [{ "file": "although/back.jpg", "size": 100276, "type": "image/jpeg" }, { "file": "although/front.jpg", "size": 100124, "type": "image/jpeg" }, { "file": "although/side.jpg", "size": 74320, "type": "image/jpeg" }, { "file": "bullshit_jobs/back.jpg", "size": 178250, "type": "image/jpeg" }, { "file": "bullshit_jobs/front.jpg", "size": 182849, "type": "image/jpeg" }, { "file": "bullshit_jobs/side.jpg", "size": 16343, "type": "image/jpeg" }, { "file": "burnout_society/back.jpg", "size": 71408, "type": "image/jpeg" }, { "file": "burnout_society/front.jpg", "size": 35419, "type": "image/jpeg" }, { "file": "burnout_society/side.jpg", "size": 4130, "type": "image/jpeg" }, { "file": "capitalist_realism/back.jpg", "size": 509560, "type": "image/jpeg" }, { "file": "capitalist_realism/front.jpg", "size": 543209, "type": "image/jpeg" }, { "file": "capitalist_realism/side.jpg", "size": 17944, "type": "image/jpeg" }, { "file": "do_nothing/front.jpg", "size": 95028, "type": "image/jpeg" }, { "file": "do_nothing/side.jpg", "size": 15477, "type": "image/jpeg" }, { "file": "favicon.ico", "size": 1150, "type": "image/vnd.microsoft.icon" }, { "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "flow/back.jpg", "size": 149201, "type": "image/jpeg" }, { "file": "flow/front.jpg", "size": 68961, "type": "image/jpeg" }, { "file": "flow/side.jpg", "size": 34234, "type": "image/jpeg" }, { "file": "ottoman_vampires/front.jpg", "size": 112747, "type": "image/jpeg" }, { "file": "ottoman_vampires/side.jpg", "size": 24826, "type": "image/jpeg" }, { "file": "performance_addiction/front.jpg", "size": 99174, "type": "image/jpeg" }, { "file": "performance_addiction/side.jpg", "size": 22977, "type": "image/jpeg" }, { "file": "robots.txt", "size": 70, "type": "text/plain" }, { "file": "tamka.jpg", "size": 248153, "type": "image/jpeg" }, { "file": "your_brain_on_porn/back.jpg", "size": 78314, "type": "image/jpeg" }, { "file": "your_brain_on_porn/front.jpg", "size": 50743, "type": "image/jpeg" }, { "file": "your_brain_on_porn/side.jpg", "size": 13307, "type": "image/jpeg" }],
      layout: "src/routes/__layout.svelte",
      error: ".svelte-kit/build/components/error.svelte",
      routes: [
        {
          type: "page",
          pattern: /^\/$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/library\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/library.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/essays\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/essays/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/essays\/haunted_bands_of_wroclaw\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/essays/haunted_bands_of_wroclaw.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        }
      ]
    };
    get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
      handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    module_lookup = {
      "src/routes/__layout.svelte": () => Promise.resolve().then(() => (init_layout_a44d6e83(), layout_a44d6e83_exports)),
      ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(() => (init_error_c7aa771f(), error_c7aa771f_exports)),
      "src/routes/index.svelte": () => Promise.resolve().then(() => (init_index_9b58d7d6(), index_9b58d7d6_exports)),
      "src/routes/library.svelte": () => Promise.resolve().then(() => (init_library_98fcbcbb(), library_98fcbcbb_exports)),
      "src/routes/essays/index.svelte": () => Promise.resolve().then(() => (init_index_324d63c6(), index_324d63c6_exports)),
      "src/routes/essays/haunted_bands_of_wroclaw.svelte": () => Promise.resolve().then(() => (init_haunted_bands_of_wroclaw_31520356(), haunted_bands_of_wroclaw_31520356_exports))
    };
    metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-7fed233a.js", "css": ["assets/pages/__layout.svelte-9b0032ba.css", "assets/vendor-eaf54bf2.css"], "js": ["pages/__layout.svelte-7fed233a.js", "chunks/vendor-79c1691d.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-0dd3cecf.js", "css": ["assets/vendor-eaf54bf2.css"], "js": ["error.svelte-0dd3cecf.js", "chunks/vendor-79c1691d.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-616c1a3c.js", "css": ["assets/pages/index.svelte-b956f94a.css", "assets/vendor-eaf54bf2.css"], "js": ["pages/index.svelte-616c1a3c.js", "chunks/vendor-79c1691d.js"], "styles": [] }, "src/routes/library.svelte": { "entry": "pages/library.svelte-57eb484c.js", "css": ["assets/pages/library.svelte-54628904.css", "assets/vendor-eaf54bf2.css"], "js": ["pages/library.svelte-57eb484c.js", "chunks/vendor-79c1691d.js"], "styles": [] }, "src/routes/essays/index.svelte": { "entry": "pages/essays/index.svelte-de75a398.js", "css": ["assets/pages/essays/index.svelte-29c2edac.css", "assets/vendor-eaf54bf2.css"], "js": ["pages/essays/index.svelte-de75a398.js", "chunks/vendor-79c1691d.js"], "styles": [] }, "src/routes/essays/haunted_bands_of_wroclaw.svelte": { "entry": "pages/essays/haunted_bands_of_wroclaw.svelte-5e9dff02.js", "css": ["assets/pages/essays/haunted_bands_of_wroclaw.svelte-80bafa07.css", "assets/vendor-eaf54bf2.css"], "js": ["pages/essays/haunted_bands_of_wroclaw.svelte-5e9dff02.js", "chunks/vendor-79c1691d.js"], "styles": [] } };
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
init_ssr();
init_app_42ebbb40();
var import_cookie8 = __toModule(require_cookie());
init_dist();

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (!rendered) {
    return {
      statusCode: 404,
      body: "Not found"
    };
  }
  const partial_response = {
    statusCode: rendered.status,
    ...split_headers(rendered.headers)
  };
  if (rendered.body instanceof Uint8Array) {
    return {
      ...partial_response,
      isBase64Encoded: true,
      body: Buffer.from(rendered.body).toString("base64")
    };
  }
  return {
    ...partial_response,
    body: rendered.body
  };
}
function split_headers(headers) {
  const h2 = {};
  const m2 = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m2 : h2;
    target[key] = value;
  }
  return {
    headers: h2,
    multiValueHeaders: m2
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
